@String{pub-ISO:adr = "Geneva, Switzerland"}

@String{pub-ISO     = "International Organization for Standardization"}

@inproceedings{abrahams.2000.exceptions-generic,
  abstract  = {This paper represents the knowledge accumulated in response to a real-world need: that the C++ Standard
               Template Library exhibit useful and well-defined interactions with exceptions, the error-handling
               mechanism built-in to the core C++ language. It explores the meaning of exception-safety, reveals
               surprising myths about exceptions and genericity, describes valuable tools for reasoning about program
               correctness, and outlines an automated testing procedure for verifying exception-safety.},
  address   = {Berlin, Heidelberg},
  author    = {Abrahams, David},
  booktitle = {Generic Programming},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David R.},
  isbn      = {978-3-540-39953-7},
  pages     = {69--79},
  publisher = {Springer Berlin Heidelberg},
  title     = {Exception-Safety in Generic Components},
  year      = {2000}
}

@software{adobe.2019.photoshop,
  author  = {Adobe},
  date    = {2021-02-09},
  title   = {Adobe Photoshop},
  url     = {https://photoshop.com/fr},
  version = {22.2}
}

@inproceedings{aksel.2020.hipsycl,
  address   = {New York, NY, USA},
  articleno = {8},
  author    = {Alpay, Aksel and Heuveline, Vincent},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  doi       = {10.1145/3388333.3388658},
  isbn      = {9781450375313},
  keywords  = {heterogeneity, SYCL, parallelism, CUDA, parallelruntimes, HIP, C++, GPU, compilers},
  location  = {Munich, Germany},
  numpages  = {1},
  publisher = {Association for Computing Machinery},
  series    = {IWOCL '20},
  title     = {SYCL beyond OpenCL: The Architecture, Current State and Future Direction of HipSYCL},
  url       = {https://doi.org/10.1145/3388333.3388658},
  year      = {2020}
}

@misc{amd.2013.acml-gpu,
  author       = {AMD},
  howpublished = {AMD},
  note         = {Available at \url{http://developer.amd.com/wordpress/media/2013/02/ACML-GPUreadme.pdf}},
  title        = {ACML-GPU - drop-in BLAS replacement, multi-GPUs accelerated},
  year         = {2013}
}

@software{anaconda.2020,
  author  = {{Anaconda, Inc.}},
  date    = {2020-11-19},
  title   = {Anaconda},
  url     = {https://anaconda.com},
  version = {2020.11}
}

@article{angulo.2007.morpho_color,
  abstract = {The extension of mathematical morphology operators to multi-valued functions, and in particular to colour
              images, is neither direct nor general. In this paper, a generalisation of distance-based and
              lexicographical-based approaches is proposed, allowing the extension of morphological operators to colour
              images for any colour representation (e.g., RGB, LSH and L*a*b*) and for any metric distance to a
              reference colour. The performance of the introduced operators is illustrated by means of different
              applications: colour feature extraction using openings (closings) by reconstruction, colour gradients for
              segmenting, colour denoising by the centre operator and colour enhancement by the contrast mapping.
              Examples from natural colour images and biomedical microscopic colour images are given.},
  author   = {Jesús Angulo},
  doi      = {https://doi.org/10.1016/j.cviu.2006.11.008},
  issn     = {1077-3142},
  journal  = {Computer Vision and Image Understanding},
  keywords = {Colour mathematical morphology, Colour distance, Multivariate ordering, Colour feature extraction,
              Colour noise removal, Colour contrast enhancement, LSH, Lab},
  note     = {Special issue on color image processing},
  number   = {1},
  pages    = {56-73},
  title    = {Morphological colour operators in totally ordered lattices based on distances: Application to image
              filtering, enhancement and analysis},
  url      = {https://www.sciencedirect.com/science/article/pii/S1077314206002165},
  volume   = {107},
  year     = {2007}
}

@book{ansi.1983.ada,
  author    = {{ANSI}},
  month     = {06},
  pages     = {333},
  publisher = {American National Standards Institute},
  title     = {{ANSI/MIL-STD-1815A}: {Programming} languages --- {Ada}},
  url       = {https://www.iso.org/standard/16028.html},
  year      = {1983}
}

@inproceedings{atkinson.1978.cluimpl,
  abstract  = {Linguistic mechanisms used in CLU to support 1) structured exception handling, 2) iteration over abstract
               objects, and 3) parameterized abstractions are briefly reviewed, and methods of realizing these
               mechanisms are described. The mechanisms discussed support features that are likely to be included in
               other programming languages, and the implementation methods should be applicable to a wide range of
               languages.},
  address   = {New York, NY, USA},
  author    = {Atkinson, Russell R. and Liskov, Barbara H. and Scheifler, Robert W.},
  booktitle = {Proceedings of the 1978 Annual Conference},
  doi       = {10.1145/800127.804079},
  isbn      = {0897910001},
  keywords  = {CLU, Iterators, Programming language, Parameterized modules, Exception handling, Implementation methods},
  location  = {Washington, D.C., USA},
  numpages  = {7},
  pages     = {123-129},
  publisher = {Association for Computing Machinery},
  series    = {ACM '78},
  title     = {Aspects Of Implementing CLU},
  url       = {https://doi.org/10.1145/800127.804079},
  year      = {1978}
}

@inproceedings{austern.2000.segmented,
  abstract  = {Many data structures are naturally segmented. Generic algorithms that ignore that feature, and that treat
               every data structure as a uniform range of elements, are unnecessarily inefficient. A new kind of
               iterator abstraction, in which segmentation is explicit, makes it possible to write hierarchical
               algorithms that exploit segmentation.},
  address   = {Berlin, Heidelberg},
  author    = {Austern, Matthew H.},
  booktitle = {Generic Programming},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David R.},
  isbn      = {978-3-540-39953-7},
  pages     = {80--90},
  publisher = {Springer Berlin Heidelberg},
  title     = {Segmented Iterators and Hierarchical Algorithms},
  year      = {2000}
}

@article{backus.1978.functional,
  abstract   = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at
                the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of
                programming inherited from their common ancestor—the von Neumann computer, their close coupling of
                semantics to state transitions, their division of programming into a world of expressions and a world of
                statements, their inability to effectively use powerful combining forms for building new programs from
                existing ones, and their lack of useful mathematical properties for reasoning about programs. An
                alternative functional style of programming is founded on the use of combining forms for creating
                programs. Functional programs deal with structured data, are often non-repetitive and non-recursive, are
                hierarchically constructed, do not name their arguments, and do not require the complex machinery of
                procedure declarations to become generally applicable. Combining forms can use high level programs to
                build still higher level ones in a style not possible in conventional languages. Associated with the
                functional style of programming is an algebra of programs whose variables range over programs and whose
                operations are combining forms. This algebra can be used to transform programs and to solve equations
                whose ``unknowns'' are programs in much the same way one transforms equations in high school algebra.
                These transformations are given by algebraic laws and are carried out in the same language in which
                programs are written. Combining forms are chosen not only for their programming power but also for the
                power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and
                termination conditions for large classes of programs. A new class of computing systems uses the
                functional programming style both in its programming language and in its state transition rules. Unlike
                von Neumann languages, these systems have semantics loosely coupled to states—only one state transition
                occurs per major computation.},
  address    = {New York, NY, USA},
  author     = {Backus, John},
  doi        = {10.1145/359576.359579},
  issn       = {0001-0782},
  issue_date = {Aug. 1978},
  journal    = {Commun. ACM},
  keywords   = {algebra of programs, models of computing systems, functional forms, combining forms,
                program termination, metacomposition, applicative state transition systems, program correctness,
                programming languages, program transformation, functional programming, von Neumann languages,
                von Neumann computers, applicative computing systems},
  month      = {08},
  number     = {8},
  numpages   = {29},
  pages      = {613-641},
  publisher  = {Association for Computing Machinery},
  title      = {Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs},
  url        = {https://doi.org/10.1145/359576.359579},
  volume     = {21},
  year       = {1978}
}

@inproceedings{badawy.2001.locality,
  abstract  = {Software prefetching and locality optimizations are techniques for overcoming the speed gap between
               processor and memory. In this paper, we evaluate the impact of memory trends on the effectiveness of
               software prefetching and locality optimizations for three types of applications: regular scientific
               codes, irregular scientific codes, and pointer-chasing codes. We find for many applications, software
               prefetching outperforms locality optimizations when there is sufficient memory bandwidth, but locality
               optimizations outperform software prefetching under bandwidth-limited conditions. The break-even point
               (for 1 Ghz processors) occurs at roughly 2.5 GBytes/sec on today's memory systems, and will increase on
               future memory systems. We also study the interactions between software prefetching and locality
               optimizations when applied in concert. Naively combining the techniques provides robustness to changes in
               memory bandwidth and latency, but does not yield additional performance gains. We propose and evaluate
               several algorithms to better integrate software prefetching and locality optimizations, including a
               modified tiling algorithm, padding for prefetching, and index prefetching.},
  address   = {New York, NY, USA},
  author    = {Badawy, Abdel-Hameed A. and Aggarwal, Aneesh and Yeung, Donald and Tseng, Chau-Wen},
  booktitle = {Proceedings of the 15th International Conference on Supercomputing},
  doi       = {10.1145/377792.377906},
  isbn      = {158113410X},
  location  = {Sorrento, Italy},
  numpages  = {15},
  pages     = {486-500},
  publisher = {Association for Computing Machinery},
  series    = {ICS '01},
  title     = {Evaluating the Impact of Memory System Performance on Software Prefetching and Locality Optimizations},
  url       = {https://doi.org/10.1145/377792.377906},
  year      = {2001}
}

@inproceedings{beazley.1996.swig,
  author    = {Beazley, David M and others},
  booktitle = {Tcl/Tk Workshop},
  pages     = {74},
  title     = {SWIG: An Easy to Use Tool for Integrating Scripting Languages with C and C++.},
  volume    = {43},
  year      = {1996}
}

@article{behnel.2010.cython,
  author   = {Behnel, S. and Bradshaw, R. and Citro, C. and Dalcin, L. and Seljebotn, D.S. and Smith, K.},
  doi      = {10.1109/MCSE.2010.118},
  issn     = {1521-9615},
  journal  = {Computing in Science Engineering},
  keywords = {Cython language; Fortran code; Python language extension; numerical loops; programming language;
              Clanguage; numerical analysis},
  month    = {03},
  number   = {2},
  pages    = {31-39},
  title    = {Cython: The Best of Both Worlds},
  volume   = {13},
  year     = {2011}
}

@misc{behnel.2022.cython-template,
  author       = {Behnel, S. and Bradshaw, R. and Seljebotn, D.S. and Dalcin, L.},
  howpublished = {https://cython.readthedocs.io/en/latest},
  note         = {Available at \url{https://cython.readthedocs.io/en/latest/src/userguide/wrapping_CPlusPlus.html\#templates}},
  title        = {Using {C}++ in {C}ython > templates},
  year         = {2022}
}

@article{bentley.1983.programming,
  author    = {Bentley, Jon},
  journal   = {Communications of the ACM},
  number    = {12},
  pages     = {1040--1045},
  publisher = {ACM New York, NY, USA},
  title     = {Programming pearls: Writing correct programs},
  volume    = {26},
  year      = {1983}
}

@book{bentley.2016.programming,
  author    = {Bentley, Jon},
  publisher = {Addison-Wesley Professional},
  title     = {Programming pearls},
  year      = {2016}
}

@article{berti.2006.gral,
  author    = {Guntram Berti},
  journal   = {Future Generation Computer Systems},
  number    = {1-2},
  pages     = {110--122},
  publisher = {Elsevier},
  title     = {{GrAL}--the Grid Algorithms Library},
  volume    = {22},
  year      = {2006}
}

@article{blackford.2002.blas,
  author  = {Blackford, L Susan and Petitet, Antoine and Pozo, Roldan and Remington, Karin and Whaley, R Clint and
             Demmel, James and Dongarra, Jack and Duff, Iain and Hammarling, Sven and Henry, Greg and others},
  journal = {ACM Transactions on Mathematical Software},
  number  = {2},
  pages   = {135--151},
  title   = {An updated set of basic linear algebra subprograms (BLAS)},
  volume  = {28},
  year    = {2002}
}

@article{boehm.1984.economics,
  abstract = {This paper summarizes the current state of the art and recent trends in software engineering economics. It
              provides an overview of economic analysis techniques and their applicability to software engineering and
              management. It surveys the field of software cost estimation, including the major estimation techniques
              available, the state of the art in algorithmic cost models, and the outstanding research issues in
              software cost estimation.},
  author   = {Boehm, Barry W.},
  doi      = {10.1109/TSE.1984.5010193},
  issn     = {1939-3520},
  journal  = {IEEE Transactions on Software Engineering},
  keywords = {},
  month    = {01},
  number   = {1},
  pages    = {4-21},
  title    = {Software Engineering Economics},
  volume   = {SE-10},
  year     = {1984}
}

@software{boost.2021,
  author  = {Boost},
  date    = {2021-04-16},
  title   = {Boost C++ Libraries},
  url     = {https://www.boost.org/},
  version = {1.76.0}
}

@book{bourbaki.1970.theorie,
  author    = {Bourbaki, Nicolas},
  publisher = {Hermann Paris},
  title     = {Th{\'e}orie des ensembles},
  volume    = {1},
  year      = {1970}
}

@misc{bourdev.2006.bgil,
  author       = {Lubomir Bourdev and Hailin Jin},
  howpublished = {{A}dobe stlab},
  note         = {Available at \url{https://stlab.adobe.com/gil/index.html}},
  title        = {{B}oost {G}eneric {I}mage {L}ibrary},
  year         = {2006}
}

@article{bourdev.2011.runtimedispatch,
  author   = {Lubomir Bourdev and Jaakko Järvi},
  doi      = {https://doi.org/10.1016/j.scico.2008.06.003},
  issn     = {0167-6423},
  journal  = {Science of Computer Programming},
  keywords = {Generic programming, C++ templates, Template bloat, Template
              metaprogramming},
  note     = {Special issue on library-centric software design (LCSD 2006)},
  number   = {4},
  pages    = {243 - 257},
  title    = {Efficient run-time dispatching in generic programming with minimal code bloat},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167642308000634},
  volume   = {76},
  year     = {2011}
}

@article{bradski.2000.opencv,
  author               = {Bradski, G.},
  citeulike-article-id = {2236121},
  journal              = {Dr. Dobb's Journal of Software Tools},
  keywords             = {bibtex-import},
  posted-at            = {2008-01-15 19:21:54},
  priority             = {4},
  title                = {{The OpenCV Library}},
  year                 = {2000}
}

@inproceedings{brown.2018.ranges,
  author    = {Brown, G. and Di Bella, C. and Haidl, M. and Remmelg, T. and
               Reyes, R. and Steuwer, M.},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  pages     = {1--5},
  title     = {Introducing Parallelism to the Ranges {TS}},
  year      = {2018}
}

@inproceedings{brown.2019.heterogeneous,
  acmid     = {3318196},
  address   = {New York, NY, USA},
  articleno = {18},
  author    = {Brown, Gordon and Reyes, Ruyman and Wong, Michael},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  doi       = {10.1145/3318170.3318196},
  isbn      = {978-1-4503-6230-6},
  keywords  = {C++, concurrency, distributed programming models, executors,
               heterogeneous programming, parallelism},
  location  = {Boston, MA, USA},
  numpages  = {5},
  pages     = {18:1--18:5},
  publisher = {ACM},
  series    = {IWOCL'19},
  title     = {Towards Heterogeneous and Distributed Computing in C++},
  url       = {http://doi.acm.org/10.1145/3318170.3318196},
  year      = {2019}
}

@inproceedings{burrus.2003.mpool,
  abstract     = {Object-oriented and generic programming are both supported in C++. OOP provides high expressiveness
                  whereas GP leads to more efficient programs by avoiding dynamic typing. This paper presents SCOOP, a
                  new paradigm which enables both classical OO design and high performance in C++ by mixing OOP and GP.
                  We show how classical and advanced OO features such as virtual methods, multiple inheritance, argument
                  covariance, virtual types and multimethods can be implemented in a fully statically typed model, hence
                  without run-time overhead.},
  address      = {Anaheim, CA, USA},
  author       = {Nicolas Burrus and Alexandre Duret-Lutz and Thierry G\'eraud and David Lesage and Rapha\"el Poss},
  booktitle    = {Proceedings of the Workshop on Multiple Paradigm with Object-Oriented Languages (MPOOL)},
  lrdenewsdate = {2003-10-29},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/mpool03-abstract.pdf},
  lrdeprojects = {Olena},
  month        = {10},
  title        = {A static {C++} object-oriented programming ({SCOOP}) paradigm mixing benefits of traditional {OOP} and
                  generic programming},
  year         = 2003
}

@techreport{c++.2020.stddraftN4849,
  author       = {Richard Smith},
  institution  = {International Organization for Standardization},
  month        = {01},
  note         = {{\small\url{https://wg21.link/n4849}}},
  optpublisher = {WG21},
  title        = {{N4849}: Working Draft, Standard for Programming Language {C++}},
  year         = 2020
}

@article{carlinet.2014.tip,
  author   = {Edwin Carlinet and Thierry G\'eraud},
  journal  = {IEEE Transactions on Image Processing},
  number   = {9},
  optmonth = {September},
  pages    = {3885--3895},
  title    = {A Comparative Review of Component Tree Computation Algorithms},
  volume   = {23},
  year     = {2014}
}

@article{carlinet.2015.tip,
  author   = {Edwin Carlinet and Thierry G\'eraud},
  journal  = {IEEE Transactions on Image Processing},
  number   = {12},
  optmonth = {December},
  pages    = {5330--5342},
  title    = {{MToS}: {A} Tree of Shapes for Multivariate Images},
  volume   = {24},
  year     = {2015}
}

@misc{carlinet.2018.pylena,
  author       = {Edwin Carlinet and others},
  howpublished = {{EPITA} Research and Developement Laboratory},
  note         = {Available at \url{https://gitlab.lrde.epita.fr/olena/pylene}},
  title        = {{P}ylena: a Modern {C}++ Image Processing Generic
                  Library},
  year         = {2018}
}

@misc{carter.2018.concepts,
  author       = {Casey Carter and Eric Niebler},
  key          = {P0898r3},
  month        = {06},
  organization = {WG21},
  title        = {Standard Library Concepts},
  url          = {https://wg21.link/p0898r3},
  year         = {2018}
}

@online{chollet.2015.keras,
  author    = {Chollet, Francois and others},
  publisher = {GitHub},
  title     = {Keras},
  url       = {https://github.com/fchollet/keras},
  year      = {2015}
}

@software{clark.2021.pillow,
  author  = {{Alex Clark and al.}},
  date    = {2021-03-06},
  title   = {Pillow},
  url     = {https://python-pillow.org},
  version = {8.1.2}
}

@software{codeplay.2021.computecpp,
  author  = {Codeplay},
  title   = {ComputeCpp},
  url     = {https://codeplay.com/products/computesuite/computecpp},
  version = {2.8.0}
}

@misc{coeurjolly.2016.dgtal,
  author = {Coeurjolly, D and Lachaud, JO and Kerautret, B},
  title  = {DGtal: Digital geometry tools and algorithms library},
  year   = {2016}
}

@inbook{coplien.1996.crtp,
  address   = {USA},
  author    = {Coplien, James O.},
  booktitle = {C++ Gems},
  isbn      = {1884842372},
  numpages  = {10},
  pages     = {135-144},
  publisher = {SIGS Publications, Inc.},
  title     = {Curiously Recurring Template Patterns},
  year      = {1996}
}

@article{curtsinger.2013.stabilizer-art,
  abstract   = {Researchers and software developers require effective performance evaluation. Researchers must evaluate
                optimizations or measure overhead. Software developers use automatic performance regression tests to
                discover when changes improve or degrade performance. The standard methodology is to compare execution
                times before and after applying changes. Unfortunately, modern architectural features make this approach
                unsound. Statistically sound evaluation requires multiple samples to test whether one can or cannot
                (with high confidence) reject the null hypothesis that results are the same before and after. However,
                caches and branch predictors make performance dependent on machine-specific parameters and the exact
                layout of code, stack frames, and heap objects. A single binary constitutes just one sample from the
                space of program layouts, regardless of the number of runs. Since compiler optimizations and code
                changes also alter layout, it is currently impossible to distinguish the impact of an optimization from
                that of its layout effects. This paper presents Stabilizer, a system that enables the use of the
                powerful statistical techniques required for sound performance evaluation on modern architectures.
                Stabilizer forces executions to sample the space of memory configurations by repeatedly re-randomizing
                layouts of code, stack, and heap objects at runtime. Stabilizer thus makes it possible to control for
                layout effects. Re-randomization also ensures that layout effects follow a Gaussian distribution,
                enabling the use of statistical tests like ANOVA. We demonstrate Stabilizer's efficiency (< 7\% median
                overhead) and its effectiveness by evaluating the impact of LLVM's optimizations on the SPEC CPU2006
                benchmark suite. We find that, while -O2 has a significant impact relative to -O1, the performance
                impact of -O3 over -O2 optimizations is indistinguishable from random noise.},
  address    = {New York, NY, USA},
  author     = {Curtsinger, Charlie and Berger, Emery D.},
  doi        = {10.1145/2490301.2451141},
  issn       = {0163-5964},
  issue_date = {March 2013},
  journal    = {SIGARCH Comput. Archit. News},
  keywords   = {measurement bias, performance evaluation, randomization},
  month      = {03},
  number     = {1},
  numpages   = {10},
  pages      = {219-228},
  publisher  = {Association for Computing Machinery},
  title      = {STABILIZER: Statistically Sound Performance Evaluation},
  url        = {https://doi.org/10.1145/2490301.2451141},
  volume     = {41},
  year       = {2013}
}

@inproceedings{curtsinger.2013.stabilizer-proc,
  abstract  = {Researchers and software developers require effective performance evaluation. Researchers must evaluate
               optimizations or measure overhead. Software developers use automatic performance regression tests to
               discover when changes improve or degrade performance. The standard methodology is to compare execution
               times before and after applying changes. Unfortunately, modern architectural features make this approach
               unsound. Statistically sound evaluation requires multiple samples to test whether one can or cannot
               (with high confidence) reject the null hypothesis that results are the same before and after. However,
               caches and branch predictors make performance dependent on machine-specific parameters and the exact
               layout of code, stack frames, and heap objects. A single binary constitutes just one sample from the
               space of program layouts, regardless of the number of runs. Since compiler optimizations and code
               changes also alter layout, it is currently impossible to distinguish the impact of an optimization from
               that of its layout effects. This paper presents Stabilizer, a system that enables the use of the
               powerful statistical techniques required for sound performance evaluation on modern architectures.
               Stabilizer forces executions to sample the space of memory configurations by repeatedly re-randomizing
               layouts of code, stack, and heap objects at runtime. Stabilizer thus makes it possible to control for
               layout effects. Re-randomization also ensures that layout effects follow a Gaussian distribution,
               enabling the use of statistical tests like ANOVA. We demonstrate Stabilizer's efficiency (< 7\% median
               overhead) and its effectiveness by evaluating the impact of LLVM's optimizations on the SPEC CPU2006
               benchmark suite. We find that, while -O2 has a significant impact relative to -O1, the performance
               impact of -O3 over -O2 optimizations is indistinguishable from random noise.},
  address   = {New York, NY, USA},
  author    = {Curtsinger, Charlie and Berger, Emery D.},
  booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages
               and Operating Systems},
  doi       = {10.1145/2451116.2451141},
  isbn      = {9781450318709},
  journal   = {SIGARCH Comput. Archit. News},
  keywords  = {measurement bias, randomization, performance evaluation},
  location  = {Houston, Texas, USA},
  numpages  = {10},
  pages     = {219-228},
  publisher = {Association for Computing Machinery},
  series    = {ASPLOS '13},
  title     = {STABILIZER: Statistically Sound Performance Evaluation},
  url       = {https://doi.org/10.1145/2451116.2451141},
  year      = {2013}
}

@inproceedings{curtsinger.2015.coz,
  abstract  = {Improving performance is a central concern for software developers. To locate optimization opportunities,
               developers rely on software profilers. However, these profilers only report where programs spent their
               time: optimizing that code may have no impact on performance. Past profilers thus both waste developer
               time and make it difficult for them to uncover significant optimization opportunities. This paper
               introduces causal profiling. Unlike past profiling approaches, causal profiling indicates exactly where
               programmers should focus their optimization efforts, and quantifies their potential impact. Causal
               profiling works by running performance experiments during program execution. Each experiment calculates
               the impact of any potential optimization by virtually speeding up code: inserting pauses that slow down
               all other code running concurrently. The key insight is that this slowdown has the same relative effect
               as running that line faster, thus "virtually" speeding it up. We present Coz, a causal profiler, which we
               evaluate on a range of highly-tuned applications: Memcached, SQLite, and the PARSEC benchmark suite. Coz
               identifies previously unknown optimization opportunities that are both significant and targeted. Guided
               by Coz, we improve the performance of Memcached by 9\%, SQLite by 25\%, and accelerate six PARSEC
               applications by as much as 68\%; in most cases, these optimizations involve modifying under 10 lines of
               code.},
  address   = {New York, NY, USA},
  author    = {Curtsinger, Charlie and Berger, Emery D.},
  booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
  doi       = {10.1145/2815400.2815409},
  isbn      = {9781450338349},
  location  = {Monterey, California},
  numpages  = {14},
  pages     = {184-197},
  publisher = {Association for Computing Machinery},
  series    = {SOSP '15},
  title     = {Coz: Finding Code That Counts with Causal Profiling},
  url       = {https://doi.org/10.1145/2815400.2815409},
  year      = {2015}
}

@inproceedings{czarnecki.2000.generative,
  abstract  = {We describe generative programming, an approach to generating customized programming components or
               systems, and active libraries, which are based on this approach. In contrast to conventional libraries,
               active libraries may contain metaprograms that implement domain-specific code generation, optimizations,
               debugging, profiling and testing. Several working examples (Blitz++, GMCL, Xroma) are presented to
               illustrate the potential of active libraries. We discuss relevant implementation technologies.},
  address   = {Berlin, Heidelberg},
  author    = {Czarnecki, Krzysztof and Eisenecker, Ulrich and Gl{\"u}ck, Robert and Vandevoorde, David and
               Veldhuizen, Todd},
  booktitle = {Generic Programming},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David R.},
  isbn      = {978-3-540-39953-7},
  pages     = {25--39},
  publisher = {Springer Berlin Heidelberg},
  title     = {Generative Programming and Active Libraries},
  url       = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.646.8822&rep=rep1&type=pdf},
  year      = {2000}
}

@inproceedings{darbon.2002.ismm,
  abstract     = {Several libraries dedicated to mathematical morphology exist. But they lack genericity, that is to
                  say, the ability for operators to accept input of different natures --- 2D binary images, graphs
                  enclosing floating values, etc. We describe solutions which are integrated in Olena, a library
                  providing morphological operators. We demonstrate with some examples that translating mathematical
                  formulas and algorithms into source code is made easy and safe with Olena. Moreover, experimental
                  results show that no extra costs at run-time are induced.},
  address      = {Sydney, Australia},
  author       = {J\'er\^ome Darbon and Thierry G\'eraud and Alexandre Duret-Lutz},
  booktitle    = {Mathematical Morphology, Proceedings of the 6th International Symposium (ISMM)},
  lrdeprojects = {Olena},
  month        = {04},
  pages        = {175--184},
  publisher    = {CSIRO Publishing},
  title        = {Generic implementation of morphological image operators},
  year         = 2002
}

@inproceedings{darbon.2004.ecoopphd,
  abstract     = {This paper deals with the implementation of algorithms in the specific domain of image processing.
                  Although many image processing libraries are available, they generally lack genericity and
                  flexibility. Many image processing algorithms can be expressed as compositions of elementary
                  algorithmic operations referred to as blocks. Implementing these compositions is achieved using
                  generic programming. Our solution is compared to previous ones, and we demonstrate it on a class image
                  processing algorithms.},
  address      = {Oslo, Norway},
  author       = {J\'er\^ome Darbon and Thierry G\'eraud and Patrick Bellot},
  booktitle    = {Proceedings of the ECOOP Workshop for PhD Students},
  lrdenewsdate = {2004-03-10},
  lrdeprojects = {Olena},
  month        = {06},
  title        = {Generic algorithmic blocks dedicated to image processing},
  year         = 2004
}

@article{dean.2008.mapreduce,
  abstract   = {MapReduce is a programming model and an associated implementation for processing and generating large
                datasets that is amenable to a broad variety of real-world tasks. Users specify the computation in terms
                of a map and a reduce function, and the underlying runtime system automatically parallelizes the
                computation across large-scale clusters of machines, handles machine failures, and schedules
                inter-machine communication to make efficient use of the network and disks. Programmers find the system
                easy to use: more than ten thousand distinct MapReduce programs have been implemented internally at
                Google over the past four years, and an average of one hundred thousand MapReduce jobs are executed on
                Google's clusters every day, processing a total of more than twenty petabytes of data per day.},
  address    = {New York, NY, USA},
  author     = {Dean, Jeffrey and Ghemawat, Sanjay},
  doi        = {10.1145/1327452.1327492},
  issn       = {0001-0782},
  issue_date = {January 2008},
  journal    = {Commun. ACM},
  month      = {01},
  number     = {1},
  numpages   = {7},
  pages      = {107-113},
  publisher  = {Association for Computing Machinery},
  title      = {MapReduce: Simplified Data Processing on Large Clusters},
  url        = {https://doi.org/10.1145/1327452.1327492},
  volume     = {51},
  year       = {2008}
}

@misc{dean.2019.monoids,
  author    = {Ben Dean},
  month     = {06},
  note      = {Slides available at
               \url{https://github.com/boostcon/cppnow_presentations_2019/blob/master/05-09-2019_thursday/Identifying_Monoids_Exploiting_Compositional_Structure_in_Code__Ben_Deane_cppnow_05092019.pdf},
               Talk available on youtube at \url{https://youtu.be/INnattuluiM}},
  publisher = {{C++Now} 2019},
  title     = {Identifying Monoids: Exploiting Compositional Structure in Code},
  url       = {https://cppnow2019.sched.com/event/b60160aa659270370279c5acb6196fb6},
  year      = {2019}
}

@inproceedings{dehnert.1998.fundamentals,
  author       = {James C. Dehnert and Alexander Stepanov},
  booktitle    = {Generic Programming},
  errbooktitle = {Intl. Symp. on Symbolic and Algebraic Computation},
  optmonth     = {apr},
  organization = {Springer},
  pages        = {1--11},
  series       = {LNCS},
  title        = {Fundamentals of Generic Programming},
  volume       = {1766},
  year         = 2000
}

@inproceedings{demaille.2013.vcsn,
  abstract  = {Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It
               is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten
               years ago, several shortcomings were discovered along the years, especially problems related to code
               complexity and obfuscation as well as performance issues. This paper presents the concepts underlying
               Vaucanson 2, a complete rewrite of the platform that addresses these issues.},
  address   = {Berlin, Heidelberg},
  author    = {Demaille, Akim and Duret-Lutz, Alexandre and Lombardy, Sylvain and Sakarovitch, Jacques},
  booktitle = {Implementation and Application of Automata},
  editor    = {Konstantinidis, Stavros},
  isbn      = {978-3-642-39274-0},
  pages     = {122--133},
  publisher = {Springer Berlin Heidelberg},
  title     = {Implementation Concepts in Vaucanson 2},
  year      = {2013}
}

@inproceedings{dewitte.2005.morpho_color,
  abstract  = {In this paper we extend the basic morphological operators dilation and erosion for grey-scale images
               based on the threshold approach, umbra approach and fuzzy set theory to colour images. This is realised
               by treating colours as vectors and defining a new vector ordering so that new colour morphological
               operators are presented. Here we only discuss colours represented in the RGB colour space. The colour
               space RGB becomes together with the new ordering and associated minimum and maximum operators a complete
               chain. All this can be extended to the colour spaces HSV and L*a*b*. Experimental results show that our
               method provides an improvement on the component-based approach of morphological operators applied to
               colour images. The colours in the colour images are preserved, that is, no new colours are introduced.},
  address   = {Berlin, Heidelberg},
  author    = {De Witte, Val{\'e}rie and Schulte, Stefan and Nachtegael, Mike and Van der Weken, Dietrich and
               Kerre, Etienne E.},
  booktitle = {Image Analysis and Recognition},
  editor    = {Kamel, Mohamed and Campilho, Aur{\'e}lio},
  isbn      = {978-3-540-31938-2},
  pages     = {667--675},
  publisher = {Springer Berlin Heidelberg},
  title     = {Vector Morphological Operators for Colour Images},
  year      = {2005}
}

@software{dionne.2021.metabench,
  author  = {Louis Dionne},
  date    = {2019-09-16},
  title   = {Metabench},
  url     = {https://github.com/ldionne/metabench/},
  version = {head}
}

@article{dosries.2066.specifying.art,
  abstract   = {C++ templates are key to the design of current successful mainstream libraries and systems. They are the
                basis of programming techniques in diverse areas ranging from conventional general-purpose programming
                to software for safety-critical embedded systems. Current work on improving templates focuses on the
                notion of concepts (a type system for templates), which promises significantly improved error
                diagnostics and increased expressive power such as concept-based overloading and function template
                partial specialization. This paper presents C++ templates with an emphasis on problems related to
                separate compilation. We consider the problem of how to express concepts in a precise way that is simple
                enough to be usable by ordinary programmers. In doing so, we expose a few weaknesses of the current
                specification of the C++ standard library and suggest a far more precise and complete specification. We
                also present a systematic way of translating our proposed concept definitions, based on use-patterns
                rather than function signatures, into constraint sets that can serve as convenient basis for concept
                checking in a compiler.},
  address    = {New York, NY, USA},
  author     = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  doi        = {10.1145/1111320.1111064},
  issn       = {0362-1340},
  issue_date = {January 2006},
  journal    = {SIGPLAN Not.},
  keywords   = {C++ concepts, C++ templates, separate compilation, generic programming, type systems},
  month      = {01},
  number     = {1},
  numpages   = {14},
  pages      = {295-308},
  publisher  = {Association for Computing Machinery},
  title      = {Specifying C++ Concepts},
  url        = {https://doi.org/10.1145/1111320.1111064},
  volume     = {41},
  year       = {2006}
}

@inproceedings{dosries.2066.specifying.proc,
  abstract  = {C++ templates are key to the design of current successful mainstream libraries and systems. They are the
               basis of programming techniques in diverse areas ranging from conventional general-purpose programming to
               software for safety-critical embedded systems. Current work on improving templates focuses on the notion
               of concepts (a type system for templates), which promises significantly improved error diagnostics and
               increased expressive power such as concept-based overloading and function template partial
               specialization. This paper presents C++ templates with an emphasis on problems related to separate
               compilation. We consider the problem of how to express concepts in a precise way that is simple enough to
               be usable by ordinary programmers. In doing so, we expose a few weaknesses of the current specification
               of the C++ standard library and suggest a far more precise and complete specification. We also present a
               systematic way of translating our proposed concept definitions, based on use-patterns rather than
               function signatures, into constraint sets that can serve as convenient basis for concept checking in a
               compiler.},
  address   = {New York, NY, USA},
  author    = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  doi       = {10.1145/1111037.1111064},
  isbn      = {1595930272},
  keywords  = {C++ concepts, generic programming, type systems, C++ templates, separate compilation},
  location  = {Charleston, South Carolina, USA},
  numpages  = {14},
  pages     = {295-308},
  publisher = {Association for Computing Machinery},
  series    = {POPL '06},
  title     = {Specifying C++ Concepts},
  url       = {https://doi.org/10.1145/1111037.1111064},
  year      = {2006}
}

@inproceedings{duretlutz.2000.olena,
  author       = {Duret-Lutz, Alexandre},
  booktitle    = {symposium on Generative and Component-Based Software Engineering, Young Researchers Workshop},
  organization = {Citeseer},
  title        = {Olena: a component-based platform for image processing, mixing generic, generative and OO programming},
  volume       = {10},
  year         = {2000}
}

@inproceedings{esterie.2014.boostsimd,
  acmid     = {2568063},
  address   = {New York, NY, USA},
  author    = {Est{\'e}rie, Pierre and Falcou, Joel and Gaunard, Mathias and Laprest{\'e}, Jean-Thierry},
  booktitle = {Proceedings of the 2014 Workshop on Programming Models for SIMD/Vector Processing},
  doi       = {10.1145/2568058.2568063},
  isbn      = {978-1-4503-2653-7},
  keywords  = {SIMD, c++, generic programming, template meta-programming},
  location  = {Orlando, Florida, USA},
  numpages  = {8},
  pages     = {1--8},
  publisher = {ACM},
  series    = {WPMVP '14},
  title     = {Boost.SIMD: Generic Programming for Portable SIMDization},
  url       = {http://doi.acm.org/10.1145/2568058.2568063},
  year      = {2014}
}

@book{etter.1993.engineering,
  author    = {Etter, Delores M and Etter, Dolores M and Etter, Delores M},
  publisher = {Prentice Hall Englewood cliffs, New Jersey 07632},
  title     = {Engineering problem solving with MATLAB},
  volume    = {2},
  year      = {1993}
}

@book{etter.2002.introduction,
  author    = {Etter, Delores M and Kuncicky, David C and Hull, Douglas W},
  publisher = {Prentice Hall},
  title     = {Introduction to MATLAB},
  year      = {2002}
}

@article{fernique.2018.autowig,
  author    = {Fernique, Pierre and Pradal, Christophe},
  journal   = {PeerJ Computer Science},
  pages     = {e149},
  publisher = {PeerJ Inc.},
  title     = {AutoWIG: automatic generation of python bindings for C++ libraries},
  url       = {https://peerj.com/articles/cs-149.pdf},
  volume    = {4},
  year      = {2018}
}

@inbook{floyd.1993.meaning,
  abstract  = {This paper attempts to provide an adequate basis for formal definitions of the meanings of programs in
               appropriately defined programming languages, in such a way that a rigorous standard is established for
               proofs about computer programs, including proofs of correctness, equivalence, and termination. The basis
               of our approach is the notion of an interpretation of a program: that is, an association of a proposition
               with each connection in the flow of control through a program, where the proposition is asserted to hold
               whenever that connection is taken. To prevent an interpretation from being chosen arbitrarily, a
               condition is imposed on each command of the program. This condition guarantees that whenever a command is
               reached by way of a connection whose associated proposition is then true, it will be left (if at all) by
               a connection whose associated proposition will be true at that time. Then by induction on the number of
               commands executed, one sees that if a program is entered by a connection whose associated proposition is
               then true, it will be left (if at all) by a connection whose associated proposition will be true at that
               time. By this means, we may prove certain properties of programs, particularly properties of the form:
               `If the initial values of the program variables satisfy the relation Rl, the final values on completion
               will satisfy the relation R2'.},
  address   = {Dordrecht},
  author    = {Floyd, Robert W.},
  booktitle = {Program Verification: Fundamental Issues in Computer Science},
  doi       = {10.1007/978-94-011-1793-7_4},
  editor    = {Colburn, Timothy R. and Fetzer, James H. and Rankin, Terry L.},
  isbn      = {978-94-011-1793-7},
  pages     = {65--81},
  publisher = {Springer Netherlands},
  title     = {Assigning Meanings to Programs},
  url       = {https://doi.org/10.1007/978-94-011-1793-7_4},
  year      = {1993}
}

@misc{fog.2013.vcl,
  author = {Fog, Agner},
  note   = {\url{http://www.agner.org/optimize/vectorclass.pdf}},
  pages  = {33},
  title  = {{C}++ vector class library},
  year   = {2013}
}

@misc{froment.2004.megawave2,
  author = {Froment, Jacques},
  title  = {MegaWave2 user's guide},
  year   = {2004}
}

@inproceedings{froment.2012.megawave,
  address     = {France},
  author      = {Froment, Jacques},
  booktitle   = {{IPOL 2012 Meeting on Image Processing Libraries}},
  hal_id      = {hal-00907378},
  hal_version = {v1},
  month       = {06},
  title       = {{MegaWave}},
  url         = {https://hal.archives-ouvertes.fr/hal-00907378},
  year        = {2012}
}

@book{gamma.1995.design,
  author    = {Erich Gamma},
  publisher = {Pearson Education India},
  title     = {Design patterns: elements of reusable object-oriented software},
  year      = {1995}
}

@inproceedings{garrigues.2014.video++,
  author       = {Matthieu Garrigues and Antoine Manzanera},
  booktitle    = {Conference on Design and Architectures for Signal and Image Processing (DASIP)},
  organization = {IEEE},
  pages        = {1--6},
  title        = {Video++, a modern image and video processing {C}++ framework},
  year         = {2014}
}

@inproceedings{geraud.2000.europlop,
  abstract     = {This pattern faces the problem of improving the performances of design patterns when they are involved
                  in intensive algorithms. Generic programming is a paradigm in which most classes and procedures are
                  parameterized, thus leading to the construction of general and efficient software components. We
                  demonstrate that some design patterns from Gamma et al. can be translated into this paradigm while
                  handling operation polymorphism by parametric polymorphism. We thus preserve their modularity and
                  reusability properties but we avoid the performance penalty due to their dynamic behavior, which is a
                  critical issue in numerical computing.},
  address      = {Irsee, Germany},
  author       = {Thierry G\'eraud and Alexandre Duret-Lutz},
  booktitle    = {Proceedings of the 5th European Conference on Pattern Languages of Programs (EuroPLoP)},
  editors      = {M. Devos and A. R\"uping},
  lrdekeywords = {Software engineering},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/europlop00.pdf},
  lrdeprojects = {Software},
  month        = {07},
  pages        = {283--294},
  publisher    = {UVK, Univ. Verlag, Konstanz},
  title        = {Generic programming redesign of patterns},
  year         = 2000
}

@inproceedings{geraud.2000.icpr,
  abstract     = {Algorithm libraries dedicated to image processing and pattern recognition are not reusable; to run an
                  algorithm on particular data, one usually has either to rewrite the algorithm or to manually ``copy,
                  paste, and modify''. This is due to the lack of genericity of the programming paradigm used to
                  implement the libraries. In this paper, we present a recent paradigm that allows algorithms to be
                  written once and for all and to accept input of various types. Moreover, this total reusability can be
                  obtained with a very comprehensive writing and without significant cost at execution, compared to a
                  dedicated algorithm. This new paradigm is called ``generic programming'' and is fully supported by the
                  C++ language. We show how this paradigm can be applied to image processing and pattern recognition
                  routines. The perspective of our work is the creation of a generic library.},
  address      = {Barcelona, Spain},
  author       = {Thierry G\'eraud and Yoann Fabre and Alexandre Duret-Lutz and Dimitri Papadopoulos-Orfanos and
                  Jean-Fran\c{c}ois Mangin},
  booktitle    = {Proceedings of the 15th International Conference on Pattern Recognition (ICPR)},
  lrdeprojects = {Olena},
  month        = {09},
  pages        = {816--819},
  publisher    = {IEEE Computer Society},
  title        = {Obtaining genericity for image processing and pattern recognition algorithms},
  volume       = 4,
  year         = 2000
}

@misc{geraud.2006.scoop-pres,
  author       = {Thierry G\'eraud},
  howpublished = {\url{http://www.lrde.epita.fr/people/theo/pub/olena/olena-06-jan.pdf}},
  month        = {01},
  project      = {Olena},
  title        = {Advanced Static Object-Oriented Programming Features: A Sequel to {SCOOP}},
  urllrde      = {200601-TR},
  year         = 2006
}

@inproceedings{geraud.2008.mpool,
  abstract     = {Classical (unbounded) genericity in \Cxx{}03 defines the interactions between generic data types and
                  algorithms in terms of concepts. Concepts define the requirements over a type (or a parameter) by
                  expressing constraints on its methods and dependent types (typedefs). The upcoming \Cxx{}0x standard
                  will promote concepts from abstract entities (not directly enforced by the tools) to language
                  constructs, enabling compilers and tools to perform additional checks on generic constructs as well as
                  enabling new features (e.g., concept-based overloading). Most modern languages support this notion of
                  signature on generic types. However, generic types built on other types and relying on concepts to
                  both ensure type conformance and drive code specialization, restrain the interface and the
                  implementation of the newly created type: specific methods and associated types not mentioned in the
                  concept will not be part of the new type. The paradigm of concept-based genericity lacks the required
                  semantics to transform types while retaining or adapting their intrinsic capabilities. We present a
                  new form of semantically-enriched genericity allowing static generic type transformations through a
                  simple form of type introspection based on type metadata called properties. This approach relies on a
                  new Static \Cxx Object-Oriented Programming (SCOOP) paradigm, and is adapted to the creation of
                  generic and efficient libraries, especially in the field of scientific computing. Our proposal uses a
                  metaprogramming facility built into a \Cxx library called Static, and doesn't require any language
                  extension nor additional processing (preprocessor, transformation tool).},
  address      = {Paphos, Cyprus},
  author       = {Thierry G\'eraud and Roland Levillain},
  booktitle    = {Proceedings of the 6th International Workshop on Multiparadigm Programming with Object-Oriented
                  Languages (MPOOL)},
  lrdenewsdate = {2008-05-26},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/geraud.08.mpool.pdf},
  lrdeprojects = {Olena},
  month        = {07},
  title        = {Semantics-Driven Genericity: A Sequel to the Static {C++} Object-Oriented Programming Paradigm
                  ({SCOOP 2})},
  year         = 2008
}

@incollection{geraud.2010.book,
  author       = {Thierry G\'eraud and Hugues Talbot and Marc Van Droogenbroeck},
  booktitle    = {Mathematical Morphology---From Theory to Applications},
  crossref     = {najman.2013.mathematical},
  editor       = {Laurent Najman and Hugues Talbot},
  isbn         = {978-1-84821-215-2},
  lrdekeywords = {Image},
  month        = {07},
  pages        = {323--353},
  publisher    = {Wiley-ISTE},
  title        = {Algorithms for Mathematical Morphology},
  url          = {http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1848212151.html},
  year         = 2010
}

@phdthesis{geraud.2012.hdr,
  author      = {Thierry G\'eraud},
  lrdepaper   = {http://www.lrde.epita.fr/~theo/papers/geraud.2012.hdr.pdf},
  lrdeproject = {Olena},
  lrdeslides  = {http://www.lrde.epita.fr/~theo/slides/geraud.2012.hdr_slides.pdf},
  month       = {06},
  note        = {In French},
  school      = {Universit\'e Paris-Est},
  title       = {Outil logiciel pour le traitement d'images: Biblioth\`eque, paradigmes, types et algorithmes},
  type        = {Habilitation Thesis},
  year        = 2012
}

@misc{geraud.2012.ipolmeeting,
  author       = {Thierry G\'eraud and Roland Levillain and Guillaume Lazzara},
  howpublished = {{IPOL} meeting, {ENS} Cachan, France},
  month        = {06},
  title        = {The {M}ilena Image Processing Library},
  url          = {https://www.lrde.epita.fr/~theo/talks/geraud.2012.ipol_talk.pdf},
  year         = {2012}
}

@misc{geraud.2018.gtgdmm,
  author       = {Thierry G\'eraud and Edwin Carlinet},
  howpublished = {Journ\'ee du Groupe de Travail de G\'eom\'etrie Discrète et Morphologie Math\'ematique, Lyon, France},
  month        = {06},
  title        = {A Modern {C++} Library for Generic and Efficient Image Processing},
  url          = {https://www.lrde.epita.fr/~theo/talks/geraud.2018.gtgdmm_talk.pdf},
  year         = {2018}
}

@article{gibbons.2007.datatype,
  author    = {Gibbons, Jeremy},
  journal   = {Datatype-Generic Programming: International Spring School, {SSDGP} 2006, Nottingham, {UK}, April 24-27,
               2006, Revised Lectures},
  pages     = {1},
  publisher = {Springer Science \& Business Media},
  title     = {Datatype-Generic Programming},
  volume    = {4719},
  year      = {2007}
}

@software{gimp.2019,
  author  = {{The GIMP Development Team}},
  date    = {2019-06-12},
  title   = {GIMP},
  url     = {https://www.gimp.org},
  version = {2.10.12}
}

@software{gnu.2021.octave,
  author  = {{GNU Project}},
  date    = {2021-02-20},
  title   = {Octave},
  url     = {https://www.gnu.org/software/octave/index},
  version = {6.2.0}
}

@article{goguen.1984.parametrized,
  abstract = {Parameterized programming is a powerful technique for the reliable reuse of software. In this technique,
              modules are parameterized over very general interfaces that describe what properties of an environment are
              required for the module to work correctly. Reusability is enhanced by the flexibility of the
              parameterization mechanism proposed here. Reliability is further enhanced by permitting interface
              requirements to include more than purely syntactic information. This paper introduces three new ideas that
              seem especially useful in supporting parameterized programming: 1) theories, which declare global
              properties of program modules and interfaces; 2) views, which connect theories with program modules in an
              elegant way; and 3) module expressions, a kind of general structured program transformation which produces
              new modules by modifying and combining existing modules. Although these ideas are illustrated with some
              simple examples in the OBJ programming language, they should also be taken as proposals for an
              Ada<sup>1</sup> library system, for adding modules to Prolog, and as considerations for future language
              design efforts. OBJ is an ultra-high level programming language, based upon rewrite rules, that
              incorporates these ideas, and many others from modern programming methodology.},
  author   = {Goguen, Joseph A.},
  doi      = {10.1109/TSE.1984.5010277},
  issn     = {1939-3520},
  journal  = {IEEE Transactions on Software Engineering},
  keywords = {},
  month    = {09},
  number   = {5},
  pages    = {528-543},
  title    = {Parameterized Programming},
  volume   = {SE-10},
  year     = {1984}
}

@inproceedings{gossec.2019.pybind,
  author    = {Celian Gossec},
  booktitle = {Student LRDE tech reports},
  title     = {Binding a high-performance {C}++ image processing library to {P}ython},
  year      = {2019}
}

@software{graphicsmagick.2021,
  author  = {{GraphicsMagick Group}},
  date    = {2020-12-26},
  title   = {GraphicsMagick},
  url     = {https://http://www.graphicsmagick.org},
  version = {1.3.36}
}

@article{gregor.2006.concepts-art,
  abstract   = {Generic programming has emerged as an important technique for the development of highly reusable and
                efficient software libraries. In C++, generic programming is enabled by the flexibility of templates,
                the C++ type parametrization mechanism. However, the power of templates comes with a price: generic
                (template) libraries can be more difficult to use and develop than non-template libraries and their
                misuse results in notoriously confusing error messages. As currently defined in C++98, templates are
                unconstrained, and type-checking of templates is performed late in the compilation process, i.e., after
                the use of a template has been combined with its definition. To improve the support for generic
                programming in C++, we introduce concepts to express the syntactic and semantic behavior of types and to
                constrain the type parameters in a C++ template. Using concepts, type-checking of template definitions
                is separated from their uses, thereby making templates easier to use and easier to compile. These
                improvements are achieved without limiting the flexibility of templates or decreasing their performance
                — in fact their expressive power is increased. This paper describes the language extensions supporting
                concepts, their use in the expression of the C++ Standard Template Library, and their implementation in
                the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO C++
                standard, C++0x.},
  address    = {New York, NY, USA},
  author     = {Gregor, Douglas and J\"{a}rvi, Jaakko and Siek, Jeremy and Stroustrup, Bjarne and Dos Reis, Gabriel and
                Lumsdaine, Andrew},
  doi        = {10.1145/1167515.1167499},
  issn       = {0362-1340},
  issue_date = {October 2006},
  journal    = {SIGPLAN Not.},
  keywords   = {C++ templates, C++0x, constrained generics, parametric polymorphism, concepts, generic programming},
  month      = {10},
  number     = {10},
  numpages   = {20},
  pages      = {291-310},
  publisher  = {Association for Computing Machinery},
  title      = {Concepts: Linguistic Support for Generic Programming in C++},
  url        = {https://doi.org/10.1145/1167515.1167499},
  volume     = {41},
  year       = {2006}
}

@inproceedings{gregor.2006.concepts-proc,
  abstract  = {Generic programming has emerged as an important technique for the development of highly reusable and
               efficient software libraries. In C++, generic programming is enabled by the flexibility of templates,
               the C++ type parametrization mechanism. However, the power of templates comes with a price: generic
               (template) libraries can be more difficult to use and develop than non-template libraries and their
               misuse results in notoriously confusing error messages. As currently defined in C++98, templates are
               unconstrained, and type-checking of templates is performed late in the compilation process, i.e., after
               the use of a template has been combined with its definition. To improve the support for generic
               programming in C++, we introduce concepts to express the syntactic and semantic behavior of types and to
               constrain the type parameters in a C++ template. Using concepts, type-checking of template definitions
               is separated from their uses, thereby making templates easier to use and easier to compile. These
               improvements are achieved without limiting the flexibility of templates or decreasing their performance
               — in fact their expressive power is increased. This paper describes the language extensions supporting
               concepts, their use in the expression of the C++ Standard Template Library, and their implementation in
               the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO C++
               standard, C++0x.},
  address   = {New York, NY, USA},
  author    = {Gregor, Douglas and J\"{a}rvi, Jaakko and Siek, Jeremy and Stroustrup, Bjarne and Dos Reis, Gabriel and
               Lumsdaine, Andrew},
  booktitle = {Proceedings of the 21st Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages,
               and Applications},
  doi       = {10.1145/1167473.1167499},
  isbn      = {1595933484},
  keywords  = {concepts, parametric polymorphism, C++ templates, constrained generics, C++0x, generic programming},
  location  = {Portland, Oregon, USA},
  numpages  = {20},
  pages     = {291-310},
  publisher = {Association for Computing Machinery},
  series    = {OOPSLA '06},
  title     = {Concepts: Linguistic Support for Generic Programming in C++},
  url       = {https://doi.org/10.1145/1167473.1167499},
  year      = {2006}
}

@article{guelton.2015.pythran,
  author    = {Guelton, Serge and Brunet, Pierrick and Amini, Mehdi and Merlini, Adrien and Corbillon, Xavier and
               Raynaud, Alan},
  journal   = {Computational Science \& Discovery},
  number    = {1},
  pages     = {014001},
  publisher = {IOP Publishing},
  title     = {{P}ythran: Enabling static optimization of scientific python programs},
  volume    = {8},
  year      = {2015}
}

@misc{guennebaud.2010.eigen,
  author       = {Ga\"{e}l Guennebaud and Beno\^{i}t Jacob and others},
  howpublished = {http://eigen.tuxfamily.org},
  note         = {Available at \url{http://eigen.tuxfamily.org}},
  title        = {Eigen v3},
  year         = {2010}
}

@misc{guennebaud.2010.eigen-cuda,
  author       = {Ga\"{e}l Guennebaud and Beno\^{i}t Jacob and others},
  howpublished = {http://eigen.tuxfamily.org},
  note         = {Available at \url{https://eigen.tuxfamily.org/dox/TopicCUDA.html}},
  title        = {Using Eigen in CUDA kernels },
  year         = {2022}
}

@book{gulli.2017.deep,
  author    = {Gulli, Antonio and Pal, Sujit},
  publisher = {Packt Publishing Ltd},
  title     = {Deep learning with Keras},
  year      = {2017}
}

@phdthesis{halli.2016.java-hpc,
  author      = {Halli, Abderrahmane Nassim},
  hal_id      = {tel-01679740},
  hal_version = {v1},
  keywords    = {Jni ; Jit ; Hotspot JVM ; Performance ; Java ; Jit ; Jni ; JVM HotSpot ; Performance ; Java},
  month       = {10},
  note        = {Available at \url{https://tel.archives-ouvertes.fr/tel-01679740/file/HALLI_2016_archivage.pdf}},
  number      = {2016GREAM047},
  school      = {{Universit{\'e} Grenoble Alpes}},
  title       = {{Optimisation de code pour application Java haute-performance}},
  type        = {Theses},
  url         = {https://tel.archives-ouvertes.fr/tel-01679740},
  year        = {2016}
}


@inproceedings{hanus.1995.curry,
  abstract  = {Functional and logic programming are the most important declarative programming paradigms, and interest
               in combining them has grown over the last decade. However, integrated functional logic languages are
               currently not widely used. This is due to the fact that the operational principles are not well
               understood and many different evaluation strategies have been proposed which resulted in many different
               functional logic languages. To overcome this situation, we propose the functional logic language Curry
               which is intended to become a standard language in this area. It includes important ideas of existing
               functional logic languages and recent developments, and combines the most important features of
               functional and logic languages. Thus, Curry can be the basis to combine the currently separated research
               efforts of the functional and logic programming communities and to boost declarative programming in
               general. Moreover, since functions provide for more efficient evaluation strategies and are a
               declarative replacement of some impure features of Prolog (in particular, pruning operators), Curry can
               be also used as a declarative successor of Prolog.},
  author    = {Michael Hanus and Herbert Kuchen and Juan Jose Moreno-Navarro},
  booktitle = {Proc. ILPS'95 Workshop on Visions for the Future of Logic Programming},
  pages     = {95-107},
  title     = {Curry: A Truly Functional Logic Language},
  volume    = {95},
  year      = {1995}
}

@article{haralick.1977.imageaccessprotocol,
  abstract = {During the past decade a number of multiimage picture processing software packages have been put together.
              However, only a few of the references to picture processing systems discuss image data structure or
              input/output routines. This correspondence is a first step in a direction toward getting a communication
              process started by suggesting some specifications for a multiimage data format and standard input/output
              interface routines to access the image data.},
  author   = {R. M. {Haralick}},
  doi      = {10.1109/TSE.1977.231124},
  issn     = {2326-3881},
  journal  = {IEEE Transactions on Software Engineering},
  keywords = {Digital image processing; image processing; software; Access protocols; Image processing;
              Image segmentation; Data structures; Spatial resolution; Software packages; Communication standards;
              Laboratories; Image resolution; Electromagnetic launching; Digital image processing; image processing;
              software},
  month    = {03},
  number   = {2},
  pages    = {190-192},
  title    = {Image Access Protocol for Image Processing Software},
  volume   = {SE-3},
  year     = {1977}
}

@article{hoare.1969.axiomatic,
  abstract   = {In this paper an attempt is made to explore the logical foundations of computer programming by use of
                techniques which were first applied in the study of geometry and have later been extended to other
                branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which
                can be used in proofs of the properties of computer programs. Examples are given of such axioms and
                rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important
                advantage, both theoretical and practical, may follow from a pursuance of these topics.},
  address    = {New York, NY, USA},
  author     = {Hoare, C. A. R.},
  doi        = {10.1145/363235.363259},
  issn       = {0001-0782},
  issue_date = {Oct. 1969},
  journal    = {Commun. ACM},
  keywords   = {program documentation, formal language definition, programming language design,
                machine-independent programming, theory of programming' proofs of programs, axiomatic method},
  month      = {10},
  number     = {10},
  numpages   = {5},
  pages      = {576-580},
  publisher  = {Association for Computing Machinery},
  title      = {An Axiomatic Basis for Computer Programming},
  url        = {https://doi.org/10.1145/363235.363259},
  volume     = {12},
  year       = {1969}
}

@misc{howard.2017.mobilenets,
  archiveprefix = {arXiv},
  author        = {Andrew G. Howard and Menglong Zhu and Bo Chen and Dmitry Kalenichenko and Weijun Wang and
                   Tobias Weyand and Marco Andreetto and Hartwig Adam},
  eprint        = {1704.04861},
  primaryclass  = {cs.CV},
  title         = {MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications},
  year          = {2017}
}

@manual{ibanez.2003.ITKSoftwareGuide,
  author       = {Ibanez, L. and Schroeder, W. and Ng, L. and Cates, J.},
  edition      = {First},
  note         = {ISBN 1-930934-10-6},
  organization = {Kitware, Inc.},
  title        = {The {ITK} {S}oftware {G}uide},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf},
  year         = {2003}
}

@manual{ibanez.2005.ITKSoftwareGuideSecondEdition,
  author       = {Ibanez, L. and Schroeder, W. and Ng, L. and Cates, J.},
  edition      = {Second},
  note         = {ISBN 1-930934-15-7},
  organization = {Kitware, Inc.},
  title        = {The {ITK} {S}oftware {G}uide},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf},
  year         = {2005}
}

@article{iglberger.2012_1.blaze,
  author  = {Klaus {Iglberger} and Georg {Hager} and Jan {Treibig} and Ulrich {R{\"u}de}},
  journal = {SIAM Journal on Scientific Computing},
  pages   = {C42--C69},
  title   = {Expression Templates Revisited: A Performance Analysis of Current Methodologies},
  volume  = {34(2)},
  year    = {2012}
}

@inproceedings{iglberger.2012_2.blaze,
  author    = {Klaus {Iglberger} and Georg {Hager} and Jan {Treibig} and Ulrich {R{\"u}de}},
  booktitle = {Proceedings of the 2nd International Workshop on New Algorithms and Programming Models for the Manycore
               Era (APMM 2012) at HPCS 2012},
  title     = {High Performance Smart Expression Template Math Libraries},
  year      = {2012}
}

@misc{iglberger.2012.blaze,
  author       = {Klaus {Iglberger}},
  howpublished = {https://bitbucket.org/blaze-lib},
  title        = {Blaze C++ Linear Algebra Library},
  year         = {2012}
}

@software{imagemagick.2021,
  author  = {{The ImageMagick Development Team}},
  date    = {2021-01-04},
  title   = {ImageMagick},
  url     = {https://imagemagick.org},
  version = {7.0.10}
}

@software{intel-llvm.2021.sycl,
  author  = {Intel Corporation},
  title   = {SYCL Compiler and Runtimes},
  url     = {https://github.com/intel/llvm},
  version = {master}
}

@book{iso.1987.ada,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {06},
  pages     = {333},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  url       = {https://www.iso.org/standard/16028.html},
  year      = {1987}
}

@book{iso.1995.ada,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {02},
  pages     = {511},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  url       = {https://www.iso.org/standard/22983.html},
  year      = {1995}
}

@book{iso.1995.ada.amend,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {03},
  pages     = {317},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Amendment 1},
  url       = {https://www.iso.org/standard/45001.html},
  year      = {2007}
}

@book{iso.1995.ada.corr,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {06},
  pages     = {56},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Technical Corrigendum 1},
  url       = {https://www.iso.org/standard/35451.html},
  year      = {2001}
}

@book{iso.1998.cpp,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {09},
  pages     = {732},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC 14882:2003}: {Programming} languages --- {C++}},
  url       = {https://www.iso.org/standard/25845.html},
  year      = {1998}
}

@book{iso.2003.cpp,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {10},
  pages     = {757},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC 14882:2003}: {Programming} languages --- {C++}},
  url       = {https://www.iso.org/standard/38110.html},
  year      = {2003}
}

@book{iso.2011.cpp,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {09},
  pages     = {1338},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC 14882:2011}: {Programming} languages --- {C++}},
  url       = {https://www.iso.org/standard/50372.html},
  year      = {2011}
}

@book{iso.2012.ada,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {12},
  pages     = {832},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  url       = {https://www.iso.org/standard/61507.html},
  year      = {2012}
}

@book{iso.2012.ada.corr,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {02},
  pages     = {75},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Technical Corrigendum 1},
  url       = {https://www.iso.org/standard/69798.html},
  year      = {2016}
}

@book{iso.2014.cpp,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {12},
  pages     = {1358},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC 14882:2014}: {Programming} languages --- {C++}},
  url       = {https://www.iso.org/standard/64029.html},
  year      = {2014}
}

@book{iso.2017.cpp,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {12},
  pages     = {1605},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC 14882:2017}: {Programming} languages --- {C++}},
  url       = {https://www.iso.org/standard/68564.html},
  year      = {2017}
}

@book{iso.2020.cpp,
  address   = pub-ISO:adr,
  author    = {{ISO}},
  month     = {12},
  pages     = {1853},
  publisher = pub-ISO,
  title     = {{ISO\slash IEC 14882:2020}: {Programming} languages --- {C++}},
  url       = {https://www.iso.org/standard/79358.html},
  year      = {2020}
}

@inbook{iverson.2007.notation,
  address   = {New York, NY, USA},
  author    = {Iverson, Kenneth E.},
  booktitle = {ACM Turing Award Lectures},
  isbn      = {9781450310499},
  pages     = {1979},
  publisher = {Association for Computing Machinery},
  title     = {Notation as a Tool of Thought},
  url       = {https://doi.org/10.1145/1283920.1283935},
  year      = {2007}
}

@misc{jakob.2017.pybind11,
  author = {Jakob, Wenzel and Rhinelander, Jason and Moldovan, Dean},
  note   = {https://github.com/pybind/pybind11},
  title  = {pybind11—Seamless operability between C++ 11 and Python},
  year   = {2017}
}

@inproceedings{jarvi.2006.specialization,
  acmid     = {1134014},
  address   = {New York, NY, USA},
  author    = {J\"{a}rvi, Jaakko and Gregor, Douglas and Willcock, Jeremiah and Lumsdaine, Andrew and Siek, Jeremy},
  booktitle = {Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  doi       = {10.1145/1133981.1134014},
  isbn      = {1-59593-320-4},
  keywords  = {concepts, constrained generics, generic programming, parametric polymorphism, specialization},
  location  = {Ottawa, Ontario, Canada},
  numpages  = {11},
  pages     = {272--282},
  publisher = {ACM},
  series    = {PLDI '06},
  title     = {Algorithm Specialization in Generic Programming: Challenges of Constrained Generics in C++},
  url       = {http://doi.acm.org/10.1145/1133981.1134014},
  year      = {2006}
}

@article{jarvi.2006.specialization-article,
  acmid      = {1134014},
  address    = {New York, NY, USA},
  author     = {J\"{a}rvi, Jaakko and Gregor, Douglas and Willcock, Jeremiah and Lumsdaine, Andrew and Siek, Jeremy},
  doi        = {10.1145/1133255.1134014},
  issn       = {0362-1340},
  issue_date = {June 2006},
  journal    = {SIGPLAN Not.},
  keywords   = {concepts, constrained generics, generic programming, parametric polymorphism, specialization},
  month      = {06},
  number     = {6},
  numpages   = {11},
  pages      = {272--282},
  publisher  = {ACM},
  title      = {Algorithm Specialization in Generic Programming: Challenges of Constrained Generics in C++},
  url        = {http://doi.acm.org/10.1145/1133255.1134014},
  volume     = {41},
  year       = {2006}
}

@manual{johnson.2013.ITKSoftwareGuideThirdEdition,
  author       = {Johnson, Hans J. and McCormick, M. and Ib{\'a}{\~n}ez, L. and The Insight Software Consortium},
  edition      = {Third},
  note         = {\textit{In press}},
  organization = {Kitware, Inc.},
  title        = {The {ITK} {S}oftware {G}uide},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf},
  year         = {2013}
}

@manual{johnson.2015.itkvol1,
  author    = {Johnson, Hans J and McCormick, Matthew M and Ibanez, Luis},
  publisher = {Kitware, Inc.},
  title     = {Template:The ITK Software Guide Book 1: Introduction and Development Guidelines-Volume 1},
  year      = {2015}
}

@manual{johnson.2015.itkvol2,
  author    = {Johnson, Hans J and McCormick, Matthew M and Ibanez, Luis},
  publisher = {Kitware, Inc.},
  title     = {Template:The ITK Software Guide Book 2: Design and Functionality-Volume 2},
  year      = {2015}
}

@misc{jones.2006.scipy,
  author = {Eric Jones and Travis Oliphant and Pearu Peterson and others},
  title  = {{SciPy}: Open source scientific tools for {Python}},
  url    = {http://www.scipy.org/},
  year   = {2001}
}

@inproceedings{kapur.1982.tecton,
  address   = {Berlin, Heidelberg},
  author    = {Kapur, Deepak and Musser, David R. and Stepanov, Alexander A.},
  booktitle = {Program Specification},
  editor    = {Staunstrup, J{\o}rgen},
  isbn      = {978-3-540-39176-0},
  pages     = {402--414},
  publisher = {Springer Berlin Heidelberg},
  title     = {Tecton: A language for manipulating generic objects},
  year      = {1982}
}

@proceedings{kerautret.2018.rrprconf,
  editor    = {Bertrand Kerautret and Miguel Colom and Daniel Lopresti and Pascal Monasse and Hugues Talbot},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  title     = {Reproducible Research in Pattern Recognition — Second International Workshop, {RRPR} 2018, Beijing,
               China, August 20, 2018, Revised Selected Papers},
  volume    = {11455},
  year      = {2019}
}

@inproceedings{kluyver.2016.jupyter,
  abstract  = {It is increasingly necessary for researchers in all fields to write computer code, and in order to
               reproduce research results, it is important that this code is published. We present Jupyter notebooks, a
               document format for publishing code, results and explanations in a form that is both readable and
               executable. We discuss various tools and use cases for notebook documents.},
  address   = {Netherlands},
  author    = {Thomas Kluyver and Benjamin Ragan-Kelley and Fernando P{\'e}rez and Brian Granger and Matthias Bussonnier
               and Jonathan Frederic and Kyle Kelley and Jessica Hamrick and Jason Grout and Sylvain Corlay and Paul
               Ivanov and Dami{\'a}n Avila and Safia Abdalla and Carol Willing and  Jupyter development team},
  booktitle = {Positioning and Power in Academic Publishing: Players, Agents and Agendas},
  editor    = {Fernando Loizides and Birgit Scmidt},
  pages     = {87--90},
  publisher = {IOS Press},
  title     = {Jupyter Notebooks — a publishing format for reproducible computational workflows},
  url       = {https://eprints.soton.ac.uk/403913/},
  year      = {2016}
}

@book{knuth.2014.art,
  author    = {Knuth, Donald E},
  publisher = {Addison-Wesley Professional},
  title     = {Art of computer programming, volume 2: Seminumerical algorithms},
  year      = {2014}
}

@misc{kobalicek.2011.asmjit,
  author = {Kobalicek, P},
  title  = {asmjit-complete x86/x64 {JIT} assembler for {C}++ language},
  year   = {2011}
}

@misc{kolas.2000.gegl,
  author = {Kol{\r{a}}s, {\O}yvind and et al.},
  note   = {Available at \url{http://www.gegl.org}},
  title  = {{G}eneric {G}raphic {L}ibrary},
  year   = {2000}
}

@article{kothe.2011.generic,
  author  = {Ullrich K{\"o}the},
  journal = {C++ Report Magazine},
  note    = {{\small\url{https://ukoethe.github.io/vigra}}},
  number  = {1},
  pages   = {24--30},
  title   = {{STL}-Style Generic Programming with Images},
  volume  = {12},
  year    = {2000}
}

@misc{kothe.2011.generic.INTROUVABLE,
  author = {K{\"o}the, Ullrich},
  title  = {Generic programming for computer vision: The vigra computer vision library},
  year   = {2011}
}

@article{kotzmann.2008.hotspot,
  abstract   = {Version 6 of Sun Microsystems' Java HotSpot\textsuperscript{\texttrademark} VM ships with a redesigned
                version of the client just-in-time compiler that includes several research results of the last years.
                The client compiler is at the heart of the VM configuration used by default for interactive desktop
                applications. For such applications, low startup and pause times are more important than peak
                performance. This paper outlines the new architecture of the client compiler and shows how it interacts
                with the VM. It presents the intermediate representation that now uses static single-assignment (SSA)
                form and the linear scan algorithm for global register allocation. Efficient support for exception
                handling and deoptimization fulfills the demands that are imposed by the dynamic features of the Java
                programming language. The evaluation shows that the new client compiler generates better code in less
                time. The popular SPECjvm98 benchmark suite is executed 45\% faster, while the compilation speed is also
                up to 40\% better. This indicates that a carefully selected set of global optimizations can also be
                integrated in just-in-time compilers that focus on compilation speed and not on peak performance. In
                addition, the paper presents the impact of several optimizations on execution and compilation speed. As
                the source code is freely available, the Java HotSpot\textsuperscript{\texttrademark} VM and the client
                compiler are the ideal basis for experiments with new feedback-directed optimizations in a
                production-level Java just-in-time compiler. The paper outlines research projects that add fast
                algorithms for escape analysis, automatic object inlining, and array bounds check elimination.},
  address    = {New York, NY, USA},
  articleno  = {7},
  author     = {Kotzmann, Thomas and Wimmer, Christian and M\"{o}ssenb\"{o}ck, Hanspeter and Rodriguez,
                Thomas and Russell, Kenneth and Cox, David},
  doi        = {10.1145/1369396.1370017},
  issn       = {1544-3566},
  issue_date = {May 2008},
  journal    = {ACM Trans. Archit. Code Optim.},
  keywords   = {deoptimization, intermediate representation, register allocation, Java, compiler,
                just-in-time compilation, optimization},
  month      = {05},
  number     = {1},
  numpages   = {32},
  publisher  = {Association for Computing Machinery},
  title      = {Design of the Java HotSpot\textsuperscript{\texttrademark} Client Compiler for Java 6},
  url        = {https://doi.org/10.1145/1369396.1370017},
  volume     = {5},
  year       = {2008}
}

@article{kwame.2017.qualitative,
  author    = {Kwame, Ampomah Ernest and Martey, Ezekiel Mensah and Chris, Abilimi Gilbert},
  journal   = {Communications},
  number    = {7},
  pages     = {8--13},
  publisher = {Foundation of Computer Science (FCS), NY, USA},
  title     = {Qualitative assessment of compiled, interpreted and hybrid programming languages},
  volume    = {7},
  year      = {2017}
}

@software{lemire.2021.simdjson,
  author  = {Daniel Lemire and Geoff Langdale and John Keiser},
  date    = {2021-09-08},
  title   = {simdjson},
  url     = {https://github.com/simdjson/simdjson},
  version = {1.0}
}

@inproceedings{levillain.2009.ismm,
  abstract     = {We present a programming framework for discrete mathematical morphology centered on the concept of
                  genericity. We show that formal definitions of morphological algorithms can be translated into actual
                  code, usable on virtually any kind of compatible images, provided a general definition of the concept
                  of image is given. This work is implemented in Milena, a generic, efficient, and user-friendly image
                  processing library.},
  address      = {Groningen, The Netherlands},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  booktitle    = {Mathematical Morphology and Its Application to Signal and Image Processing — Proceedings of the Ninth
                  International Symposium on Mathematical Morphology (ISMM)},
  editor       = {Michael H. F. Wilkinson and Jos B. T. M. Roerdink},
  keywords     = {mathematical morphology, image processing operator, genericity, programming},
  lrdenewsdate = {2009-04-09},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.09.ismm.pdf},
  lrdeprojects = {Olena},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.09.ismm.slides.pdf},
  month        = {08},
  pages        = {295--306},
  publisher    = {Springer Berlin / Heidelberg},
  series       = {Lecture Notes in Computer Science},
  title        = {{Milena}: Write Generic Morphological Algorithms Once, Run on Many Kinds of Images},
  volume       = 5720,
  year         = 2009
}

@inproceedings{levillain.2010.icip,
  abstract     = {Most image processing frameworks are not generic enough to provide true reusability of data structures
                  and algorithms. In fact, genericity allows users to write and experiment virtually any method on any
                  compatible input(s). In this paper, we advocate the use of generic programming in the design of image
                  processing software, while preserving performances close to dedicated code. The implementation of our
                  proposal, Milena, a generic and efficient library, illustrates the benefits of our approach.},
  address      = {Hong Kong},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  booktitle    = {Proceedings of the IEEE International Conference on Image Processing (ICIP)},
  keywords     = {Genericity, Image Processing, Software Design, Reusability, Efficiency},
  lrdenewsdate = {2010-05-26},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.10.icip.pdf},
  lrdeposter   = {http://www.lrde.epita.fr/dload/papers/levillain.10.icip.poster.pdf},
  lrdeprojects = {Olena},
  month        = {09},
  pages        = {1941--1944},
  title        = {Why and How to Design a Generic and Efficient Image Processing Framework: The Case of the {Milena}
                  Library},
  year         = 2010
}

@inproceedings{levillain.2010.wadgmm,
  abstract     = {Digital Geometry software should reflect the generality of the underlying mathematics: mapping the
                  latter to the former requires genericity. By designing generic solutions, one can effectively reuse
                  digital geometry data structures and algorithms. We propose an image processing framework centered on
                  the Generic Programming paradigm in which an algorithm on the paper can be turn into a single code,
                  written once and usable with various input types. This approach enables users to design and implement
                  new methods at a lower cost, try cross-domain experiments and help generalize results.},
  address      = {Istanbul, Turkey},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  booktitle    = {Proceedings of the Workshop on Applications of Digital Geometry and Mathematical Morphology (WADGMM)},
  keywords     = {Generic Programming, Interface, Skeleton, Complex},
  lrdenewsdate = {2012-07-30},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.10.wadgmm.pdf},
  lrdeprojects = {Olena},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.10.wadgmm.slides.pdf},
  month        = {08},
  pages        = {96--100},
  title        = {Writing Reusable Digital Geometry Algorithms in a Generic Image Processing Framework},
  url          = {http://mdigest.jrc.ec.europa.eu/wadgmm2010/},
  year         = 2010
}

@inproceedings{levillain.2011.gretsi,
  abstract     = {De plus en plus d'outils logiciels modernes pour le traitement d'images sont con\c{c}us en prenant en
                  compte le probl\`eme de la g\'en\'ericit\'e du code, c'est-\`a-dire la possibilit\'e d'\'ecrire des
                  algorithmes r\'eutilisables, compatibles avec de nombreux types d'entr\'ees. Cependant, ce choix de
                  conception se fait souvent au d\'etriment des performances du code ex\'ecut\'e. Du fait de la grande
                  vari\'et\'e des types d'images existants et de la n\'ecessit\'e d'avoir des impl\'ementations rapides,
                  g\'en\'ericit\'e et performance apparaissent comme des qualit\'es essentielles du logiciel en
                  traitement d'images. Cet article pr\'esente une approche pr\'eservant les performances dans un
                  framework logiciel g\'en\'erique tirant parti des caract\'eristiques des types de donn\'ees
                  utilis\'es. Gr\^ace \`a celles-ci, il est possible d'\'ecrire des variantes d'algorithmes
                  g\'en\'eriques offrant un compromis entre g\'en\'ericit\'e et performance. Ces alternatives sont
                  capables de pr\'eserver une partie des aspects g\'en\'eriques d'origine tout en apportant des gains
                  substantiels \`a l'ex\'ecution. D'apr\`es nos essais, ces optimisations g\'en\'eriques fournissent des
                  performances supportant la comparaison avec du code d\'edi\'e, allant parfois m\^eme jusqu'\`a
                  surpasser des routines optimis\'ees manuellement.},
  address      = {Bordeaux, France},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  booktitle    = {Proceedings of the 23rd Symposium on Signal and Image Processing (GRETSI)},
  category     = {national},
  lrdenewsdate = {2011-05-13},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.11.gretsi.pdf},
  lrdeposter   = {http://www.lrde.epita.fr/dload/papers/levillain.11.gretsi.poster.pdf},
  lrdeprojects = {Olena},
  month        = {09},
  note         = {In French.},
  title        = {Une approche g\'en\'erique du logiciel pour le traitement d'images pr\'eservant les performances},
  year         = 2011
}

@phdthesis{levillain.2011.phd,
  abstract     = {In the context of software engineering for image processing (IP), we consider the notion of
                  reusability of algorithms. In many software tools, an algorithm's implementation often depends on the
                  type of processed data. In a broad definition, discrete digital images may have various forms —
                  classical 2D images, 3D volumes, non-regular graphs, cell complexes, and so on — thus leading to a
                  combinatorial explosion of the theoretical number of implementations. Generic programming (GP) is a
                  framework suited to the development of reusable software tools. We present a programming paradigm
                  based on GP designed for the creation of scientific software such as IP tools. This approach combines
                  the benefits of reusability, expressive power, extensibility, and efficiency. We then propose a
                  software architecture for IP using this programming paradigm based on a generic IP library. The
                  foundations of this framework define essential IP concepts, enabling the development of algorithms
                  compatible with many image types. We finally present a strategy to build high-level tools on top of
                  this library, such as bridges to dynamic languages or graphical user interfaces. This mechanism has
                  been designed to preserve the genericity and efficiency of the underlying software tools, while making
                  them simpler to use and more flexible.},
  address      = {Marne-la-Vall\'ee, France},
  author       = {Roland Levillain},
  lrdepaper    = {http://www.lrde.epita.fr/~roland/phd/levillain-phd.pdf},
  lrdeprojects = {Olena},
  month        = {11},
  school       = {Universit\'e Paris-Est},
  title        = {Towards a Software Architecture for Generic Image Processing},
  year         = 2011
}

@inproceedings{levillain.2012.wadgmm-lncs,
  abstract     = {Digital Topology software should reflect the generality of the underlying mathematics: mapping the
                  latter to the former requires genericity. By designing generic solutions, one can effectively reuse
                  digital topology data structures and algorithms. We propose an image processing framework focused on
                  the Generic Programming paradigm in which an algorithm on the paper can be turned into a single code,
                  written once and usable with various input types. This approach enables users to design and implement
                  new methods at a lower cost, try cross-domain experiments and help generalize results.},
  annote       = {This paper is an extended version of levillain.10.wadgmm (201008-WADGMM).},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  booktitle    = {WADGMM 2010},
  editor       = {Ullrich K\"othe and Annick Montanvert and Pierre Soille},
  keywords     = {Generic Programming, Interface, Skeleton, Complex},
  lrdenewsdate = {2012-08-08},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.12.wadgmm-lncs.pdf},
  lrdeprojects = {Olena},
  oldkeys      = {levillain.12.lncs},
  pages        = {140--153},
  publisher    = {Springer-Verlag Berlin Heidelberg},
  series       = {Lecture Notes in Computer Science},
  title        = {Writing Reusable Digital Topology Algorithms in a Generic Image Processing Framework},
  volume       = 7346,
  year         = 2012
}

@inproceedings{levillain.2014.ciarp,
  abstract     = {An important topic for the image processing and pattern recognition community is the construction of
                  open source and efficient libraries. An increasing number of software frameworks are said to be
                  generic: they allow users to write reusable algorithms compatible with many input image types.
                  However, this design choice is often made at the expense of performance. We present an approach to
                  preserve efficiency in a generic image processing framework, by leveraging data types features.
                  Variants of generic algorithms taking advantage of image types properties can be defined, offering an
                  adjustable trade-off between genericity and efficiency. Our experiments show that these generic
                  optimizations can match dedicated code in terms of execution times, and even sometimes perform better
                  than routines optimized by hand. Digital Topology software should reflect the generality of the
                  underlying mathematics: mapping the latter to the former requires genericity. By designing generic
                  solutions, one can effectively reuse digital topology data structures and algorithms. We propose an
                  image processing framework focused on the Generic Programming paradigm in which an algorithm on the
                  paper can be turned into a single code, written once and usable with various input types. This
                  approach enables users to design and implement new methods at a lower cost, try cross-domain
                  experiments and help generalize results.},
  address      = {Puerto Vallarta, Mexico},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman and Edwin Carlinet},
  booktitle    = {Progress in Pattern Recognition, Image Analysis, Computer Vision, and Applications — Proceedings of
                  the 19th Iberoamerican Congress on Pattern Recognition (CIARP)},
  editor       = {Eduardo Bayro and Edwin Hancock},
  keywords     = {Generic Programming, Image Processing, Performance, Olena},
  lrdenewsdate = {2014-09-10},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.14.ciarp.pdf},
  lrdeprojects = {Olena},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.14.ciarp.slides.pdf},
  month        = {11},
  pages        = {70--79},
  publisher    = {Springer-Verlag},
  series       = {Lecture Notes in Computer Science},
  title        = {Practical Genericity: Writing Image Processing Algorithms Both Reusable and Efficient},
  volume       = {8827},
  year         = {2014}
}

@inproceedings{levin.2004.colorization,
  abstract  = {Colorization is a computer-assisted process of adding color to a monochrome image or movie. The process
               typically involves segmenting images into regions and tracking these regions across image sequences.
               Neither of these tasks can be performed reliably in practice; consequently, colorization requires
               considerable user intervention and remains a tedious, time-consuming, and expensive task. In this paper
               we present a simple colorization method that requires neither precise image segmentation, nor accurate
               region tracking. Our method is based on a simple premise; neighboring pixels in space-time that have
               similar intensities should have similar colors. We formalize this premise using a quadratic cost function
               and obtain an optimization problem that can be solved efficiently using standard techniques. In our
               approach an artist only needs to annotate the image with a few color scribbles, and the indicated colors
               are automatically propagated in both space and time to produce a fully colorized image or sequence. We
               demonstrate that high quality colorizations of stills and movie clips may be obtained from a relatively
               modest amount of user input.},
  address   = {New York, NY, USA},
  author    = {Levin, Anat and Lischinski, Dani and Weiss, Yair},
  booktitle = {ACM SIGGRAPH 2004 Papers},
  doi       = {10.1145/1186562.1015780},
  isbn      = {9781450378239},
  keywords  = {segmentation, colorization, recoloring},
  location  = {Los Angeles, California},
  numpages  = {6},
  pages     = {689--694},
  publisher = {Association for Computing Machinery},
  series    = {SIGGRAPH '04},
  title     = {Colorization Using Optimization},
  url       = {https://doi.org/10.1145/1186562.1015780},
  year      = {2004}
}

@article{liskov.1993.cluart,
  abstract   = {The idea of a data abstraction has had a significant impact on the development of programming languages
                and on programming methodology. CLU was the first implemented programming language to provide direct
                linguistic support for data abstraction. This paper provides a history of data abstraction and CLU. CLU
                contains a number of other interesting and influential features, including its exception handling
                mechanism, its iterators, and its parameterized types.},
  address    = {New York, NY, USA},
  author     = {Liskov, Barbara},
  doi        = {10.1145/155360.155367},
  issn       = {0362-1340},
  issue_date = {March 1993},
  journal    = {SIGPLAN Not.},
  month      = {03},
  number     = {3},
  numpages   = {15},
  pages      = {133-147},
  publisher  = {Association for Computing Machinery},
  title      = {A History of CLU},
  url        = {https://doi.org/10.1145/155360.155367},
  volume     = {28},
  year       = {1993}
}

@inproceedings{liskov.1993.cluproc,
  abstract  = {The idea of a data abstraction has had a significant impact on the development of programming languages
               and on programming methodology. CLU was the first implemented programming language to provide direct
               linguistic support for data abstraction. This paper provides a history of data abstraction and CLU. CLU
               contains a number of other interesting and influential features, including its exception handling
               mechanism, its iterators, and its parameterized types.},
  address   = {New York, NY, USA},
  author    = {Liskov, Barbara},
  booktitle = {The Second ACM SIGPLAN Conference on History of Programming Languages},
  doi       = {10.1145/154766.155367},
  isbn      = {0897915704},
  location  = {Cambridge, Massachusetts, USA},
  numpages  = {15},
  pages     = {133-147},
  publisher = {Association for Computing Machinery},
  series    = {HOPL-II},
  title     = {A History of CLU},
  url       = {https://doi.org/10.1145/154766.155367},
  year      = {1993}
}

@article{liu.2019.sunwayimg,
  abstract = {Many big data applications need to process massive images and videos, while the performance of image
              processing is far from reaching requirements. This paper proposes the SunwayImg, a parallel image
              processing library, to support image-related applications on the Sunway many-core processor as well as the
              Sunway TaihuLight supercomputer. The SunwayImg integrates three kinds of image algorithms: fundamental
              algorithms to support basic image operations on the Sunway processor, widely used image feature extraction
              algorithms and a typical neural network model DBN. In addition, to parallelize various kinds of image
              algorithms efficiently on the Sunway processor, we propose a three-tier parallelization strategy as well
              as fine-grained parallelization inside core-groups. Finally, we accomplish implementation of the SunwayImg
              and evaluate it on the Sunway TaihuLight supercomputer to verify its effectiveness and performance.},
  author   = {R. {Liu} and Y. {Liu} and M. {Zhao} and K. {Song} and D. {Qian}},
  doi      = {10.1109/ACCESS.2019.2939940},
  issn     = {2169-3536},
  journal  = {IEEE Access},
  keywords = {Big Data; feature extraction; image processing; multiprocessing systems; neural nets; parallel machines;
              image feature extraction algorithms; three-tier parallelization strategy; fine-grained parallelization;
              SunwayImg; Sunway TaihuLight supercomputer; parallel image processing library; Sunway many-core processor;
              big data applications; image-related applications; image operations; neural network model; Libraries;
              Computer architecture; Feature extraction; Supercomputers; Software; Neural networks; Image library;
              high performance computing; parallel computing; deep neural networks},
  month    = {},
  number   = {},
  pages    = {128555-128569},
  title    = {SunwayImg: A Parallel Image Processing Library for the Sunway Many-Core Processor},
  volume   = {7},
  year     = {2019}
}

@software{mathworks.2020.matlab,
  author  = {{MathWorks}},
  date    = {2020-09-22},
  title   = {MATLAB},
  url     = {https://fr.mathworks.com/products/matlab.html},
  version = {R2020b}
}

@inproceedings{matuska.2012.bench,
  abstract  = {In order to fill gap of growing demand for high efficient image and video processing, open source
               computer vision library (OpenCv) is way to deals with this task. Hence, this paper is about basic
               algorithm for image processing and their CPU time consumption in Matlab comparing with OpenCv.
               Algorithms are tested on images with resolution 3264x2448, 1920x1080, 1024x768 and 220x260.
               Multi-processors computer and multi-threading programs are used to improve processing efficiency.},
  author    = {S. {Matuska} and R. {Hudec} and M. {Benco}},
  booktitle = {2012 ELEKTRO},
  doi       = {10.1109/ELEKTRO.2012.6225575},
  issn      = {null},
  keywords  = {image processing; mathematics computing; microprocessor chips; multi-threading; CPU time consumption;
               image processing algorithm; Matlab; OpenCV; video processing; open source computer vision library;
               multi-processors computer; multi-threading programs; Application software; Instruction sets; Kernel;
               Image edge detection; Smoothing methods; Computer vision; OpenCV; Matlab; computer vision;
               mutli-threading},
  month     = {05},
  number    = {},
  pages     = {75-78},
  title     = {The comparison of CPU time consumption for image processing
               algorithm in Matlab and OpenCV},
  volume    = {},
  year      = {2012}
}

@article{meyer.1992.design,
  abstract = {Methodological guidelines for object-oriented software construction that improve the reliability of the
              resulting software systems are presented. It is shown that the object-oriented techniques rely on the
              theory of design by contract, which underlies the design of the Eiffel analysis, design, and programming
              language and of the supporting libraries, from which a number of examples are drawn. The theory of
              contract design and the role of assertions in that theory are discussed.},
  author   = {Meyer, B.},
  doi      = {10.1109/2.161279},
  issn     = {1558-0814},
  journal  = {Computer},
  keywords = {},
  month    = {10},
  number   = {10},
  pages    = {40-51},
  title    = {Applying 'design by contract'},
  volume   = {25},
  year     = {1992}
}

@inproceedings{meyer.2009.ismm,
  author    = {Fernand Meyer and Jean Stawiaski},
  booktitle = {Proc. of the Intl. Symp. on Mathematical Morphology (ISMM)},
  pages     = {161--170},
  publisher = {Springer},
  series    = {LNCS},
  title     = {Morphology on graphs and minimum spanning trees},
  volume    = {5720},
  year      = {2009}
}
@article{moisan.2005.modeling,
  author  = {Moisan, Lionel},
  journal = {Lecture Notes of ENS Cachan edition},
  title   = {Modeling and image processing},
  year    = {2005}
}

@book{moore.2017.matlab,
  author    = {Moore, Holly},
  publisher = {Pearson},
  title     = {MATLAB for Engineers},
  year      = {2017}
}

@inproceedings{musser.1987.ada,
  abstract  = {It is well-known that data abstractions are crucial to good software engineering practice. We argue that
               algorithmic abstractions, or generic algorithms, are perhaps even more important for software
               reusability. Generic algorithms are parameterized procedural schemata that are completely independent of
               the underlying data representation and are derived from concrete, efficient algorithms. We discuss this
               notion with illustrations from the structure of an Ada library of reusable software components we are
               presently developing.},
  address   = {New York, NY, USA},
  author    = {Musser, David R. and Stepanov, Alexander A.},
  booktitle = {Proceedings of the 1987 Annual ACM SIGAda International Conference on Ada},
  doi       = {10.1145/317500.317529},
  isbn      = {0897912438},
  location  = {Boston, Massachusetts, USA},
  numpages  = {10},
  pages     = {216-225},
  publisher = {Association for Computing Machinery},
  series    = {SIGAda '87},
  title     = {A Library of Generic Algorithms in Ada},
  url       = {https://doi.org/10.1145/317500.317529},
  year      = {1987}
}

% First appearence of the expression "generic programming"
@inproceedings{musser.1988.generic,
  author       = {David R. Musser and Alexander A. Stepanov},
  booktitle    = {Intl. Symp. on Symbolic and Algebraic Computation},
  organization = {Springer},
  pages        = {13--25},
  title        = {Generic programming},
  year         = {1988}
}

@book{musser.1989.ada,
  author    = {Musser, David R and Stepanov, Alexander A},
  publisher = {Springer-Verlag},
  title     = {The Ada Generic Library linear list processing packages},
  year      = {1989}
}

@article{musser.1994.algorithm,
  abstract = {We outline an approach to construction of software libraries in which generic algorithms (algorithmic
              abstractions) play a more central role than in conventional software library technology or in the
              object-oriented programming paradigm. Our approach is to consider algorithms first, decide what types and
              access operations they need for efficient execution, and regard the types and operations as formal
              parameters that can be instantiated in many different ways, as long as the actual parameters satisfy the
              assumptions on which the correctness and efficiency of the algorithms are based. The means by which
              instantiation is carried out is language dependent; in the C++ examples in this paper, we instantiate
              generic algorithms by constructing classes that define the needed types and access operations. By use of
              such compile-time techniques and careful attention to algorithmic issues, it is possible to construct
              software components of broad utility with no sacrifice of efficiency.},
  author   = {Musser, David R. and Stepanov, Alexander A.},
  doi      = {10.1002/spe.4380240703},
  eprint   = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380240703},
  journal  = {Software: Practice and Experience},
  keywords = {Generic algorithms, Algorithmic abstractions, Software libraries, Abstract data types, C+ +, Templates},
  number   = {7},
  pages    = {623-642},
  title    = {Algorithm-oriented generic libraries},
  url      = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380240703},
  volume   = {24},
  year     = {1994}
}

@book{musser.2012.ada,
  author    = {Musser, David R and Stepanov, Alexander A},
  publisher = {Springer Science \& Business Media},
  title     = {The Ada{\textregistered} generic library: linear list processing packages},
  year      = {2012}
}

@article{mytkowicz.2009.sigplan-art,
  abstract   = {This paper presents a surprising result: changing a seemingly innocuous aspect of an experimental setup
                can cause a system researcher to draw wrong conclusions from an experiment. What appears to be an
                innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation.
                This phenomenon is called measurement bias in the natural and social sciences.Our results demonstrate
                that measurement bias is significant and commonplace in computer system evaluation. By significant we
                mean that measurement bias can lead to a performance analysis that either over-states an effect or even
                yields an incorrect conclusion. By common place we mean that measurement bias occurs in all
                architectures that we tried (Pentium 4, Core 2, and m5 O3CPU), both compilers that we tried (gcc and
                Intel's C compiler), and most of the SPEC CPU2006 C programs. Thus, we cannot ignore measurement bias.
                Nevertheless, in a literature survey of 133 recent papers from ASPLOS, PACT, PLDI, and CGO, we
                determined that none of the papers with experimental results adequately consider measurement bias.
                Inspired by similar problems and their solutions in other sciences, we describe and demonstrate two
                methods, one for detecting (causal analysis) and one for avoiding (setup randomization) measurement
                bias.},
  address    = {New York, NY, USA},
  author     = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
  doi        = {10.1145/1508284.1508275},
  issn       = {0362-1340},
  issue_date = {March 2009},
  journal    = {SIGPLAN Not.},
  keywords   = {bias, performance, measurement},
  month      = {03},
  number     = {3},
  numpages   = {12},
  pages      = {265-276},
  publisher  = {Association for Computing Machinery},
  title      = {Producing Wrong Data without Doing Anything Obviously Wrong!},
  url        = {https://doi.org/10.1145/1508284.1508275},
  volume     = {44},
  year       = {2009}
}

@inproceedings{mytkowicz.2009.sigplan-proc,
  abstract  = {This paper presents a surprising result: changing a seemingly innocuous aspect of an experimental setup
               can cause a system researcher to draw wrong conclusions from an experiment. What appears to be an
               innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation.
               This phenomenon is called measurement bias in the natural and social sciences.Our results demonstrate
               that measurement bias is significant and commonplace in computer system evaluation. By significant we
               mean that measurement bias can lead to a performance analysis that either over-states an effect or even
               yields an incorrect conclusion. By common place we mean that measurement bias occurs in all
               architectures that we tried (Pentium 4, Core 2, and m5 O3CPU), both compilers that we tried (gcc and
               Intel's C compiler), and most of the SPEC CPU2006 C programs. Thus, we cannot ignore measurement bias.
               Nevertheless, in a literature survey of 133 recent papers from ASPLOS, PACT, PLDI, and CGO, we
               determined that none of the papers with experimental results adequately consider measurement bias.
               Inspired by similar problems and their solutions in other sciences, we describe and demonstrate two
               methods, one for detecting (causal analysis) and one for avoiding (setup randomization) measurement
               bias.},
  address   = {New York, NY, USA},
  author    = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
  booktitle = {Proceedings of the 14th International Conference on Architectural Support for Programming Languages and
               Operating Systems},
  doi       = {10.1145/1508244.1508275},
  isbn      = {9781605584065},
  journal   = {SIGPLAN Not.},
  keywords  = {measurement, bias, performance},
  location  = {Washington, DC, USA},
  numpages  = {12},
  pages     = {265-276},
  publisher = {Association for Computing Machinery},
  series    = {ASPLOS XIV},
  title     = {Producing Wrong Data without Doing Anything Obviously Wrong!},
  url       = {https://doi.org/10.1145/1508244.1508275},
  year      = {2009}
}

@book{najman.2013.mathematical,
  author    = {Najman, L. and Talbot, H.},
  isbn      = {9781118600856},
  publisher = {Wiley},
  series    = {ISTE},
  title     = {Mathematical Morphology: From Theory to Applications},
  url       = {https://books.google.fr/books?id=9FUlX8YrRvMC},
  year      = {2013}
}

@inproceedings{nanz.2015.comparative,
  author    = {Nanz, Sebastian and Furia, Carlo A.},
  booktitle = {2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  doi       = {10.1109/ICSE.2015.90},
  issn      = {1558-1225},
  keywords  = {},
  month     = {05},
  number    = {},
  pages     = {778-788},
  title     = {A Comparative Study of Programming Languages in Rosetta Code},
  volume    = {1},
  year      = {2015}
}

@misc{niebler.2014.ranges,
  author = {Eric Niebler, Sean Parent, Andrew Sutton},
  key    = {D4128},
  month  = {10},
  title  = {Ranges for the Standard Library: Revision 1},
  url    = {https://ericniebler.github.io/std/wg21/D4128.html},
  year   = {2014}
}

@misc{niebler.2018.deepranges,
  author       = {Eric Niebler and Casey Carter},
  key          = {p1037r0},
  month        = {05},
  organization = {WG21},
  pages        = {61--61},
  title        = {Deep Integration of the Ranges {TS}},
  url          = {https://wg21.link/p1037r0},
  year         = {2018}
}

@misc{niebler.2018.mergingranges,
  author       = {Eric Niebler and Casey Carter},
  key          = {p0896r1},
  month        = {05},
  organization = {WG21},
  pages        = {96--96},
  title        = {Merging the Ranges {TS}},
  url          = {https://wg21.link/p0896r1},
  year         = {2018}
}

@misc{niebler.2018.ranges,
  author       = {Eric Niebler and Casey Carter},
  month        = {05},
  note         = {{\small\url{https://wg21.link/p1037r0}}},
  optpublisher = {WG21},
  title        = {{P1037R0}: {D}eep Integration of the Ranges {TS}},
  year         = 2018
}

@software{nlohmann.2021.json,
  author  = {Niels Lohmann},
  date    = {2021-08-26},
  title   = {Json},
  url     = {https://github.com/nlohmann/json},
  version = {3.10.2}
}

@article{novak.1997.reuse,
  abstract = {A generic procedure can be specialized, by compilation through views, to operate directly on concrete
              data. A view is a computational mapping that describes how a concrete type implements an abstract type.
              Clusters of related views are needed for specialization of generic procedures that involve several types
              or several views of a single type. A user interface that reasons about relationships between concrete
              types and abstract types allows view clusters to be created easily. These techniques allow rapid
              specialization of generic procedures for applications.},
  author   = {G. S. {Novak}},
  doi      = {10.1109/32.605759},
  issn     = {2326-3881},
  journal  = {IEEE Transactions on Software Engineering},
  keywords = {software reusability; abstract data types; partial evaluation (compilers); program compilers;
              user interfaces; software reuse; generic procedure specialization; views; computational mapping;
              concrete type; abstract data type; user interface; view clusters; partial evaluation;
              direct manipulation editor; Concrete; Software algorithms; Clustering algorithms; Programming profession;
              Object oriented programming; User interfaces; Application software; Costs; Production; Libraries},
  month    = {07},
  number   = {7},
  pages    = {401-417},
  title    = {Software reuse by specialization of generic procedures through views},
  volume   = {23},
  year     = {1997}
}

@misc{nvidia.2022.nvblas,
  author       = {Nvidia},
  howpublished = {Nvidia},
  note         = {Available at \url{https://docs.nvidia.com/cuda/nvblas/}},
  title        = {NVBLAS - drop-in BLAS replacement, multi-GPUs accelerated},
  year         = {2022}
}

@inproceedings{oezkan.2017.IPlibrary,
  abstract  = {Field Programmable Gate Arrays (FPGAs) are proved to be among the most suitable architectures for image
               processing applications. However, accelerating algorithms using FPGAs is a time-consuming task and needs
               expertise. Whereas the recent advancements in High-Level Synthesis (HLS) promise to solve this problem,
               today's HLS tools require apt hardware descriptions of algorithms to be able to provide favorable
               implementations. A solution is developing highly parameterizable and optimized HLS libraries for the
               fundamental image processing components. Another solution is providing a higher level of abstraction in
               the form of a Domain-Specific Language (DSL) and a corresponding efficient back end for hardware design.
               In this paper, we provide a highly efficient and parameterizable C++ library for image processing
               applications, which would be the cornerstone for both approaches. In our library, nodes of a stream-based
               data flow graph can be described as C++ objects for specified functions, and the whole application can be
               efficiently parallelized just by defining a global constant as the parallelization factor. Moreover, the
               key hardware design elements, i.e., line buffers and sliding windows with different border handling
               patterns, can be utilized individually to ease the design of more complicated applications.},
  author    = {M. A. {Oezkan} and O. {Reiche} and F. {Hannig} and J. {Teich}},
  booktitle = {FSP 2017; Fourth International Workshop on FPGAs for Software Programmers},
  doi       = {},
  issn      = {null},
  keywords  = {},
  month     = {09},
  number    = {},
  pages     = {1-10},
  title     = {A Highly Efficient and Comprehensive Image Processing Library for C++-based High-Level Synthesis},
  volume    = {},
  year      = {2017}
}

@misc{olena.2000.www,
  author       = {EPITA Research and Developpement Laboratory (LRDE)},
  howpublished = {\url{http://olena.lrde.epita.fr}},
  key          = {Olena},
  oldkeys      = {olena.net},
  title        = {The {Olena} image processing platform},
  year         = {2000}
}

@misc{oliphant.2006.numpy,
  author       = {Travis Oliphant},
  howpublished = {USA: Trelgol Publishing},
  title        = {{NumPy}: A guide to {NumPy}},
  url          = {http://www.numpy.org/},
  year         = {2006}
}

@misc{opencv.bg_sub,
  month = {12},
  note  = {{\small\url{https://docs.opencv.org/3.4/d1/dc5/tutorial_background_subtraction.html}}},
  title = {Background Subtraction},
  year  = 2018
}

@misc{openvx.2019,
  author       = {{Khronos Group}},
  howpublished = {\url{https://www.khronos.org/openvx/}},
  optannote    = {},
  optmonth     = {},
  optnote      = {},
  title        = {{OpenVX}},
  year         = {2019}
}

@incollection{oram.2007.beautiful,
  author    = {Travis E. Oliphant},
  booktitle = {Beautiful code},
  chapter   = 19,
  editor    = {Andrew Oram and Greg Wilson},
  publisher = {O'reilly Sebastopol, CA},
  title     = {Multidimensional Iterators in {N}um{P}y},
  year      = 2007
}

@misc{parent.2018.generic-programming,
  author    = {Sean Parent},
  note      = {Talk available on youtube at \url{https://youtu.be/FtZEU9zv9eM}},
  publisher = {{code::dive} 2019},
  title     = {2018 : Generic Programming},
  url       = {https://codedive.pl/2018/generic-programming},
  year      = {2018}
}

@book{part.1996.matlab,
  author    = {P{\"a}rt-Enander, Eva and Sj{\"o}berg, Anders and Melin, Bo and Isaksson, Pernilla},
  publisher = {Addison-Wesley Harlow},
  title     = {The MATLAB handbook},
  year      = {1996}
}

@incollection{paszke.2019.pytorch,
  author    = {Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and
               Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and
               Desmaison, Alban and Kopf, Andreas and Yang, Edward and DeVito, Zachary and Raison, Martin and
               Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and
               Chintala, Soumith},
  booktitle = {Advances in Neural Information Processing Systems 32},
  editor    = {H. Wallach and H. Larochelle and A. Beygelzimer and F. d\textquotesingle Alch{\'e}-Buc and E. Fox and
               R. Garnett},
  pages     = {8024--8035},
  publisher = {Curran Associates, Inc.},
  title     = {PyTorch: An Imperative Style, High-Performance Deep Learning Library},
  url       = {http://papers.neurips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library.pdf},
  year      = {2019}
}

@misc{penuchot.2019.blaze-cuda,
  author       = {Jules {Penuchot}},
  howpublished = {Github},
  note         = {Available at \url{https://github.com/STEllAR-GROUP/blaze_cuda}},
  title        = {CUDA extension for Blaze.},
  year         = {2019}
}

@article{perret.2019.higra,
  abstract = {Higra — Hierarchical Graph Analysis is a C++/Python library for efficient sparse graph analysis with a
              special focus on hierarchical methods capable of handling large amount of data. The main aspects of
              hierarchical graph analysis addressed in Higra are the construction of hierarchical representations
              (agglomerative clustering, mathematical morphology hierarchies, etc.), the analysis and processing of such
              representations (filtering, clustering, characterization, etc.), and their assessment. Higra targets a
              large audience, from students and practitioners wanting an accessible library for quickly experimenting,
              to researchers developing new methods for hierarchical analysis of graph data. Higra is a generic toolbox
              for graph analysis and can be utilized in a large variety of application fields like machine learning,
              data science, pattern analysis and computer vision. Moreover, it contains an image analysis module easing
              the handling of pixel grid graphs by providing efficient algorithms dedicated to this field.},
  author   = {B. Perret and G. Chierchia and J. Cousty and S.J. F. Guimarães and Y. Kenmochi and L. Najman},
  doi      = {https://doi.org/10.1016/j.softx.2019.100335},
  issn     = {2352-7110},
  journal  = {SoftwareX},
  keywords = {Graph, Hierarchical clustering, Component tree},
  pages    = {100335},
  title    = {Higra: Hierarchical Graph Analysis},
  url      = {http://www.sciencedirect.com/science/article/pii/S235271101930247X},
  volume   = {10},
  year     = {2019}
}

@article{peterson.2009.f2py,
  author    = {Peterson, Pearu},
  journal   = {International Journal of Computational Science and Engineering},
  number    = {4},
  pages     = {296--305},
  publisher = {Inderscience Publishers},
  title     = {F2PY: a tool for connecting Fortran and Python programs},
  volume    = {4},
  year      = {2009}
}

@article{piper.1985.data,
  author    = {Jim Piper and Denis Rutovitz},
  journal   = {Pattern Recognition Letters},
  number    = {2},
  pages     = {119--129},
  publisher = {Elsevier},
  title     = {Data structures for image processing in a {C} language and {U}nix environment},
  volume    = {3},
  year      = {1985}
}

@article{pirkelbauer.2010.multimethods,
  abstract = {Multiple dispatch-the selection of a function to be invoked based on the dynamic type of two or more
              arguments-is a solution to several classical problems in object-oriented programming. Open multi-methods
              generalize multiple dispatch towards open-class extensions, which improve separation of concerns and
              provisions for retroactive design. We present the rationale, design, implementation, performance,
              programming guidelines, and experiences of working with a language feature, called open multi-methods, for
              C++. Our open multi-methods support both repeated and virtual inheritance. Our call resolution rules
              generalize both virtual function dispatch and overload resolution semantics. After using all information
              from argument types, these rules can resolve further ambiguities by using covariant return types. Care was
              taken to integrate open multi-methods with existing C++ language features and rules. We describe a model
              implementation and compare its performance and space requirements to existing open multi-method extensions
              and work-around techniques for C++. Compared to these techniques, our approach is simpler to use, catches
              more user mistakes, and resolves more ambiguities through link-time analysis, is comparable in memory
              usage, and runs significantly faster. In particular, the runtime cost of calling an open multi-method is
              constant and less than the cost of a double dispatch (two virtual function calls). Finally, we provide a
              sketch of a design for open multi-methods in the presence of dynamic loading and linking of libraries.},
  author   = {Peter Pirkelbauer and Yuriy Solodkyy and Bjarne Stroustrup},
  doi      = {https://doi.org/10.1016/j.scico.2009.06.002},
  issn     = {0167-6423},
  journal  = {Science of Computer Programming},
  keywords = {Multi-methods, Open-methods, Multiple dispatch, Binary method problem, Augmenting method problem,
              Object-oriented programming, Generic programming, C},
  note     = {Generative Programming and Component Engineering (GPCE 2007)},
  number   = {7},
  pages    = {638 - 667},
  title    = {Design and evaluation of {C}++ open multi-methods},
  url      = {http://www.sciencedirect.com/science/article/pii/S016764230900094X},
  volume   = {75},
  year     = {2010}
}

@book{plauger.2000.c++-stl,
  author    = {Plauger, Phillip James and Lee, Meng and Musser, David and Stepanov, Alexander A},
  publisher = {Prentice Hall PTR},
  title     = {C++ standard template library},
  year      = {2000}
}

@article{prechelt.2000.comparison,
  abstract = {Often heated, debates regarding different programming languages' effectiveness remain inconclusive because
              of scarce data and a lack of direct comparisons. The author addresses that challenge, comparatively
              analyzing 80 implementations of the phone-code program in seven different languages (C, C++, Java, Perl,
              Python, Rexx and Tcl). Further, for each language, the author analyzes several separate implementations by
              different programmers. The comparison investigates several aspects of each language, including program
              length, programming effort, runtime efficiency, memory consumption, and reliability. The author uses
              comparisons to present insight into program language performance.},
  author   = {Prechelt, L.},
  doi      = {10.1109/2.876288},
  issn     = {1558-0814},
  journal  = {Computer},
  keywords = {},
  month    = {10},
  number   = {10},
  pages    = {23-29},
  title    = {An empirical comparison of seven programming languages},
  volume   = {33},
  year     = {2000}
}

@software{ptc.2019.mathcad,
  author  = {{PTC}},
  date    = {2019-10-01},
  title   = {GraphicsMagick},
  url     = {https://www.mathcad.com},
  version = {6.0}
}

@software{pypi.2021,
  author  = {{The PyPi Developement Team}},
  date    = {2021-01-31},
  title   = {{P}y{P}i},
  url     = {https://pypi.org},
  version = {21.0.1}
}

@software{quantstack.2021.xeus-cling,
  author  = {QuantStack},
  date    = {2021-03-16},
  title   = {xeus-cling},
  url     = {https://github.com/QuantStack/xeus-cling},
  version = {0.12.1}
}

@article{ragankelley.2013.halide,
  author  = {Jonathan Ragan-kelley and Connelly Barnes and Andrew Adams and Fr{\'e}do Durand and Saman Amarasinghe and
             et al.},
  journal = {PLDI 2013},
  title   = {{H}alide: A Language and Compiler for Optimizing Parallelism, Locality, and Recomputation in Image
             Processing Pipelines},
  year    = {2013}
}

@book{redfern.2012.matlab,
  author    = {Redfern, Darren and Campbell, Colin},
  publisher = {Springer Science \& Business Media},
  title     = {The MATLAB{\textregistered} 5 Handbook},
  year      = {2012}
}

@article{ritter.1990.cvgi,
  author    = {Gerhard X. Ritter and Joseph N. Wilson and Jennifer L. Davidson},
  journal   = {Computer Vision, Graphics, and Image Processing},
  number    = 3,
  pages     = {297--331},
  publisher = {Elsevier},
  title     = {Image algebra: An overview},
  volume    = 49,
  year      = 1990
}

@article{roman.1998.digital,
  abstract = {This paper presents a class library dedicated to digital image processing which provides resources for
              essential digital image processing operations. Besides its practical value, the class library is used to
              teach both object-oriented software engineering methodology and digital image processing. The resulting
              module can be accessed from independent specialized applications through its public interface while its
              implementation details are perfectly encapsulated. First of all it is used as the inner part of an
              integrated environment designed for students and researchers in the field of digital image processing.This
              software component was built aiming for both portability and extendibility. It contains attributes and
              methods that allow for a wide range of digital image processing algorithms: point and geometric
              operations; filter, edge detection, segmentation and texture operations; and fast Fourier transforms,
              discrete cosine transforms, and wavelet and Gabor transformations. All these can be used for image
              enhancement, restoration, compression, analysis, and synthesis.},
  author   = {D. {Roman} and M. {Fisher} and J. {Cubillo}},
  doi      = {10.1109/13.728270},
  issn     = {1557-9638},
  journal  = {IEEE Transactions on Education},
  keywords = {image processing; software engineering; engineering education; object-oriented programming;
              object-oriented approach; digital image processing; object-oriented software engineering; encapsulation;
              integrated environment; digital image processing algorithms; geometric operations; point operations;
              filter; edge detection; segmentation; texture operations; fast Fourier transforms;
              discrete cosine transforms; wavelet; Gabor transformations; image enhancement; image restoration;
              image compression; image analysis; image synthesis; Digital images; Software libraries;
              Software engineering; Application software; Digital filters; Gabor filters; Image edge detection;
              Image segmentation; Fast Fourier transforms; Discrete cosine transforms},
  month    = {11},
  number   = {4},
  pages    = {331-333},
  title    = {Digital image processing-an object-oriented approach},
  volume   = {41},
  year     = {1998}
}

@inproceedings{roynard.2019.rrpr,
  abstract  = {As there are as many clients as many usages of an Image Processing library, each one may expect
               different services from it. Some clients may look for efficient and production-quality algorithms, some
               may look for a large tool set, while others may look for extensibility and genericity to inter-operate
               with their own code base...but in most cases, they want a simple-to-use and stable product. For a C++
               Image Processing library designer, it is difficult to conciliate genericity, efficiency and simplicity at
               the same time. Modern C++ (post 2011) brings new features for library developers that will help designing
               a software solution combining those three points. In this paper, we develop a method using these
               facilities to abstract the library components and augment the genericity of the algorithms. Furthermore,
               this method is not specific to image processing; it can be applied to any C++ scientific library.},
  address   = {Cham},
  author    = {Roynard, Micha{\"e}l and Carlinet, Edwin and G{\'e}raud, Thierry},
  booktitle = {Reproducible Research in Pattern Recognition},
  editor    = {Kerautret, Bertrand and Colom, Miguel and Lopresti, Daniel and Monasse, Pascal and Talbot, Hugues},
  isbn      = {978-3-030-23987-9},
  pages     = {121--137},
  publisher = {Springer International Publishing},
  title     = {An Image Processing Library in Modern C++: Getting Simplicity and Efficiency with Generic Programming},
  year      = {2019}
}

@misc{sanderson.2016.armadillo,
  author       = {Sanderson, Conrad and Curtin, Ryan},
  howpublished = {Sourceforge},
  note         = {Available at \url{https://gitlab.com/conradsnicta/armadillo-code}},
  title        = {Armadillo, {C}++ library for linear algebra \& scientific computing},
  year         = {2016}
}

@article{sanderson.2016.armadillo-art,
  author    = {Sanderson, Conrad and Curtin, Ryan},
  journal   = {Journal of Open Source Software},
  number    = {2},
  pages     = {26},
  publisher = {Journal of Open Source Software},
  title     = {Armadillo: a template-based C++ library for linear algebra},
  volume    = {1},
  year      = {2016}
}

@inproceedings{sanderson.2018.armadillo-proc,
  abstract  = {When implementing functionality which requires sparse matrices, there are numerous storage formats to
               choose from, each with advantages and disadvantages. To achieve good performance, several formats may
               need to be used in one program, requiring explicit selection and conversion between the formats. This can
               be both tedious and error-prone, especially for non-expert users. Motivated by this issue, we present a
               user-friendly sparse matrix class for the C++ language, with a high-level application programming
               interface deliberately similar to the widely used MATLAB language. The class internally uses two main
               approaches to achieve efficient execution: (i) a hybrid storage framework, which automatically and
               seamlessly switches between three underlying storage formats (compressed sparse column, coordinate list,
               Red-Black tree) depending on which format is best suited for specific operations, and (ii) template-based
               meta-programming to automatically detect and optimise execution of common expression patterns. To
               facilitate relatively quick conversion of research code into production environments, the class and its
               associated functions provide a suite of essential sparse linear algebra functionality (eg., arithmetic
               operations, submatrix manipulation) as well as high-level functions for sparse eigendecompositions and
               linear equation solvers. The latter are achieved by providing easy-to-use abstractions of the low-level
               ARPACK and SuperLU libraries. The source code is open and provided under the permissive Apache 2.0
               license, allowing unencumbered use in commercial products.},
  address   = {Cham},
  author    = {Sanderson, Conrad
               and Curtin, Ryan},
  booktitle = {Mathematical Software -- ICMS 2018},
  editor    = {Davenport, James H.
               and Kauers, Manuel
               and Labahn, George
               and Urban, Josef},
  isbn      = {978-3-319-96418-8},
  pages     = {422--430},
  publisher = {Springer International Publishing},
  title     = {A User-Friendly Hybrid Sparse Matrix Class in {C}++},
  year      = {2018}
} 

@article{sanderson.2019.practical,
  author    = {Sanderson, Conrad and Curtin, Ryan},
  journal   = {Mathematical and Computational Applications},
  number    = {3},
  pages     = {70},
  publisher = {Multidisciplinary Digital Publishing Institute},
  title     = {Practical Sparse Matrices in C++ with Hybrid Storage and Template-Based Expression Optimisation},
  volume    = {24},
  year      = {2019}
}

@software{scilab.2020,
  author  = {{Scilab Enterprises}},
  date    = {2020-02-25},
  title   = {Scilab},
  url     = {https://www.scilab.org},
  version = {6.1.0}
}

@misc{seymour.2009.concepts,
  author       = {Bill Seymour},
  key          = {N2929},
  month        = {07},
  organization = {WG21},
  title        = {{LWG} Papers to Re-Merge into {C}++0x After Removing Concepts},
  url          = {https://wg21.link/n2929},
  year         = {2009}
}

@inproceedings{siek.2001.boostgraph,
  author    = {Jeremy Siek, Lie-Quan Lee, Andrew Lumsdaine},
  publisher = {Addison-Wesley},
  title     = {The {B}oost {G}raph library},
  url       = {http://cds.cern.ch/record/1518180/files/0201729148_TOC.pdf},
  year      = {2001}
}

@book{stepanov.1987.higher,
  author    = {Stepanov, Alexander A and Kershenbaum, Aaron and Musser, David R},
  publisher = {March},
  title     = {Higher order programming},
  year      = {1987}
}

@book{stepanov.1995.standard,
  author    = {Stepanov, Alexander and Lee, Meng},
  publisher = {Hewlett Packard Laboratories 1501 Page Mill Road, Palo Alto, CA 94304},
  title     = {The standard template library},
  volume    = {1501},
  year      = {1995}
}

@misc{stepanov.2003.gcm,
  author    = {Alexander Stepanov},
  note      = {Slides available at \url{http://stepanovpapers.com/gcd.pdf}.
               Talk available on youtube at \url{https://youtu.be/fanm5y00joc}},
  publisher = {1999 Arthur Schoffstall Lecture in Computer Science and Computer Engineering at the Rensselaer
               Polytechnic Institute},
  title     = {Greatest Common Measure: The Last 2500 Years},
  url       = {http://stepanovpapers.com/gcd.pdf},
  year      = {2003}
}

@book{stepanov.2004.notes,
  author    = {Stepanov, Alexander A and Marcus, Matthew A},
  publisher = {Citeseer},
  title     = {Notes on the Foundations of Programming},
  year      = {2004}
}

@book{stepanov.2009.elements,
  author    = {Alexander Stepanov and Paul McJones},
  month     = {06},
  optnote   = {Decomposing programs into a system of algorithmic components},
  publisher = {Addison-Wesley Professional},
  title     = {Elements of Programming},
  year      = {2009}
}

% Reclaiming of the expression "generic programming"
@book{stepanov.2014.mathematics,
  author    = {Stepanov, Alexander A and Rose, Daniel E},
  publisher = {Pearson Education},
  title     = {From mathematics to generic programming},
  year      = {2014}
}

@book{stroustrup.1995.design,
  address   = {New York, NY, USA},
  author    = {Stroustrup, Bjarne},
  isbn      = {0-201-54330-3},
  publisher = {ACM Press/Addison-Wesley Publishing Co.},
  title     = {The Design and Evolution of {C}++},
  year      = {1994}
}

@inbook{stroustrup.1996.history,
  abstract  = {This paper outlines the history of the C++ programming language. The emphasis is on the ideas,
               constraints, and people that shaped the language, rather than the minutiae of language features. Key
               design decisions relating to language features are discussed, but the focus is one of the overall design
               goals and practical constraints. The evolution of C++ is traced from C with Classes to the current ANSI
               and ISO standards work and the explosion of use, interest, commercial activity, compilers, tools,
               environments, and libraries.},
  address   = {New York, NY, USA},
  author    = {Stroustrup, Bjarne},
  booktitle = {History of Programming Languages---II},
  isbn      = {0201895021},
  numpages  = {71},
  pages     = {699-769},
  publisher = {Association for Computing Machinery},
  title     = {A History of C++: 1979--1991},
  url       = {https://doi.org/10.1145/234286.1057836},
  year      = {1996}
}

@article{stroustrup.1999.hot,
  author    = {Bjarne Stroustrup},
  journal   = {Handbook of Object Technology},
  publisher = {CRC Press},
  title     = {An overview of the {C++} programming language},
  year      = {1999}
}

% first appearence of "concept" and "regular type"
@misc{stroustrup.2003.concepts,
  author       = {Bjarne Stroustrup and Gabriel Dos Reis},
  key          = {N1522},
  month        = {10},
  organization = {WG21},
  title        = {Concepts — {D}esign choices for template argument checking},
  url          = {https://wg21.link/n1522},
  year         = {2003}
}

@article{stroustrup.2005.design,
  author  = {Stroustrup, Bjarne},
  journal = {C/C++ Users Journal},
  number  = {5},
  pages   = {7},
  title   = {The design of C++ 0x},
  volume  = {23},
  year    = {2005}
}

@inproceedings{stroustrup.2007.evolving,
  abstract  = {This paper outlines the history of the C++ programming language from the early days of its ISO
               standardization (1991), through the 1998 ISO standard, to the later stages of the C++0x revision of that
               standard (2006). The emphasis is on the ideals, constraints, programming techniques, and people that
               shaped the language, rather than the minutiae of language features. Among the major themes are the
               emergence of generic programming and the STL (the C++ standard library's algorithms and containers).
               Specific topics include separate compilation of templates, exception handling, and support for embedded
               systems programming. During most of the period covered here, C++ was a mature language with millions of
               users. Consequently, this paper discusses various uses of C++ and the technical and commercial pressures
               that provided the background for its continuing evolution.},
  address   = {New York, NY, USA},
  author    = {Stroustrup, Bjarne},
  booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  doi       = {10.1145/1238844.1238848},
  isbn      = {9781595937667},
  keywords  = {programming language, standardization, libraries, language use, STL, multi-paradigm programming,
               evolution, ISO, C++, history},
  location  = {San Diego, California},
  pages     = {4-1-4-59},
  publisher = {Association for Computing Machinery},
  series    = {HOPL III},
  title     = {Evolving a Language in and for the Real World: C++ 1991-2006},
  url       = {https://doi.org/10.1145/1238844.1238848},
  year      = {2007}
}

@inproceedings{stroustrup.2007.hopl,
  address      = {New York, USA},
  author       = {Bjarne Stroustrup},
  booktitle    = {Proc. of the 3rd ACM SIGPLAN Conf. on History of Programming Languages},
  doi          = {10.1145/1238844.1238848},
  isbn         = {9781595937667},
  location     = {San Diego, California},
  optbooktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  optpublisher = {Association for Computing Machinery},
  optseries    = {HOPL III},
  pages        = {1--59},
  title        = {Evolving a Language in and for the Real World: {C++} 1991-2006},
  url          = {https://doi.org/10.1145/1238844.1238848},
  volume       = {4},
  year         = {2007}
}

@article{stroustrup.2012.concept,
  author  = {Stroustrup, Bjarne and Sutton, Andrew and Voufo, L and Zalewski, M},
  journal = {C++ Standards Committee Papers, Technical Report N},
  pages   = {12--0041},
  title   = {A Concept Design for the STL},
  volume  = {3351},
  year    = {2012}
}

@article{stroustrup.2020.acm,
  abstract   = {By 2006, C++ had been in widespread industrial use for 20 years. It contained parts that had survived
                unchanged since introduced into C in the early 1970s as well as features that were novel in the early
                2000s. From 2006 to 2020, the C++ developer community grew from about 3 million to about 4.5 million. It
                was a period where new programming models emerged, hardware architectures evolved, new application
                domains gained massive importance, and quite a few well-financed and professionally marketed languages
                fought for dominance. How did C++ -- an older language without serious commercial backing -- manage to
                thrive in the face of all that? This paper focuses on the major changes to the ISO C++ standard for the
                2011, 2014, 2017, and 2020 revisions. The standard library is about 3/4 of the C++20 standard, but this
                paper's primary focus is on language features and the programming techniques they support. The paper
                contains long lists of features documenting the growth of C++. Significant technical points are
                discussed and illustrated with short code fragments. In addition, it presents some failed proposals and
                the discussions that led to their failure. It offers a perspective on the bewildering flow of facts and
                features across the years. The emphasis is on the ideas, people, and processes that shaped the language.
                Themes include efforts to preserve the essence of C++ through evolutionary changes, to simplify its use,
                to improve support for generic programming, to better support compile-time programming, to extend
                support for concurrency and parallel programming, and to maintain stable support for decades' old code.
                The ISO C++ standard evolves through a consensus process. Inevitably, there is competition among
                proposals and clashes (usually polite ones) over direction, design philosophies, and principles. The
                committee is now larger and more active than ever, with as many as 250 people turning up to week-long
                meetings three times a year and many more taking part electronically. We try (not always successfully)
                to mitigate the effects of design by committee, bureaucratic paralysis, and excessive enthusiasm for a
                variety of language fashions.  Specific language-technical topics include the memory model, concurrency
                and parallelism, compile-time computation, move-semantics, exceptions, lambda expressions, and modules.
                Designing a mechanism for specifying a template's requirements on its arguments that is sufficiently
                flexible and precise yet doesn't impose run-time costs turned out to be hard. The repeated attempts to
                design ``concepts'' to do that have their roots back in the 1980s and touch upon many key design issues
                for C++ and for generic programming.  The description is based on personal participation in the key
                events and design decisions, backed by the thousands of papers and hundreds of meeting minutes in the
                ISO C++ standards committee's archives.},
  address    = {New York, NY, USA},
  articleno  = {70},
  author     = {Stroustrup, Bjarne},
  doi        = {10.1145/3386320},
  issue_date = {June 2020},
  journal    = {Proc. ACM Program. Lang.},
  keywords   = {C++, concurrency and parallelism, generic programming, programming language design and evolution,
                resource management, simplification of language use, standardization},
  month      = {06},
  number     = {HOPL},
  numpages   = {168},
  publisher  = {Association for Computing Machinery},
  title      = {Thriving in a Crowded and Changing World: C++ 2006-2020},
  url        = {https://doi.org/10.1145/3386320},
  volume     = {4},
  year       = {2020}
}

@inproceedings{sutton.2012.concepts,
  abstract  = {We present a set of concepts (requirements on template arguments) for a large subset of the ISO C++
               standard library. The goal of our work is twofold: to identify a minimal and useful set of concepts
               required to constrain the library's generic algorithms and data structures and to gain insights into how
               best to support such concepts within C++. We start with the design of concepts rather than the design of
               supporting language features; the language design must be made to fit the concepts, rather than the other
               way around. A direct result of the experiment is the realization that to simply and elegantly support
               generic programming we need two kinds of abstractions: constraints are predicates on static properties of
               a type, and concepts are abstract specifications of an algorithm's syntactic and semantic requirements.
               Constraints are necessary building blocks of concepts. Semantic properties are represented as axioms. We
               summarize our approach: concepts{\thinspace}={\thinspace}constraints{\thinspace}+{\thinspace}axioms. This
               insight is leveraged to develop a library containing only 14 concepts that encompassing the functional,
               iterator, and algorithm components of the C++ Standard Library (the STL). The concepts are implemented as
               constraint classes and evaluated using Clang's and GCC's Standard Library test suites.},
  address   = {Berlin, Heidelberg},
  author    = {Sutton, Andrew and Stroustrup, Bjarne},
  booktitle = {Software Language Engineering},
  editor    = {Sloane, Anthony and A{\ss}mann, Uwe},
  isbn      = {978-3-642-28830-2},
  pages     = {97--118},
  publisher = {Springer Berlin Heidelberg},
  title     = {Design of Concept Libraries for C++},
  year      = {2012}
}

@misc{sutton.2017.concepts,
  author       = {Andrew Sutton},
  key          = {N4674},
  month        = {06},
  organization = {WG21},
  title        = {Working Draft, {C}++ extensions for Concepts},
  url          = {https://wg21.link/n4674},
  year         = {2017}
}

@book{taylor.2004.intel,
  author    = {Taylor, Stewart},
  publisher = {Intel Press},
  title     = {Intel integrated performance primitives},
  year      = {2004}
}

@misc{tensorflow.2015.whitepaper,
  author = {Mart{\'i}n~Abadi and Ashish~Agarwal and Paul~Barham and Eugene~Brevdo and Zhifeng~Chen and Craig~Citro and
            Greg~S.~Corrado and Andy~Davis and Jeffrey~Dean and Matthieu~Devin and Sanjay~Ghemawat and
            Ian~Goodfellow and Andrew~Harp and Geoffrey~Irving and Michael~Isard and Yangqing Jia and
            Rafal~Jozefowicz and Lukasz~Kaiser and Manjunath~Kudlur and Josh~Levenberg and Dandelion~Man{\'e} and
            Rajat~Monga and Sherry~Moore and Derek~Murray and Chris~Olah and Mike~Schuster and Jonathon~Shlens and
            Benoit~Steiner and Ilya~Sutskever and Kunal~Talwar and Paul~Tucker and Vincent~Vanhoucke and
            Vijay~Vasudevan and Fernanda~Vi{\'e}gas and Oriol~Vinyals and Pete~Warden and Martin~Wattenberg and
            Martin~Wicke and Yuan~Yu and Xiaoqiang~Zheng},
  note   = {Software available from tensorflow.org},
  title  = {{TensorFlow}: Large-Scale Machine Learning on Heterogeneous Systems},
  url    = {https://www.tensorflow.org/},
  year   = {2015}
}

@inproceedings{tschumperle.2012.cimg,
  address     = {Cachan, France},
  author      = {Tschumperl{\'e}, David},
  booktitle   = {{IPOL 2012 Meeting on Image Processing Libraries}},
  hal_id      = {hal-00927458},
  hal_version = {v1},
  keywords    = {Image Processing; C++ Library; Template-based programming; Genericity; Straightforwardness;
                 Script language},
  month       = {06},
  pages       = {4 pp},
  pdf         = {https://hal.archives-ouvertes.fr/hal-00927458/file/tschumperle_ipol2012.pdf},
  title       = {{The CImg Library}},
  url         = {https://hal.archives-ouvertes.fr/hal-00927458},
  year        = {2012}
}

@article{vanderwalt.2014.skimage,
  author   = {van der Walt, {S}t\'efan and {S}ch\"onberger, {J}ohannes {L}. and {Nunez-Iglesias}, {J}uan and
              {B}oulogne, {F}ran\c{c}ois and {W}arner, {J}oshua {D}. and {Y}ager, {N}eil and
              {G}ouillart, {E}mmanuelle and {Y}u, {T}ony and the scikit-image contributors},
  doi      = {10.7717/peerj.453},
  issn     = {2167-8359},
  journal  = {PeerJ},
  keywords = {Image processing, Reproducible research, Education, Visualization, Open source, Python,
              Scientific programming},
  month    = {6},
  pages    = {e453},
  title    = {scikit-image: image processing in {P}ython},
  url      = {https://doi.org/10.7717/peerj.453},
  volume   = {2},
  year     = {2014}
}

@book{vandevoorde.2002.c++,
  author    = {Vandevoorde, David and Josuttis, Nicolai M},
  publisher = {Addison-Wesley Professional},
  title     = {C++ Templates: The Complete Guide, Portable Documents},
  year      = {2002}
}

@article{vanherk.1992.localminmax,
  abstract = {A new algorithm is presented for local maximum and minimum filters requiring only 6 comparisons per pixel
              independent of kernel size. The algorithm is based on separability and a combination of block recursive
              series which are evaluated forwards and backwards.},
  author   = {Marcel van Herk},
  doi      = {https://doi.org/10.1016/0167-8655(92)90069-C},
  issn     = {0167-8655},
  journal  = {Pattern Recognition Letters},
  keywords = {Mathematical morphology, recursive filters, local maximum and minimum, separability},
  number   = {7},
  pages    = {517 - 521},
  title    = {A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels},
  url      = {http://www.sciencedirect.com/science/article/pii/016786559290069C},
  volume   = {13},
  year     = {1992}
}

@inproceedings{vassilev.2012.cling,
  author    = {Vassilev,V. and Canal,Ph. and Naumann,A. and Moneta,L. and Russo,P.},
  doi       = {10.1088/1742-6596/396/5/052071},
  journal   = {Journal of Physics: Conference Series},
  month     = {12},
  number    = {5},
  pages     = {052071},
  publisher = {{IOP} Publishing},
  title     = {{Cling} — The New Interactive Interpreter for {ROOT} 6},
  url       = {https://iopscience.iop.org/article/10.1088/1742-6596/396/5/052071/pdf},
  volume    = {396},
  year      = 2012
}

@article{veldhuizen.1995.expression,
  author  = {Veldhuizen, Todd},
  journal = {C++ Report},
  number  = {5},
  pages   = {26--31},
  title   = {Expression templates},
  volume  = {7},
  year    = {1995}
}

@inproceedings{veldhuizen.1998.arrays,
  abstract  = {The Blitz++ library provides numeric arrays for C++ with efficiency that rivals Fortran, without any
               language extensions. Blitz++ has features unavailable in Fortran 90/95, such as arbitrary transpose
               operations, array renaming, tensor notation, partial reductions, multi-component arrays and stencil
               operators. The library handles parsing and analysis of array expressions on its own using the expression
               templates technique, and performs optimizations (such as loop transformations) which have until now been
               the responsibility of compilers.},
  address   = {Berlin, Heidelberg},
  author    = {Veldhuizen, Todd L.},
  booktitle = {Computing in Object-Oriented Parallel Environments},
  editor    = {Caromel, Denis and Oldehoeft, Rodney R. and Tholburn, Marydell},
  isbn      = {978-3-540-49372-3},
  pages     = {223--230},
  publisher = {Springer Berlin Heidelberg},
  title     = {Arrays in Blitz++},
  year      = {1998}
}

@inproceedings{veldhuizen.2000.blitz,
  abstract  = {Blitz++ provides dense numeric arrays for C++ with performance on par with Fortran. It does so by using
               ''template techniques'' (expression templates and template metaprograms). In addition to fast
               performance, Blitz++ arrays provide many nice notations and features not available in Fortran 90.},
  address   = {Berlin, Heidelberg},
  author    = {Veldhuizen, Todd L.},
  booktitle = {Advances in Software Tools for Scientific Computing},
  editor    = {Langtangen, Hans Petter and Bruaset, Are Magnus and Quak, Ewald},
  isbn      = {978-3-642-57172-5},
  pages     = {57--87},
  publisher = {Springer Berlin Heidelberg},
  title     = {Blitz++: The Library that Thinks it is a Compiler},
  year      = {2000}
}

@article{veldhuizen.2000.techniques,
  author    = {Veldhuizen, Todd},
  journal   = {Computer science technical report},
  pages     = {60},
  publisher = {Citeseer},
  title     = {Techniques for scientific C++},
  volume    = {542},
  year      = {2000}
}

@techreport{veldhuizen.2003.c++templates,
  author      = {Todd L. Veldhuizen},
  institution = {},
  title       = {C++ Templates are Turing Complete},
  year        = {2003}
}

@misc{voutilainen.2017.concepts,
  author       = {Ville Voutilainen},
  key          = {P0724r0},
  month        = {06},
  organization = {WG21},
  title        = {Merge the Concepts {TS} Working Draft into the {C}++20 working draft},
  url          = {https://wg21.link/p0724r0},
  year         = {2017}
}

@article{wagner.2005.generic,
  author  = {Wagner, S and Affenzeller, M},
  journal = {Adaptive and Natural Computing Algorithms, Springer Computer Science},
  pages   = {538--541},
  title   = {A Generic and Extensible Optimization Environment},
  year    = {2005}
}

@inproceedings{welsh.2002.transferring,
  abstract  = {We introduce a general technique for "colorizing" grayscale images by transferring color between a
               source, color image and a destination, grayscale image. Although the general problem of adding chromatic
               values to a grayscale image has no exact, objective solution, the current approach attempts to provide a
               method to help minimize the amount of human labor required for this task. Rather than choosing RGB colors
               from a palette to color individual components, we transfer the entire color "mood" of the source to the
               target image by matching luminance and texture information between the images. We choose to transfer only
               chromatic information and retain the original luminance values of the target image. Further, the
               procedure is enhanced by allowing the user to match areas of the two images with rectangular swatches. We
               show that this simple technique can be successfully applied to a variety of images and video, provided
               that texture and luminance are sufficiently distinct. The images generated demonstrate the potential and
               utility of our technique in a diverse set of application domains.},
  address   = {New York, NY, USA},
  author    = {Welsh, Tomihisa and Ashikhmin, Michael and Mueller, Klaus},
  booktitle = {Proceedings of the 29th Annual Conference on Computer Graphics and Interactive Techniques},
  doi       = {10.1145/566570.566576},
  isbn      = {1581135211},
  keywords  = {color, image processing, video, texture synthesis},
  location  = {San Antonio, Texas},
  numpages  = {4},
  pages     = {277--280},
  publisher = {Association for Computing Machinery},
  series    = {SIGGRAPH '02},
  title     = {Transferring Color to Grayscale Images},
  url       = {https://doi.org/10.1145/566570.566576},
  year      = {2002}
}

@inproceedings{wimtlplavrijsen.2016.cppyy,
  author    = {W. T. L. P. Lavrijsen and A. Dutta},
  booktitle = {2016 6th Workshop on {P}ython for High-Performance and Scientific Computing ({P}y{HPC})},
  doi       = {10.1109/PyHPC.2016.008},
  issn      = {},
  keywords  = {C++ language; software libraries; private Boolean query processing; encrypted data; data outsourcing;
               privacy risks; data encryption; data confidentiality; support complex queries; security requirements;
               privacy-preserving query processing framework; Bloom filter; additive homomorphic encryption;
               query evaluation; PyPy; Cling; high level productivity language; high performance libraries;
               Python-C++ bindings generators; thread safety; C++ parser; dynamic optimizations; CPython; C++ functions;
               C++ libraries; C++ languages; Generators; Standards; Libraries; Optimization; Semantics; Productivity},
  month     = {11},
  number    = {},
  pages     = {27-35},
  title     = {High-Performance {P}ython-{C}++ Bindings with {P}y{P}y and {C}ling},
  volume    = {},
  year      = {2016}
}

@software{wolfram.2020.mathematica,
  author  = {{wolfram Research}},
  date    = {2020-12-16},
  title   = {Mathematica},
  url     = {https://www.wolfram.com/mathematica/},
  version = {12.2}
}

@inproceedings{wong.2019.heterogeneous,
  acmid     = {3204939},
  address   = {New York, NY, USA},
  articleno = {20},
  author    = {Wong, Michael and Finkel, Hal},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  doi       = {10.1145/3204919.3204939},
  isbn      = {978-1-4503-6439-3},
  keywords  = {BoF, C++, HPC, SC17, concurrency, distributed programming models, heterogeneous programming, parallelism},
  location  = {Oxford, United Kingdom},
  numpages  = {7},
  pages     = {20:1--20:7},
  publisher = {ACM},
  series    = {IWOCL '18},
  title     = {Distributed \& Heterogeneous Programming in C++ for HPC at SC17},
  url       = {http://doi.acm.org/10.1145/3204919.3204939},
  year      = {2018}
}

@article{xie.improving,
  author = {Xie, Danke and Wang, ChernHsi Jeffrey and Schimpf, Michael},
  title  = {Improving Java Virtual Machine performance with SIMD technology}
}

@software{xilinx.2021.triSYCL,
  author  = {Xilinx and others},
  title   = {The triSYCL project},
  url     = {https://github.com/trisycl/trisycl},
  version = {master}
}

@article{xu.2015.pami,
  author       = {Yongchao Xu and Thierry G{\'e}raud and Laurent Najman},
  journal      = {IEEE Transactions on Pattern Analysis and Machine Intelligence},
  number       = {6},
  optpublisher = {IEEE},
  pages        = {1126--1140},
  title        = {Connected filtering on tree-based shape-spaces},
  volume       = {38},
  year         = {2015}
}

@article{yoo.2002.engineering,
  author    = {Yoo, Terry S and Ackerman, Michael J and Lorensen, William E and Schroeder, Will and Chalana, Vikram and
               Aylward, Stephen and Metaxas, Dimitris and Whitaker, Ross},
  journal   = {Studies in health technology and informatics},
  pages     = {586--592},
  publisher = {IOS Press; 1999},
  title     = {Engineering and algorithm design for an image processing API: a technical report on ITK-the insight
               toolkit},
  year      = {2002}
}

@inproceedings{zhang.2016.colorful,
  abstract  = {Given a grayscale photograph as input, this paper attacks the problem of hallucinating a plausible color
               version of the photograph. This problem is clearly underconstrained, so previous approaches have either
               relied on significant user interaction or resulted in desaturated colorizations. We propose a fully
               automatic approach that produces vibrant and realistic colorizations. We embrace the underlying
               uncertainty of the problem by posing it as a classification task and use class-rebalancing at training
               time to increase the diversity of colors in the result. The system is implemented as a feed-forward pass
               in a CNN at test time and is trained on over a million color images. We evaluate our algorithm using a
               ``colorization Turing test,'' asking human participants to choose between a generated and ground truth
               color image. Our method successfully fools humans on 32 {\%} of the trials, significantly higher than
               previous methods. Moreover, we show that colorization can be a powerful pretext task for self-supervised
               feature learning, acting as a cross-channel encoder. This approach results in state-of-the-art
               performance on several feature learning benchmarks.},
  address   = {Cham},
  author    = {Zhang, Richard and Isola, Phillip and Efros, Alexei A.},
  booktitle = {Computer Vision -- ECCV 2016},
  editor    = {Leibe, Bastian and Matas, Jiri and Sebe, Nicu and Welling, Max},
  isbn      = {978-3-319-46487-9},
  pages     = {649--666},
  publisher = {Springer International Publishing},
  title     = {Colorful Image Colorization},
  year      = {2016}
}
