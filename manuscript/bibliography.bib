@String{pub-ISO     = "International Organization for Standardization"}

@String{pub-ISO:adr = "Geneva, Switzerland"}

@inproceedings{abrahams.2000.exceptions-generic,
  author    = {Abrahams, David},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David R.},
  title     = {Exception-Safety in Generic Components},
  booktitle = {Generic Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {69--79},
  abstract  = {This paper represents the knowledge accumulated in response to a real-world need: that the C++ Standard
               Template Library exhibit useful and well-defined interactions with exceptions, the error-handling
               mechanism built-in to the core C++ language. It explores the meaning of exception-safety, reveals
               surprising myths about exceptions and genericity, describes valuable tools for reasoning about program
               correctness, and outlines an automated testing procedure for verifying exception-safety.},
  isbn      = {978-3-540-39953-7}
}

@software{adobe.2019.photoshop,
  author  = {Adobe},
  title   = {Adobe Photoshop},
  url     = {https://photoshop.com/fr},
  version = {22.2},
  date    = {2021-02-09}
}

@inproceedings{aksel.2020.hipsycl,
  author    = {Alpay, Aksel and Heuveline, Vincent},
  title     = {SYCL beyond OpenCL: The Architecture, Current State and Future Direction of HipSYCL},
  year      = {2020},
  isbn      = {9781450375313},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3388333.3388658},
  doi       = {10.1145/3388333.3388658},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  articleno = {8},
  numpages  = {1},
  keywords  = {heterogeneity, SYCL, parallelism, CUDA, parallelruntimes, HIP, C++, GPU, compilers},
  location  = {Munich, Germany},
  series    = {IWOCL '20}
}

@software{anaconda.2020,
  author  = {{Anaconda, Inc.}},
  title   = {Anaconda},
  url     = {https://anaconda.com},
  version = {2020.11},
  date    = {2020-11-19}
}

@article{angulo.2007.morpho_color,
  title    = {Morphological colour operators in totally ordered lattices based on distances: Application to image
              filtering, enhancement and analysis},
  journal  = {Computer Vision and Image Understanding},
  volume   = {107},
  number   = {1},
  pages    = {56-73},
  year     = {2007},
  note     = {Special issue on color image processing},
  issn     = {1077-3142},
  doi      = {https://doi.org/10.1016/j.cviu.2006.11.008},
  url      = {https://www.sciencedirect.com/science/article/pii/S1077314206002165},
  author   = {Jesús Angulo},
  keywords = {Colour mathematical morphology, Colour distance, Multivariate ordering, Colour feature extraction,
              Colour noise removal, Colour contrast enhancement, LSH, Lab},
  abstract = {The extension of mathematical morphology operators to multi-valued functions, and in particular to colour
              images, is neither direct nor general. In this paper, a generalisation of distance-based and
              lexicographical-based approaches is proposed, allowing the extension of morphological operators to colour
              images for any colour representation (e.g., RGB, LSH and L*a*b*) and for any metric distance to a
              reference colour. The performance of the introduced operators is illustrated by means of different
              applications: colour feature extraction using openings (closings) by reconstruction, colour gradients for
              segmenting, colour denoising by the centre operator and colour enhancement by the contrast mapping.
              Examples from natural colour images and biomedical microscopic colour images are given.}
}

@book{ansi.1983.ada,
  author    = {{ANSI}},
  title     = {{ANSI/MIL-STD-1815A}: {Programming} languages --- {Ada}},
  publisher = {American National Standards Institute},
  pages     = {333},
  month     = {06},
  year      = {1983},
  url       = {https://www.iso.org/standard/16028.html}
}

@inproceedings{atkinson.1978.cluimpl,
  author    = {Atkinson, Russell R. and Liskov, Barbara H. and Scheifler, Robert W.},
  title     = {Aspects Of Implementing CLU},
  year      = {1978},
  isbn      = {0897910001},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/800127.804079},
  doi       = {10.1145/800127.804079},
  abstract  = {Linguistic mechanisms used in CLU to support 1) structured exception handling, 2) iteration over abstract
               objects, and 3) parameterized abstractions are briefly reviewed, and methods of realizing these
               mechanisms are described. The mechanisms discussed support features that are likely to be included in
               other programming languages, and the implementation methods should be applicable to a wide range of
               languages.},
  booktitle = {Proceedings of the 1978 Annual Conference},
  pages     = {123-129},
  numpages  = {7},
  keywords  = {CLU, Iterators, Programming language, Parameterized modules, Exception handling, Implementation methods},
  location  = {Washington, D.C., USA},
  series    = {ACM '78}
}

@inproceedings{austern.2000.segmented,
  author    = {Austern, Matthew H.},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David R.},
  title     = {Segmented Iterators and Hierarchical Algorithms},
  booktitle = {Generic Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {80--90},
  abstract  = {Many data structures are naturally segmented. Generic algorithms that ignore that feature, and that treat
               every data structure as a uniform range of elements, are unnecessarily inefficient. A new kind of
               iterator abstraction, in which segmentation is explicit, makes it possible to write hierarchical
               algorithms that exploit segmentation.},
  isbn      = {978-3-540-39953-7}
}

@article{backus.1978.functional,
  author     = {Backus, John},
  title      = {Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs},
  year       = {1978},
  issue_date = {Aug. 1978},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {21},
  number     = {8},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/359576.359579},
  doi        = {10.1145/359576.359579},
  abstract   = {Conventional programming languages are growing ever more enormous, but not stronger. Inherent defects at
                the most basic level cause them to be both fat and weak: their primitive word-at-a-time style of
                programming inherited from their common ancestor—the von Neumann computer, their close coupling of
                semantics to state transitions, their division of programming into a world of expressions and a world of
                statements, their inability to effectively use powerful combining forms for building new programs from
                existing ones, and their lack of useful mathematical properties for reasoning about programs. An
                alternative functional style of programming is founded on the use of combining forms for creating
                programs. Functional programs deal with structured data, are often non-repetitive and non-recursive, are
                hierarchically constructed, do not name their arguments, and do not require the complex machinery of
                procedure declarations to become generally applicable. Combining forms can use high level programs to
                build still higher level ones in a style not possible in conventional languages. Associated with the
                functional style of programming is an algebra of programs whose variables range over programs and whose
                operations are combining forms. This algebra can be used to transform programs and to solve equations
                whose ``unknowns'' are programs in much the same way one transforms equations in high school algebra.
                These transformations are given by algebraic laws and are carried out in the same language in which
                programs are written. Combining forms are chosen not only for their programming power but also for the
                power of their associated algebraic laws. General theorems of the algebra give the detailed behavior and
                termination conditions for large classes of programs. A new class of computing systems uses the
                functional programming style both in its programming language and in its state transition rules. Unlike
                von Neumann languages, these systems have semantics loosely coupled to states—only one state transition
                occurs per major computation.},
  journal    = {Commun. ACM},
  month      = aug,
  pages      = {613-641},
  numpages   = {29},
  keywords   = {algebra of programs, models of computing systems, functional forms, combining forms,
                program termination, metacomposition, applicative state transition systems, program correctness,
                programming languages, program transformation, functional programming, von Neumann languages,
                von Neumann computers, applicative computing systems}
}

@inproceedings{beazley.1996.swig,
  title     = {SWIG: An Easy to Use Tool for Integrating Scripting Languages with C and C++.},
  author    = {Beazley, David M and others},
  booktitle = {Tcl/Tk Workshop},
  volume    = {43},
  pages     = {74},
  year      = {1996}
}

@article{behnel.2010.cython,
  author   = {Behnel, S. and Bradshaw, R. and Citro, C. and Dalcin, L. and Seljebotn, D.S. and Smith, K.},
  journal  = {Computing in Science Engineering},
  title    = {Cython: The Best of Both Worlds},
  year     = {2011},
  month    = {03},
  volume   = {13},
  number   = {2},
  pages    = {31-39},
  keywords = {Cython language; Fortran code; Python language extension; numerical loops; programming language;
              Clanguage; numerical analysis},
  doi      = {10.1109/MCSE.2010.118},
  issn     = {1521-9615}
}

@article{bentley.1983.programming,
  title     = {Programming pearls: Writing correct programs},
  author    = {Bentley, Jon},
  journal   = {Communications of the ACM},
  volume    = {26},
  number    = {12},
  pages     = {1040--1045},
  year      = {1983},
  publisher = {ACM New York, NY, USA}
}

@book{bentley.2016.programming,
  title     = {Programming pearls},
  author    = {Bentley, Jon},
  year      = {2016},
  publisher = {Addison-Wesley Professional}
}

@article{berti.2006.gral,
  title     = {{GrAL}--the Grid Algorithms Library},
  author    = {Guntram Berti},
  journal   = {Future Generation Computer Systems},
  volume    = {22},
  number    = {1-2},
  pages     = {110--122},
  year      = {2006},
  publisher = {Elsevier}
}

@software{boost.2021,
  author  = {Boost},
  title   = {Boost C++ Libraries},
  url     = {https://www.boost.org/},
  version = {1.76.0},
  date    = {2021-04-16}
}



@book{bourbaki.1970.theorie,
  title     = {Th{\'e}orie des ensembles},
  author    = {Bourbaki, Nicolas},
  volume    = {1},
  year      = {1970},
  publisher = {Hermann Paris}
}

@misc{bourdev.2006.bgil,
  author       = {Lubomir Bourdev and Hailin Jin},
  title        = {{B}oost {G}eneric {I}mage {L}ibrary},
  year         = {2006},
  howpublished = {{A}dobe stlab},
  note         = {Available at \url{https://stlab.adobe.com/gil/index.html}}
}

@article{bourdev.2011.runtimedispatch,
  title    = {Efficient run-time dispatching in generic programming with minimal code bloat},
  journal  = {Science of Computer Programming},
  volume   = {76},
  number   = {4},
  pages    = {243 - 257},
  year     = {2011},
  note     = {Special issue on library-centric software design (LCSD 2006)},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2008.06.003},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167642308000634},
  author   = {Lubomir Bourdev and Jaakko Järvi},
  keywords = {Generic programming, C++ templates, Template bloat, Template
              metaprogramming}
}

@article{bradski.2000.opencv,
  author               = {Bradski, G.},
  citeulike-article-id = {2236121},
  journal              = {Dr. Dobb's Journal of Software Tools},
  keywords             = {bibtex-import},
  posted-at            = {2008-01-15 19:21:54},
  priority             = {4},
  title                = {{The OpenCV Library}},
  year                 = {2000}
}

@inproceedings{brown.2019.heterogeneous,
  author    = {Brown, Gordon and Reyes, Ruyman and Wong, Michael},
  title     = {Towards Heterogeneous and Distributed Computing in C++},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  series    = {IWOCL'19},
  year      = {2019},
  isbn      = {978-1-4503-6230-6},
  location  = {Boston, MA, USA},
  pages     = {18:1--18:5},
  articleno = {18},
  numpages  = {5},
  url       = {http://doi.acm.org/10.1145/3318170.3318196},
  doi       = {10.1145/3318170.3318196},
  acmid     = {3318196},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {C++, concurrency, distributed programming models, executors,
               heterogeneous programming, parallelism}
}

@inproceedings{burrus.2003.mpool,
  author       = {Nicolas Burrus and Alexandre Duret-Lutz and Thierry G\'eraud and David Lesage and Rapha\"el Poss},
  title        = {A static {C++} object-oriented programming ({SCOOP}) paradigm mixing benefits of traditional {OOP} and
                  generic programming},
  booktitle    = {Proceedings of the Workshop on Multiple Paradigm with Object-Oriented Languages (MPOOL)},
  year         = 2003,
  address      = {Anaheim, CA, USA},
  month        = oct,
  abstract     = {Object-oriented and generic programming are both supported in C++. OOP provides high expressiveness
                  whereas GP leads to more efficient programs by avoiding dynamic typing. This paper presents SCOOP, a
                  new paradigm which enables both classical OO design and high performance in C++ by mixing OOP and GP.
                  We show how classical and advanced OO features such as virtual methods, multiple inheritance, argument
                  covariance, virtual types and multimethods can be implemented in a fully statically typed model, hence
                  without run-time overhead.},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/mpool03-abstract.pdf},
  lrdeprojects = {Olena},
  lrdenewsdate = {2003-10-29}
}

@techreport{c++.2020.stddraftN4849,
  author       = {Richard Smith},
  title        = {{N4849}: Working Draft, Standard for Programming Language {C++}},
  note         = {{\small\url{https://wg21.link/n4849}}},
  institution  = {International Organization for Standardization},
  year         = 2020,
  month        = jan,
  optpublisher = {WG21}
}

@article{carlinet.2014.tip,
  author   = {Edwin Carlinet and Thierry G\'eraud},
  title    = {A Comparative Review of Component Tree Computation Algorithms},
  journal  = {IEEE Transactions on Image Processing},
  year     = {2014},
  volume   = {23},
  number   = {9},
  optmonth = {September},
  pages    = {3885--3895}
}

@article{carlinet.2015.tip,
  author   = {Edwin Carlinet and Thierry G\'eraud},
  title    = {{MToS}: {A} Tree of Shapes for Multivariate Images},
  journal  = {IEEE Transactions on Image Processing},
  year     = {2015},
  volume   = {24},
  number   = {12},
  pages    = {5330--5342},
  optmonth = {December}
}

@misc{carlinet.2018.pylena,
  author       = {Edwin Carlinet and others},
  title        = {{P}ylena: a Modern {C}++ Image Processing Generic
                  Library},
  year         = {2018},
  howpublished = {{EPITA} Research and Developement Laboratory},
  note         = {Available at \url{https://gitlab.lrde.epita.fr/olena/pylene}}
}

@misc{carter.2018.concepts,
  title        = {Standard Library Concepts},
  author       = {Casey Carter and Eric Niebler},
  year         = {2018},
  key          = {P0898r3},
  month        = {06},
  organization = {WG21},
  url          = {https://wg21.link/p0898r3}
}

@online{chollet.2015.keras,
  title     = {Keras},
  author    = {Chollet, Francois and others},
  year      = {2015},
  publisher = {GitHub},
  url       = {https://github.com/fchollet/keras}
}

@software{clark.2021.pillow,
  author  = {{Alex Clark and al.}},
  title   = {Pillow},
  url     = {https://python-pillow.org},
  version = {8.1.2},
  date    = {2021-03-06}
}

@software{codeplay.2021.computecpp,
  author  = {Codeplay},
  title   = {ComputeCpp},
  url     = {https://codeplay.com/products/computesuite/computecpp},
  version = {2.8.0}
}

@misc{coeurjolly.2016.dgtal,
  title  = {DGtal: Digital geometry tools and algorithms library},
  author = {Coeurjolly, D and Lachaud, JO and Kerautret, B},
  year   = {2016}
}

@inbook{coplien.1996.crtp,
  author    = {Coplien, James O.},
  title     = {Curiously Recurring Template Patterns},
  year      = {1996},
  isbn      = {1884842372},
  publisher = {SIGS Publications, Inc.},
  address   = {USA},
  booktitle = {C++ Gems},
  pages     = {135-144},
  numpages  = {10}
}

@article{curtsinger.2013.stabilizer-art,
  author     = {Curtsinger, Charlie and Berger, Emery D.},
  title      = {STABILIZER: Statistically Sound Performance Evaluation},
  year       = {2013},
  issue_date = {March 2013},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {41},
  number     = {1},
  issn       = {0163-5964},
  url        = {https://doi.org/10.1145/2490301.2451141},
  doi        = {10.1145/2490301.2451141},
  abstract   = {Researchers and software developers require effective performance evaluation. Researchers must evaluate
                optimizations or measure overhead. Software developers use automatic performance regression tests to
                discover when changes improve or degrade performance. The standard methodology is to compare execution
                times before and after applying changes. Unfortunately, modern architectural features make this approach
                unsound. Statistically sound evaluation requires multiple samples to test whether one can or cannot
                (with high confidence) reject the null hypothesis that results are the same before and after. However,
                caches and branch predictors make performance dependent on machine-specific parameters and the exact
                layout of code, stack frames, and heap objects. A single binary constitutes just one sample from the
                space of program layouts, regardless of the number of runs. Since compiler optimizations and code
                changes also alter layout, it is currently impossible to distinguish the impact of an optimization from
                that of its layout effects. This paper presents Stabilizer, a system that enables the use of the
                powerful statistical techniques required for sound performance evaluation on modern architectures.
                Stabilizer forces executions to sample the space of memory configurations by repeatedly re-randomizing
                layouts of code, stack, and heap objects at runtime. Stabilizer thus makes it possible to control for
                layout effects. Re-randomization also ensures that layout effects follow a Gaussian distribution,
                enabling the use of statistical tests like ANOVA. We demonstrate Stabilizer's efficiency (< 7% median
                overhead) and its effectiveness by evaluating the impact of LLVM's optimizations on the SPEC CPU2006
                benchmark suite. We find that, while -O2 has a significant impact relative to -O1, the performance
                impact of -O3 over -O2 optimizations is indistinguishable from random noise.},
  journal    = {SIGARCH Comput. Archit. News},
  month      = mar,
  pages      = {219-228},
  numpages   = {10},
  keywords   = {measurement bias, performance evaluation, randomization}
}

@inproceedings{curtsinger.2013.stabilizer-proc,
  author    = {Curtsinger, Charlie and Berger, Emery D.},
  title     = {STABILIZER: Statistically Sound Performance Evaluation},
  year      = {2013},
  isbn      = {9781450318709},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2451116.2451141},
  doi       = {10.1145/2451116.2451141},
  abstract  = {Researchers and software developers require effective performance evaluation. Researchers must evaluate
               optimizations or measure overhead. Software developers use automatic performance regression tests to
               discover when changes improve or degrade performance. The standard methodology is to compare execution
               times before and after applying changes. Unfortunately, modern architectural features make this approach
               unsound. Statistically sound evaluation requires multiple samples to test whether one can or cannot
               (with high confidence) reject the null hypothesis that results are the same before and after. However,
               caches and branch predictors make performance dependent on machine-specific parameters and the exact
               layout of code, stack frames, and heap objects. A single binary constitutes just one sample from the
               space of program layouts, regardless of the number of runs. Since compiler optimizations and code
               changes also alter layout, it is currently impossible to distinguish the impact of an optimization from
               that of its layout effects. This paper presents Stabilizer, a system that enables the use of the
               powerful statistical techniques required for sound performance evaluation on modern architectures.
               Stabilizer forces executions to sample the space of memory configurations by repeatedly re-randomizing
               layouts of code, stack, and heap objects at runtime. Stabilizer thus makes it possible to control for
               layout effects. Re-randomization also ensures that layout effects follow a Gaussian distribution,
               enabling the use of statistical tests like ANOVA. We demonstrate Stabilizer's efficiency (< 7% median
               overhead) and its effectiveness by evaluating the impact of LLVM's optimizations on the SPEC CPU2006
               benchmark suite. We find that, while -O2 has a significant impact relative to -O1, the performance
               impact of -O3 over -O2 optimizations is indistinguishable from random noise.},
  journal   = {SIGARCH Comput. Archit. News},
  booktitle = {Proceedings of the Eighteenth International Conference on Architectural Support for Programming Languages
               and Operating Systems},
  pages     = {219-228},
  numpages  = {10},
  keywords  = {measurement bias, randomization, performance evaluation},
  location  = {Houston, Texas, USA},
  series    = {ASPLOS '13}
}

@inproceedings{curtsinger.2015.coz,
  author    = {Curtsinger, Charlie and Berger, Emery D.},
  title     = {Coz: Finding Code That Counts with Causal Profiling},
  year      = {2015},
  isbn      = {9781450338349},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2815400.2815409},
  doi       = {10.1145/2815400.2815409},
  abstract  = {Improving performance is a central concern for software developers. To locate optimization opportunities,
               developers rely on software profilers. However, these profilers only report where programs spent their
               time: optimizing that code may have no impact on performance. Past profilers thus both waste developer
               time and make it difficult for them to uncover significant optimization opportunities. This paper
               introduces causal profiling. Unlike past profiling approaches, causal profiling indicates exactly where
               programmers should focus their optimization efforts, and quantifies their potential impact. Causal
               profiling works by running performance experiments during program execution. Each experiment calculates
               the impact of any potential optimization by virtually speeding up code: inserting pauses that slow down
               all other code running concurrently. The key insight is that this slowdown has the same relative effect
               as running that line faster, thus "virtually" speeding it up. We present Coz, a causal profiler, which we
               evaluate on a range of highly-tuned applications: Memcached, SQLite, and the PARSEC benchmark suite. Coz
               identifies previously unknown optimization opportunities that are both significant and targeted. Guided
               by Coz, we improve the performance of Memcached by 9%, SQLite by 25%, and accelerate six PARSEC
               applications by as much as 68%; in most cases, these optimizations involve modifying under 10 lines of
               code.},
  booktitle = {Proceedings of the 25th Symposium on Operating Systems Principles},
  pages     = {184-197},
  numpages  = {14},
  location  = {Monterey, California},
  series    = {SOSP '15}
}

@inproceedings{czarnecki.2000.generative,
  author    = {Czarnecki, Krzysztof and Eisenecker, Ulrich and Gl{\"u}ck, Robert and Vandevoorde, David and
               Veldhuizen, Todd},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David R.},
  title     = {Generative Programming and Active Libraries},
  booktitle = {Generic Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {25--39},
  abstract  = {We describe generative programming, an approach to generating customized programming components or
               systems, and active libraries, which are based on this approach. In contrast to conventional libraries,
               active libraries may contain metaprograms that implement domain-specific code generation, optimizations,
               debugging, profiling and testing. Several working examples (Blitz++, GMCL, Xroma) are presented to
               illustrate the potential of active libraries. We discuss relevant implementation technologies.},
  isbn      = {978-3-540-39953-7},
  url       = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.646.8822&rep=rep1&type=pdf}
}

@inproceedings{darbon.2002.ismm,
  author       = {J\'er\^ome Darbon and Thierry G\'eraud and Alexandre Duret-Lutz},
  title        = {Generic implementation of morphological image operators},
  booktitle    = {Mathematical Morphology, Proceedings of the 6th International Symposium (ISMM)},
  pages        = {175--184},
  year         = 2002,
  address      = {Sydney, Australia},
  month        = apr,
  publisher    = {CSIRO Publishing},
  abstract     = {Several libraries dedicated to mathematical morphology exist. But they lack genericity, that is to
                  say, the ability for operators to accept input of different natures --- 2D binary images, graphs
                  enclosing floating values, etc. We describe solutions which are integrated in Olena, a library
                  providing morphological operators. We demonstrate with some examples that translating mathematical
                  formulas and algorithms into source code is made easy and safe with Olena. Moreover, experimental
                  results show that no extra costs at run-time are induced.},
  lrdeprojects = {Olena}
}

@inproceedings{darbon.2004.ecoopphd,
  author       = {J\'er\^ome Darbon and Thierry G\'eraud and Patrick Bellot},
  title        = {Generic algorithmic blocks dedicated to image processing},
  booktitle    = {Proceedings of the ECOOP Workshop for PhD Students},
  year         = 2004,
  address      = {Oslo, Norway},
  month        = jun,
  abstract     = {This paper deals with the implementation of algorithms in the specific domain of image processing.
                  Although many image processing libraries are available, they generally lack genericity and
                  flexibility. Many image processing algorithms can be expressed as compositions of elementary
                  algorithmic operations referred to as blocks. Implementing these compositions is achieved using
                  generic programming. Our solution is compared to previous ones, and we demonstrate it on a class image
                  processing algorithms.},
  lrdeprojects = {Olena},
  lrdenewsdate = {2004-03-10}
}

@article{dean.2008.mapreduce,
  author     = {Dean, Jeffrey and Ghemawat, Sanjay},
  title      = {MapReduce: Simplified Data Processing on Large Clusters},
  year       = {2008},
  issue_date = {January 2008},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {1},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/1327452.1327492},
  doi        = {10.1145/1327452.1327492},
  abstract   = {MapReduce is a programming model and an associated implementation for processing and generating large
                datasets that is amenable to a broad variety of real-world tasks. Users specify the computation in terms
                of a map and a reduce function, and the underlying runtime system automatically parallelizes the
                computation across large-scale clusters of machines, handles machine failures, and schedules
                inter-machine communication to make efficient use of the network and disks. Programmers find the system
                easy to use: more than ten thousand distinct MapReduce programs have been implemented internally at
                Google over the past four years, and an average of one hundred thousand MapReduce jobs are executed on
                Google's clusters every day, processing a total of more than twenty petabytes of data per day.},
  journal    = {Commun. ACM},
  month      = {01},
  pages      = {107-113},
  numpages   = {7}
}

@misc{dean.2019.monoids,
  author    = {Ben Dean},
  title     = {Identifying Monoids: Exploiting Compositional Structure in Code},
  url       = {https://cppnow2019.sched.com/event/b60160aa659270370279c5acb6196fb6},
  month     = {06},
  year      = {2019},
  publisher = {{C++Now} 2019},
  note      = {Slides available at
               \url{https://github.com/boostcon/cppnow_presentations_2019/blob/master/05-09-2019_thursday/Identifying_Monoids_Exploiting_Compositional_Structure_in_Code__Ben_Deane_cppnow_05092019.pdf},
               Talk available on youtube at \url{https://youtu.be/INnattuluiM}}
}

@inproceedings{dehnert.1998.fundamentals,
  title        = {Fundamentals of Generic Programming},
  author       = {James C. Dehnert and Alexander Stepanov},
  booktitle    = {Generic Programming},
  errbooktitle = {Intl. Symp. on Symbolic and Algebraic Computation},
  optmonth     = {apr},
  year         = 2000,
  series       = {LNCS},
  volume       = {1766},
  pages        = {1--11},
  organization = {Springer}
}

@inproceedings{demaille.2013.vcsn,
  author    = {Demaille, Akim and Duret-Lutz, Alexandre and Lombardy, Sylvain and Sakarovitch, Jacques},
  editor    = {Konstantinidis, Stavros},
  title     = {Implementation Concepts in Vaucanson 2},
  booktitle = {Implementation and Application of Automata},
  year      = {2013},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {122--133},
  abstract  = {Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It
               is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten
               years ago, several shortcomings were discovered along the years, especially problems related to code
               complexity and obfuscation as well as performance issues. This paper presents the concepts underlying
               Vaucanson 2, a complete rewrite of the platform that addresses these issues.},
  isbn      = {978-3-642-39274-0}
}

@inproceedings{dewitte.2005.morpho_color,
  author    = {De Witte, Val{\'e}rie and Schulte, Stefan and Nachtegael, Mike and Van der Weken, Dietrich and
               Kerre, Etienne E.},
  editor    = {Kamel, Mohamed and Campilho, Aur{\'e}lio},
  title     = {Vector Morphological Operators for Colour Images},
  booktitle = {Image Analysis and Recognition},
  year      = {2005},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {667--675},
  abstract  = {In this paper we extend the basic morphological operators dilation and erosion for grey-scale images
               based on the threshold approach, umbra approach and fuzzy set theory to colour images. This is realised
               by treating colours as vectors and defining a new vector ordering so that new colour morphological
               operators are presented. Here we only discuss colours represented in the RGB colour space. The colour
               space RGB becomes together with the new ordering and associated minimum and maximum operators a complete
               chain. All this can be extended to the colour spaces HSV and L*a*b*. Experimental results show that our
               method provides an improvement on the component-based approach of morphological operators applied to
               colour images. The colours in the colour images are preserved, that is, no new colours are introduced.},
  isbn      = {978-3-540-31938-2}
}

@software{dionne.2021.metabench,
  author  = {Louis Dionne},
  title   = {Metabench},
  url     = {https://github.com/ldionne/metabench/},
  version = {head},
  date    = {2019-09-16}
}

@article{dosries.2066.specifying.art,
  author     = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  title      = {Specifying C++ Concepts},
  year       = {2006},
  issue_date = {January 2006},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {41},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1111320.1111064},
  doi        = {10.1145/1111320.1111064},
  abstract   = {C++ templates are key to the design of current successful mainstream libraries and systems. They are the
                basis of programming techniques in diverse areas ranging from conventional general-purpose programming
                to software for safety-critical embedded systems. Current work on improving templates focuses on the
                notion of concepts (a type system for templates), which promises significantly improved error
                diagnostics and increased expressive power such as concept-based overloading and function template
                partial specialization. This paper presents C++ templates with an emphasis on problems related to
                separate compilation. We consider the problem of how to express concepts in a precise way that is simple
                enough to be usable by ordinary programmers. In doing so, we expose a few weaknesses of the current
                specification of the C++ standard library and suggest a far more precise and complete specification. We
                also present a systematic way of translating our proposed concept definitions, based on use-patterns
                rather than function signatures, into constraint sets that can serve as convenient basis for concept
                checking in a compiler.},
  journal    = {SIGPLAN Not.},
  month      = jan,
  pages      = {295-308},
  numpages   = {14},
  keywords   = {C++ concepts, C++ templates, separate compilation, generic programming, type systems}
} 

@inproceedings{dosries.2066.specifying.proc,
  author    = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  title     = {Specifying C++ Concepts},
  year      = {2006},
  isbn      = {1595930272},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1111037.1111064},
  doi       = {10.1145/1111037.1111064},
  abstract  = {C++ templates are key to the design of current successful mainstream libraries and systems. They are the
               basis of programming techniques in diverse areas ranging from conventional general-purpose programming to
               software for safety-critical embedded systems. Current work on improving templates focuses on the notion
               of concepts (a type system for templates), which promises significantly improved error diagnostics and
               increased expressive power such as concept-based overloading and function template partial
               specialization. This paper presents C++ templates with an emphasis on problems related to separate
               compilation. We consider the problem of how to express concepts in a precise way that is simple enough to
               be usable by ordinary programmers. In doing so, we expose a few weaknesses of the current specification
               of the C++ standard library and suggest a far more precise and complete specification. We also present a
               systematic way of translating our proposed concept definitions, based on use-patterns rather than
               function signatures, into constraint sets that can serve as convenient basis for concept checking in a
               compiler.},
  booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {295-308},
  numpages  = {14},
  keywords  = {C++ concepts, generic programming, type systems, C++ templates, separate compilation},
  location  = {Charleston, South Carolina, USA},
  series    = {POPL '06}
}

@inproceedings{duretlutz.2000.olena,
  title        = {Olena: a component-based platform for image processing, mixing generic, generative and OO programming},
  author       = {Duret-Lutz, Alexandre},
  booktitle    = {symposium on Generative and Component-Based Software Engineering, Young Researchers Workshop},
  volume       = {10},
  year         = {2000},
  organization = {Citeseer}
}

@inproceedings{esterie.2014.boostsimd,
  author    = {Est{\'e}rie, Pierre and Falcou, Joel and Gaunard, Mathias and Laprest{\'e}, Jean-Thierry},
  title     = {Boost.SIMD: Generic Programming for Portable SIMDization},
  booktitle = {Proceedings of the 2014 Workshop on Programming Models for SIMD/Vector Processing},
  series    = {WPMVP '14},
  year      = {2014},
  isbn      = {978-1-4503-2653-7},
  location  = {Orlando, Florida, USA},
  pages     = {1--8},
  numpages  = {8},
  url       = {http://doi.acm.org/10.1145/2568058.2568063},
  doi       = {10.1145/2568058.2568063},
  acmid     = {2568063},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {SIMD, c++, generic programming, template meta-programming}
}

@book{etter.1993.engineering,
  title     = {Engineering problem solving with MATLAB},
  author    = {Etter, Delores M and Etter, Dolores M and Etter, Delores M},
  volume    = {2},
  year      = {1993},
  publisher = {Prentice Hall Englewood cliffs, New Jersey 07632}
}

@book{etter.2002.introduction,
  title     = {Introduction to MATLAB},
  author    = {Etter, Delores M and Kuncicky, David C and Hull, Douglas W},
  year      = {2002},
  publisher = {Prentice Hall}
}

@article{fernique.2018.autowig,
  title     = {AutoWIG: automatic generation of python bindings for C++ libraries},
  author    = {Fernique, Pierre and Pradal, Christophe},
  journal   = {PeerJ Computer Science},
  volume    = {4},
  pages     = {e149},
  year      = {2018},
  publisher = {PeerJ Inc.},
  url       = {https://peerj.com/articles/cs-149.pdf}
}

@inbook{floyd.1993.meaning,
  author    = {Floyd, Robert W.},
  editor    = {Colburn, Timothy R. and Fetzer, James H. and Rankin, Terry L.},
  title     = {Assigning Meanings to Programs},
  booktitle = {Program Verification: Fundamental Issues in Computer Science},
  year      = {1993},
  publisher = {Springer Netherlands},
  address   = {Dordrecht},
  pages     = {65--81},
  abstract  = {This paper attempts to provide an adequate basis for formal definitions of the meanings of programs in
               appropriately defined programming languages, in such a way that a rigorous standard is established for
               proofs about computer programs, including proofs of correctness, equivalence, and termination. The basis
               of our approach is the notion of an interpretation of a program: that is, an association of a proposition
               with each connection in the flow of control through a program, where the proposition is asserted to hold
               whenever that connection is taken. To prevent an interpretation from being chosen arbitrarily, a
               condition is imposed on each command of the program. This condition guarantees that whenever a command is
               reached by way of a connection whose associated proposition is then true, it will be left (if at all) by
               a connection whose associated proposition will be true at that time. Then by induction on the number of
               commands executed, one sees that if a program is entered by a connection whose associated proposition is
               then true, it will be left (if at all) by a connection whose associated proposition will be true at that
               time. By this means, we may prove certain properties of programs, particularly properties of the form:
               `If the initial values of the program variables satisfy the relation Rl, the final values on completion
               will satisfy the relation R2'.},
  isbn      = {978-94-011-1793-7},
  doi       = {10.1007/978-94-011-1793-7_4},
  url       = {https://doi.org/10.1007/978-94-011-1793-7_4}
}

@misc{fog.2013.vcl,
  title  = {{C}++ vector class library},
  author = {Fog, Agner},
  note   = {\url{http://www.agner.org/optimize/vectorclass.pdf}},
  pages  = {33},
  year   = {2013}
}

@misc{froment.2004.megawave2,
  title  = {MegaWave2 user's guide},
  author = {Froment, Jacques},
  year   = {2004}
}

@inproceedings{froment.2012.megawave,
  title       = {{MegaWave}},
  author      = {Froment, Jacques},
  url         = {https://hal.archives-ouvertes.fr/hal-00907378},
  booktitle   = {{IPOL 2012 Meeting on Image Processing Libraries}},
  address     = {France},
  year        = {2012},
  month       = Jun,
  hal_id      = {hal-00907378},
  hal_version = {v1}
}

@book{gamma.1995.design,
  title     = {Design patterns: elements of reusable object-oriented software},
  author    = {Erich Gamma},
  year      = {1995},
  publisher = {Pearson Education India}
}

@inproceedings{garrigues.2014.video++,
  title        = {Video++, a modern image and video processing {C}++ framework},
  author       = {Matthieu Garrigues and Antoine Manzanera},
  booktitle    = {Conference on Design and Architectures for Signal and Image Processing (DASIP)},
  pages        = {1--6},
  year         = {2014},
  organization = {IEEE}
}

@inproceedings{geraud.2000.europlop,
  author       = {Thierry G\'eraud and Alexandre Duret-Lutz},
  title        = {Generic programming redesign of patterns},
  booktitle    = {Proceedings of the 5th European Conference on Pattern Languages of Programs (EuroPLoP)},
  year         = 2000,
  month        = jul,
  address      = {Irsee, Germany},
  pages        = {283--294},
  editors      = {M. Devos and A. R\"uping},
  publisher    = {UVK, Univ. Verlag, Konstanz},
  lrdeprojects = {Software},
  abstract     = {This pattern faces the problem of improving the performances of design patterns when they are involved
                  in intensive algorithms. Generic programming is a paradigm in which most classes and procedures are
                  parameterized, thus leading to the construction of general and efficient software components. We
                  demonstrate that some design patterns from Gamma et al. can be translated into this paradigm while
                  handling operation polymorphism by parametric polymorphism. We thus preserve their modularity and
                  reusability properties but we avoid the performance penalty due to their dynamic behavior, which is a
                  critical issue in numerical computing.},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/europlop00.pdf},
  lrdekeywords = {Software engineering}
}

@inproceedings{geraud.2000.icpr,
  author       = {Thierry G\'eraud and Yoann Fabre and Alexandre Duret-Lutz and Dimitri Papadopoulos-Orfanos and
                  Jean-Fran\c{c}ois Mangin},
  title        = {Obtaining genericity for image processing and pattern recognition algorithms},
  booktitle    = {Proceedings of the 15th International Conference on Pattern Recognition (ICPR)},
  year         = 2000,
  month        = sep,
  address      = {Barcelona, Spain},
  volume       = 4,
  pages        = {816--819},
  publisher    = {IEEE Computer Society},
  lrdeprojects = {Olena},
  abstract     = {Algorithm libraries dedicated to image processing and pattern recognition are not reusable; to run an
                  algorithm on particular data, one usually has either to rewrite the algorithm or to manually ``copy,
                  paste, and modify''. This is due to the lack of genericity of the programming paradigm used to
                  implement the libraries. In this paper, we present a recent paradigm that allows algorithms to be
                  written once and for all and to accept input of various types. Moreover, this total reusability can be
                  obtained with a very comprehensive writing and without significant cost at execution, compared to a
                  dedicated algorithm. This new paradigm is called ``generic programming'' and is fully supported by the
                  C++ language. We show how this paradigm can be applied to image processing and pattern recognition
                  routines. The perspective of our work is the creation of a generic library.}
}

@misc{geraud.2006.scoop-pres,
  author       = {Thierry G\'eraud},
  title        = {Advanced Static Object-Oriented Programming Features: A Sequel to {SCOOP}},
  howpublished = {\url{http://www.lrde.epita.fr/people/theo/pub/olena/olena-06-jan.pdf}},
  month        = jan,
  year         = 2006,
  project      = {Olena},
  urllrde      = {200601-TR}
}

@inproceedings{geraud.2008.mpool,
  author       = {Thierry G\'eraud and Roland Levillain},
  title        = {Semantics-Driven Genericity: A Sequel to the Static {C++} Object-Oriented Programming Paradigm
                  ({SCOOP 2})},
  booktitle    = {Proceedings of the 6th International Workshop on Multiparadigm Programming with Object-Oriented
                  Languages (MPOOL)},
  year         = 2008,
  address      = {Paphos, Cyprus},
  month        = jul,
  lrdeprojects = {Olena},
  abstract     = {Classical (unbounded) genericity in \Cxx{}03 defines the interactions between generic data types and
                  algorithms in terms of concepts. Concepts define the requirements over a type (or a parameter) by
                  expressing constraints on its methods and dependent types (typedefs). The upcoming \Cxx{}0x standard
                  will promote concepts from abstract entities (not directly enforced by the tools) to language
                  constructs, enabling compilers and tools to perform additional checks on generic constructs as well as
                  enabling new features (e.g., concept-based overloading). Most modern languages support this notion of
                  signature on generic types. However, generic types built on other types and relying on concepts to
                  both ensure type conformance and drive code specialization, restrain the interface and the
                  implementation of the newly created type: specific methods and associated types not mentioned in the
                  concept will not be part of the new type. The paradigm of concept-based genericity lacks the required
                  semantics to transform types while retaining or adapting their intrinsic capabilities. We present a
                  new form of semantically-enriched genericity allowing static generic type transformations through a
                  simple form of type introspection based on type metadata called properties. This approach relies on a
                  new Static \Cxx Object-Oriented Programming (SCOOP) paradigm, and is adapted to the creation of
                  generic and efficient libraries, especially in the field of scientific computing. Our proposal uses a
                  metaprogramming facility built into a \Cxx library called Static, and doesn't require any language
                  extension nor additional processing (preprocessor, transformation tool).},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/geraud.08.mpool.pdf},
  lrdenewsdate = {2008-05-26}
}

@incollection{geraud.2010.book,
  author       = {Thierry G\'eraud and Hugues Talbot and Marc Van Droogenbroeck},
  title        = {Algorithms for Mathematical Morphology},
  booktitle    = {Mathematical Morphology---From Theory to Applications},
  pages        = {323--353},
  publisher    = {Wiley-ISTE},
  year         = 2010,
  editor       = {Laurent Najman and Hugues Talbot},
  isbn         = {978-1-84821-215-2},
  month        = jul,
  url          = {http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1848212151.html},
  lrdekeywords = {Image},
  crossref     = {najman.2013.mathematical}
}

@phdthesis{geraud.2012.hdr,
  author      = {Thierry G\'eraud},
  title       = {Outil logiciel pour le traitement d'images: Biblioth\`eque, paradigmes, types et algorithmes},
  school      = {Universit\'e Paris-Est},
  year        = 2012,
  month       = jun,
  lrdeproject = {Olena},
  type        = {Habilitation Thesis},
  note        = {In French},
  lrdepaper   = {http://www.lrde.epita.fr/~theo/papers/geraud.2012.hdr.pdf},
  lrdeslides  = {http://www.lrde.epita.fr/~theo/slides/geraud.2012.hdr_slides.pdf}
}

@misc{geraud.2012.ipolmeeting,
  author       = {Thierry G\'eraud and Roland Levillain and Guillaume Lazzara},
  title        = {The {M}ilena Image Processing Library},
  howpublished = {{IPOL} meeting, {ENS} Cachan, France},
  month        = {June},
  year         = {2012},
  url          = {https://www.lrde.epita.fr/~theo/talks/geraud.2012.ipol_talk.pdf}
}

@misc{geraud.2018.gtgdmm,
  author       = {Thierry G\'eraud and Edwin Carlinet},
  title        = {A Modern {C++} Library for Generic and Efficient Image Processing},
  howpublished = {Journ\'ee du Groupe de Travail de G\'eom\'etrie Discrète et Morphologie Math\'ematique, Lyon, France},
  month        = {06},
  year         = {2018},
  url          = {https://www.lrde.epita.fr/~theo/talks/geraud.2018.gtgdmm_talk.pdf}
}

@article{gibbons.2007.datatype,
  title     = {Datatype-Generic Programming},
  author    = {Gibbons, Jeremy},
  journal   = {Datatype-Generic Programming: International Spring School, {SSDGP} 2006, Nottingham, {UK}, April 24-27,
               2006, Revised Lectures},
  volume    = {4719},
  pages     = {1},
  year      = {2007},
  publisher = {Springer Science \& Business Media}
}

@software{gimp.2019,
  author  = {{The GIMP Development Team}},
  title   = {GIMP},
  url     = {https://www.gimp.org},
  version = {2.10.12},
  date    = {2019-06-12}
}

@software{gnu.2021.octave,
  author  = {{GNU Project}},
  title   = {Octave},
  url     = {https://www.gnu.org/software/octave/index},
  version = {6.2.0},
  date    = {2021-02-20}
}

@article{goguen.1984.parametrized,
  author   = {Goguen, Joseph A.},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Parameterized Programming},
  year     = {1984},
  volume   = {SE-10},
  number   = {5},
  pages    = {528-543},
  abstract = {Parameterized programming is a powerful technique for the reliable reuse of software. In this technique,
              modules are parameterized over very general interfaces that describe what properties of an environment are
              required for the module to work correctly. Reusability is enhanced by the flexibility of the
              parameterization mechanism proposed here. Reliability is further enhanced by permitting interface
              requirements to include more than purely syntactic information. This paper introduces three new ideas that
              seem especially useful in supporting parameterized programming: 1) theories, which declare global
              properties of program modules and interfaces; 2) views, which connect theories with program modules in an
              elegant way; and 3) module expressions, a kind of general structured program transformation which produces
              new modules by modifying and combining existing modules. Although these ideas are illustrated with some
              simple examples in the OBJ programming language, they should also be taken as proposals for an
              Ada<sup>1</sup> library system, for adding modules to Prolog, and as considerations for future language
              design efforts. OBJ is an ultra-high level programming language, based upon rewrite rules, that
              incorporates these ideas, and many others from modern programming methodology.},
  keywords = {},
  doi      = {10.1109/TSE.1984.5010277},
  issn     = {1939-3520},
  month    = {Sep.}
}

@inproceedings{gossec.2019.pybind,
  title     = {Binding a high-performance {C}++ image processing library to {P}ython},
  author    = {Celian Gossec},
  booktitle = {Student LRDE tech reports},
  year      = {2019}
}

@software{graphicsmagick.2021,
  author  = {{GraphicsMagick Group}},
  title   = {GraphicsMagick},
  url     = {https://http://www.graphicsmagick.org},
  version = {1.3.36},
  date    = {2020-12-26}
}

@article{gregor.2006.concepts-art,
  author     = {Gregor, Douglas and J\"{a}rvi, Jaakko and Siek, Jeremy and Stroustrup, Bjarne and Dos Reis, Gabriel and
                Lumsdaine, Andrew},
  title      = {Concepts: Linguistic Support for Generic Programming in C++},
  year       = {2006},
  issue_date = {October 2006},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {41},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1167515.1167499},
  doi        = {10.1145/1167515.1167499},
  abstract   = {Generic programming has emerged as an important technique for the development of highly reusable and
                efficient software libraries. In C++, generic programming is enabled by the flexibility of templates,
                the C++ type parametrization mechanism. However, the power of templates comes with a price: generic
                (template) libraries can be more difficult to use and develop than non-template libraries and their
                misuse results in notoriously confusing error messages. As currently defined in C++98, templates are
                unconstrained, and type-checking of templates is performed late in the compilation process, i.e., after
                the use of a template has been combined with its definition. To improve the support for generic
                programming in C++, we introduce concepts to express the syntactic and semantic behavior of types and to
                constrain the type parameters in a C++ template. Using concepts, type-checking of template definitions
                is separated from their uses, thereby making templates easier to use and easier to compile. These
                improvements are achieved without limiting the flexibility of templates or decreasing their performance
                — in fact their expressive power is increased. This paper describes the language extensions supporting
                concepts, their use in the expression of the C++ Standard Template Library, and their implementation in
                the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO C++
                standard, C++0x.},
  journal    = {SIGPLAN Not.},
  month      = oct,
  pages      = {291-310},
  numpages   = {20},
  keywords   = {C++ templates, C++0x, constrained generics, parametric polymorphism, concepts, generic programming}
}

@inproceedings{gregor.2006.concepts-proc,
  author    = {Gregor, Douglas and J\"{a}rvi, Jaakko and Siek, Jeremy and Stroustrup, Bjarne and Dos Reis, Gabriel and
               Lumsdaine, Andrew},
  title     = {Concepts: Linguistic Support for Generic Programming in C++},
  year      = {2006},
  isbn      = {1595933484},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1167473.1167499},
  doi       = {10.1145/1167473.1167499},
  abstract  = {Generic programming has emerged as an important technique for the development of highly reusable and
               efficient software libraries. In C++, generic programming is enabled by the flexibility of templates,
               the C++ type parametrization mechanism. However, the power of templates comes with a price: generic
               (template) libraries can be more difficult to use and develop than non-template libraries and their
               misuse results in notoriously confusing error messages. As currently defined in C++98, templates are
               unconstrained, and type-checking of templates is performed late in the compilation process, i.e., after
               the use of a template has been combined with its definition. To improve the support for generic
               programming in C++, we introduce concepts to express the syntactic and semantic behavior of types and to
               constrain the type parameters in a C++ template. Using concepts, type-checking of template definitions
               is separated from their uses, thereby making templates easier to use and easier to compile. These
               improvements are achieved without limiting the flexibility of templates or decreasing their performance
               — in fact their expressive power is increased. This paper describes the language extensions supporting
               concepts, their use in the expression of the C++ Standard Template Library, and their implementation in
               the ConceptGCC compiler. Concepts are candidates for inclusion in the upcoming revision of the ISO C++
               standard, C++0x.},
  booktitle = {Proceedings of the 21st Annual ACM SIGPLAN Conference on Object-Oriented Programming Systems, Languages,
               and Applications},
  pages     = {291–310},
  numpages  = {20},
  keywords  = {concepts, parametric polymorphism, C++ templates, constrained generics, C++0x, generic programming},
  location  = {Portland, Oregon, USA},
  series    = {OOPSLA '06}
}

@article{guelton.2015.pythran,
  title     = {{P}ythran: Enabling static optimization of scientific python programs},
  author    = {Guelton, Serge and Brunet, Pierrick and Amini, Mehdi and Merlini, Adrien and Corbillon, Xavier and
               Raynaud, Alan},
  journal   = {Computational Science \& Discovery},
  volume    = {8},
  number    = {1},
  pages     = {014001},
  year      = {2015},
  publisher = {IOP Publishing}
}

@misc{guennebaud.2010.eigen,
  author       = {Ga\"{e}l Guennebaud and Beno\^{i}t Jacob and others},
  title        = {Eigen v3},
  year         = {2010},
  howpublished = {http://eigen.tuxfamily.org},
  note         = {Available at \url{http://eigen.tuxfamily.org}}
}

@book{gulli.2017.deep,
  title     = {Deep learning with Keras},
  author    = {Gulli, Antonio and Pal, Sujit},
  year      = {2017},
  publisher = {Packt Publishing Ltd}
}

@inproceedings{hanus.1995.curry,
  author    = {Michael Hanus and Herbert Kuchen and Juan Jose Moreno-Navarro},
  title     = {Curry: A Truly Functional Logic Language},
  year      = {1995},
  booktitle = {Proc. ILPS'95 Workshop on Visions for the Future of Logic Programming},
  pages     = {95-107},
  volume    = {95},
  abstract  = {Functional and logic programming are the most important declarative programming paradigms, and interest
               in combining them has grown over the last decade. However, integrated functional logic languages are
               currently not widely used. This is due to the fact that the operational principles are not well
               understood and many different evaluation strategies have been proposed which resulted in many different
               functional logic languages. To overcome this situation, we propose the functional logic language Curry
               which is intended to become a standard language in this area. It includes important ideas of existing
               functional logic languages and recent developments, and combines the most important features of
               functional and logic languages. Thus, Curry can be the basis to combine the currently separated research
               efforts of the functional and logic programming communities and to boost declarative programming in
               general. Moreover, since functions provide for more efficient evaluation strategies and are a
               declarative replacement of some impure features of Prolog (in particular, pruning operators), Curry can
               be also used as a declarative successor of Prolog.}
}

@article{haralick.1977.imageaccessprotocol,
  author   = {R. M. {Haralick}},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Image Access Protocol for Image Processing Software},
  year     = {1977},
  volume   = {SE-3},
  number   = {2},
  pages    = {190-192},
  abstract = {During the past decade a number of multiimage picture processing software packages have been put together.
              However, only a few of the references to picture processing systems discuss image data structure or
              input/output routines. This correspondence is a first step in a direction toward getting a communication
              process started by suggesting some specifications for a multiimage data format and standard input/output
              interface routines to access the image data.},
  keywords = {Digital image processing; image processing; software; Access protocols; Image processing;
              Image segmentation; Data structures; Spatial resolution; Software packages; Communication standards;
              Laboratories; Image resolution; Electromagnetic launching; Digital image processing; image processing;
              software},
  doi      = {10.1109/TSE.1977.231124},
  issn     = {2326-3881},
  month    = {March}
}


@article{hoare.1969.axiomatic,
  author     = {Hoare, C. A. R.},
  title      = {An Axiomatic Basis for Computer Programming},
  year       = {1969},
  issue_date = {Oct. 1969},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {12},
  number     = {10},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/363235.363259},
  doi        = {10.1145/363235.363259},
  abstract   = {In this paper an attempt is made to explore the logical foundations of computer programming by use of
                techniques which were first applied in the study of geometry and have later been extended to other
                branches of mathematics. This involves the elucidation of sets of axioms and rules of inference which
                can be used in proofs of the properties of computer programs. Examples are given of such axioms and
                rules, and a formal proof of a simple theorem is displayed. Finally, it is argued that important
                advantage, both theoretical and practical, may follow from a pursuance of these topics.},
  journal    = {Commun. ACM},
  month      = oct,
  pages      = {576–-580},
  numpages   = {5},
  keywords   = {program documentation, formal language definition, programming language design,
                machine-independent programming, theory of programming' proofs of programs, axiomatic method}
}

@misc{howard.2017.mobilenets,
  title         = {MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications},
  author        = {Andrew G. Howard and Menglong Zhu and Bo Chen and Dmitry Kalenichenko and Weijun Wang and
                   Tobias Weyand and Marco Andreetto and Hartwig Adam},
  year          = {2017},
  eprint        = {1704.04861},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CV}
}

@manual{ibanez.2003.ITKSoftwareGuide,
  title        = {The {ITK} {S}oftware {G}uide},
  author       = {Ibanez, L. and Schroeder, W. and Ng, L. and Cates, J.},
  organization = {Kitware, Inc.},
  edition      = {First},
  year         = {2003},
  note         = {ISBN 1-930934-10-6},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf}
}

@manual{ibanez.2005.ITKSoftwareGuideSecondEdition,
  title        = {The {ITK} {S}oftware {G}uide},
  author       = {Ibanez, L. and Schroeder, W. and Ng, L. and Cates, J.},
  organization = {Kitware, Inc.},
  edition      = {Second},
  year         = {2005},
  note         = {ISBN 1-930934-15-7},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf}
}

@article{iglberger.2012_1.blaze,
  author  = {Klaus {Iglberger} and Georg {Hager} and Jan {Treibig} and Ulrich {R{\"u}de}},
  title   = {Expression Templates Revisited: A Performance Analysis of Current Methodologies},
  journal = {SIAM Journal on Scientific Computing},
  year    = {2012},
  volume  = {34(2)},
  pages   = {C42--C69}
}

@misc{iglberger.2012.blaze,
  author       = {Klaus {Iglberger}},
  title        = {Blaze C++ Linear Algebra Library},
  howpublished = {https://bitbucket.org/blaze-lib},
  year         = {2012}
}

@inproceedings{iglberger2012_2.blaze,
  author    = {Klaus {Iglberger} and Georg {Hager} and Jan {Treibig} and Ulrich {R{\"u}de}},
  title     = {High Performance Smart Expression Template Math Libraries},
  booktitle = {Proceedings of the 2nd International Workshop on New Algorithms and Programming Models for the Manycore
               Era (APMM 2012) at HPCS 2012},
  year      = 2012
}

@software{imagemagick.2021,
  author  = {{The ImageMagick Development Team}},
  title   = {ImageMagick},
  url     = {https://imagemagick.org},
  version = {7.0.10},
  date    = {2021-01-04}
}

@software{intel-llvm.2021.sycl,
  author  = {Intel Corporation},
  title   = {SYCL Compiler and Runtimes},
  url     = {https://github.com/intel/llvm},
  version = {master}
}

@book{iso.1987.ada,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {333},
  month     = {06},
  year      = {1987},
  url       = {https://www.iso.org/standard/16028.html}
}

@book{iso.1995.ada,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {511},
  month     = {02},
  year      = {1995},
  url       = {https://www.iso.org/standard/22983.html}
}

@book{iso.1995.ada.amend,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Amendment 1},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {317},
  month     = {03},
  year      = {2007},
  url       = {https://www.iso.org/standard/45001.html}
}

@book{iso.1995.ada.corr,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Technical Corrigendum 1},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {56},
  month     = {06},
  year      = {2001},
  url       = {https://www.iso.org/standard/35451.html}
}

@book{iso.1998.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2003}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {732},
  month     = {09},
  year      = {1998},
  url       = {https://www.iso.org/standard/25845.html}
}

@book{iso.2003.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2003}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {757},
  month     = {10},
  year      = {2003},
  url       = {https://www.iso.org/standard/38110.html}
}

@book{iso.2011.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2011}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1338},
  month     = {09},
  year      = {2011},
  url       = {https://www.iso.org/standard/50372.html}
}

@book{iso.2012.ada,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {832},
  month     = {12},
  year      = {2012},
  url       = {https://www.iso.org/standard/61507.html}
}

@book{iso.2012.ada.corr,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Technical Corrigendum 1},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {75},
  month     = {02},
  year      = {2016},
  url       = {https://www.iso.org/standard/69798.html}
}

@book{iso.2014.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2014}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1358},
  month     = {12},
  year      = {2014},
  url       = {https://www.iso.org/standard/64029.html}
}

@book{iso.2017.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2017}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1605},
  month     = {12},
  year      = {2017},
  url       = {https://www.iso.org/standard/68564.html}
}

@book{iso.2020.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2020}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1853},
  month     = {12},
  year      = {2020},
  url       = {https://www.iso.org/standard/79358.html}
}

@inbook{iverson.2007.notation,
  author    = {Iverson, Kenneth E.},
  title     = {Notation as a Tool of Thought},
  year      = {2007},
  isbn      = {9781450310499},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1283920.1283935},
  booktitle = {ACM Turing Award Lectures},
  pages     = {1979}
}

@misc{jakob.2017.pybind11,
  title  = {pybind11—Seamless operability between C++ 11 and Python},
  author = {Jakob, Wenzel and Rhinelander, Jason and Moldovan, Dean},
  year   = {2017},
  note   = {https://github.com/pybind/pybind11}
}

@inproceedings{jarvi.2006.specialization,
  author    = {J\"{a}rvi, Jaakko and Gregor, Douglas and Willcock, Jeremiah and Lumsdaine, Andrew and Siek, Jeremy},
  title     = {Algorithm Specialization in Generic Programming: Challenges of Constrained Generics in C++},
  booktitle = {Proceedings of the 27th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  series    = {PLDI '06},
  year      = {2006},
  isbn      = {1-59593-320-4},
  location  = {Ottawa, Ontario, Canada},
  pages     = {272--282},
  numpages  = {11},
  url       = {http://doi.acm.org/10.1145/1133981.1134014},
  doi       = {10.1145/1133981.1134014},
  acmid     = {1134014},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {concepts, constrained generics, generic programming, parametric polymorphism, specialization}
}

@article{jarvi.2006.specialization-article,
  author     = {J\"{a}rvi, Jaakko and Gregor, Douglas and Willcock, Jeremiah and Lumsdaine, Andrew and Siek, Jeremy},
  title      = {Algorithm Specialization in Generic Programming: Challenges of Constrained Generics in C++},
  journal    = {SIGPLAN Not.},
  issue_date = {June 2006},
  volume     = {41},
  number     = {6},
  month      = jun,
  year       = {2006},
  issn       = {0362-1340},
  pages      = {272--282},
  numpages   = {11},
  url        = {http://doi.acm.org/10.1145/1133255.1134014},
  doi        = {10.1145/1133255.1134014},
  acmid      = {1134014},
  publisher  = {ACM},
  address    = {New York, NY, USA},
  keywords   = {concepts, constrained generics, generic programming, parametric polymorphism, specialization}
}

@manual{johnson.2013.ITKSoftwareGuideThirdEdition,
  title        = {The {ITK} {S}oftware {G}uide},
  author       = {Johnson, Hans J. and McCormick, M. and Ib{\'a}{\~n}ez, L. and The Insight Software Consortium},
  organization = {Kitware, Inc.},
  edition      = {Third},
  year         = {2013},
  note         = {\textit{In press}},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf}
}

@manual{johnson.2015.itkvol1,
  author    = {Johnson, Hans J and McCormick, Matthew M and Ibanez, Luis},
  publisher = {Kitware, Inc.},
  title     = {Template:The ITK Software Guide Book 1: Introduction and Development Guidelines-Volume 1},
  year      = {2015}
}

@manual{johnson.2015.itkvol2,
  author    = {Johnson, Hans J and McCormick, Matthew M and Ibanez, Luis},
  publisher = {Kitware, Inc.},
  title     = {Template:The ITK Software Guide Book 2: Design and Functionality-Volume 2},
  year      = {2015}
}

@misc{jones.2006.scipy,
  author = {Eric Jones and Travis Oliphant and Pearu Peterson and others},
  title  = {{SciPy}: Open source scientific tools for {Python}},
  year   = {2001},
  url    = {http://www.scipy.org/}
}

@inproceedings{kapur.1982.tecton,
  author    = {Kapur, Deepak and Musser, David R. and Stepanov, Alexander A.},
  editor    = {Staunstrup, J{\o}rgen},
  title     = {Tecton: A language for manipulating generic objects},
  booktitle = {Program Specification},
  year      = {1982},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {402--414},
  isbn      = {978-3-540-39176-0}
}

@proceedings{kerautret.2018.rrprconf,
  editor    = {Bertrand Kerautret and Miguel Colom and Daniel Lopresti and Pascal Monasse and Hugues Talbot},
  title     = {Reproducible Research in Pattern Recognition — Second International Workshop, {RRPR} 2018, Beijing,
               China, August 20, 2018, Revised Selected Papers},
  series    = {Lecture Notes in Computer Science},
  volume    = {11455},
  publisher = {Springer},
  year      = {2019}
}

@inproceedings{kluyver.2016.jupyter,
  booktitle = {Positioning and Power in Academic Publishing: Players, Agents and Agendas},
  editor    = {Fernando Loizides and Birgit Scmidt},
  title     = {Jupyter Notebooks — a publishing format for reproducible computational workflows},
  author    = {Thomas Kluyver and Benjamin Ragan-Kelley and Fernando P{\'e}rez and Brian Granger and Matthias Bussonnier
               and Jonathan Frederic and Kyle Kelley and Jessica Hamrick and Jason Grout and Sylvain Corlay and Paul
               Ivanov and Dami{\'a}n Avila and Safia Abdalla and Carol Willing and  Jupyter development team},
  publisher = {IOS Press},
  address   = {Netherlands},
  year      = {2016},
  pages     = {87--90},
  url       = {https://eprints.soton.ac.uk/403913/},
  abstract  = {It is increasingly necessary for researchers in all fields to write computer code, and in order to
               reproduce research results, it is important that this code is published. We present Jupyter notebooks, a
               document format for publishing code, results and explanations in a form that is both readable and
               executable. We discuss various tools and use cases for notebook documents.}
}

@book{knuth.2014.art,
  title     = {Art of computer programming, volume 2: Seminumerical algorithms},
  author    = {Knuth, Donald E},
  year      = {2014},
  publisher = {Addison-Wesley Professional}
}

@misc{kobalicek.2011.asmjit,
  title  = {asmjit-complete x86/x64 {JIT} assembler for {C}++ language},
  author = {Kobalicek, P},
  year   = {2011}
}

@misc{kolas.2000.gegl,
  title  = {{G}eneric {G}raphic {L}ibrary},
  year   = {2000},
  author = {Kol{\r{a}}s, {\O}yvind and et al.},
  note   = {Available at \url{http://www.gegl.org}}
}

@article{kothe.2011.generic,
  author  = {Ullrich K{\"o}the},
  title   = {{STL}-Style Generic Programming with Images},
  journal = {C++ Report Magazine},
  year    = {2000},
  volume  = {12},
  number  = {1},
  pages   = {24--30},
  note    = {{\small\url{https://ukoethe.github.io/vigra}}}
}

@misc{kothe.2011.generic.INTROUVABLE,
  title  = {Generic programming for computer vision: The vigra computer vision library},
  author = {K{\"o}the, Ullrich},
  year   = {2011}
}

@software{lemire.2021.simdjson,
  author  = {Daniel Lemire and Geoff Langdale and John Keiser},
  title   = {simdjson},
  url     = {https://github.com/simdjson/simdjson},
  version = {1.0},
  date    = {2021-09-08}
}

@inproceedings{levillain.2009.ismm,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {{Milena}: Write Generic Morphological Algorithms Once, Run on Many Kinds of Images},
  booktitle    = {Mathematical Morphology and Its Application to Signal and Image Processing — Proceedings of the Ninth
                  International Symposium on Mathematical Morphology (ISMM)},
  pages        = {295--306},
  year         = 2009,
  editor       = {Michael H. F. Wilkinson and Jos B. T. M. Roerdink},
  series       = {Lecture Notes in Computer Science},
  address      = {Groningen, The Netherlands},
  month        = aug,
  publisher    = {Springer Berlin / Heidelberg},
  volume       = 5720,
  lrdeprojects = {Olena},
  abstract     = {We present a programming framework for discrete mathematical morphology centered on the concept of
                  genericity. We show that formal definitions of morphological algorithms can be translated into actual
                  code, usable on virtually any kind of compatible images, provided a general definition of the concept
                  of image is given. This work is implemented in Milena, a generic, efficient, and user-friendly image
                  processing library.},
  keywords     = {mathematical morphology, image processing operator, genericity, programming},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.09.ismm.slides.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.09.ismm.pdf},
  lrdenewsdate = {2009-04-09}
}

@inproceedings{levillain.2010.icip,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Why and How to Design a Generic and Efficient Image Processing Framework: The Case of the {Milena}
                  Library},
  booktitle    = {Proceedings of the IEEE International Conference on Image Processing (ICIP)},
  pages        = {1941--1944},
  year         = 2010,
  address      = {Hong Kong},
  month        = sep,
  lrdeprojects = {Olena},
  abstract     = {Most image processing frameworks are not generic enough to provide true reusability of data structures
                  and algorithms. In fact, genericity allows users to write and experiment virtually any method on any
                  compatible input(s). In this paper, we advocate the use of generic programming in the design of image
                  processing software, while preserving performances close to dedicated code. The implementation of our
                  proposal, Milena, a generic and efficient library, illustrates the benefits of our approach.},
  keywords     = {Genericity, Image Processing, Software Design, Reusability, Efficiency},
  lrdeposter   = {http://www.lrde.epita.fr/dload/papers/levillain.10.icip.poster.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.10.icip.pdf},
  lrdenewsdate = {2010-05-26}
}

@inproceedings{levillain.2010.wadgmm,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Writing Reusable Digital Geometry Algorithms in a Generic Image Processing Framework},
  booktitle    = {Proceedings of the Workshop on Applications of Digital Geometry and Mathematical Morphology (WADGMM)},
  pages        = {96--100},
  year         = 2010,
  address      = {Istanbul, Turkey},
  month        = aug,
  url          = {http://mdigest.jrc.ec.europa.eu/wadgmm2010/},
  lrdeprojects = {Olena},
  abstract     = {Digital Geometry software should reflect the generality of the underlying mathematics: mapping the
                  latter to the former requires genericity. By designing generic solutions, one can effectively reuse
                  digital geometry data structures and algorithms. We propose an image processing framework centered on
                  the Generic Programming paradigm in which an algorithm on the paper can be turn into a single code,
                  written once and usable with various input types. This approach enables users to design and implement
                  new methods at a lower cost, try cross-domain experiments and help generalize results.},
  keywords     = {Generic Programming, Interface, Skeleton, Complex},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.10.wadgmm.slides.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.10.wadgmm.pdf},
  lrdenewsdate = {2012-07-30}
}

@inproceedings{levillain.2011.gretsi,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Une approche g\'en\'erique du logiciel pour le traitement d'images pr\'eservant les performances},
  booktitle    = {Proceedings of the 23rd Symposium on Signal and Image Processing (GRETSI)},
  category     = {national},
  year         = 2011,
  address      = {Bordeaux, France},
  month        = sep,
  note         = {In French.},
  lrdeprojects = {Olena},
  abstract     = {De plus en plus d'outils logiciels modernes pour le traitement d'images sont con\c{c}us en prenant en
                  compte le probl\`eme de la g\'en\'ericit\'e du code, c'est-\`a-dire la possibilit\'e d'\'ecrire des
                  algorithmes r\'eutilisables, compatibles avec de nombreux types d'entr\'ees. Cependant, ce choix de
                  conception se fait souvent au d\'etriment des performances du code ex\'ecut\'e. Du fait de la grande
                  vari\'et\'e des types d'images existants et de la n\'ecessit\'e d'avoir des impl\'ementations rapides,
                  g\'en\'ericit\'e et performance apparaissent comme des qualit\'es essentielles du logiciel en
                  traitement d'images. Cet article pr\'esente une approche pr\'eservant les performances dans un
                  framework logiciel g\'en\'erique tirant parti des caract\'eristiques des types de donn\'ees
                  utilis\'es. Gr\^ace \`a celles-ci, il est possible d'\'ecrire des variantes d'algorithmes
                  g\'en\'eriques offrant un compromis entre g\'en\'ericit\'e et performance. Ces alternatives sont
                  capables de pr\'eserver une partie des aspects g\'en\'eriques d'origine tout en apportant des gains
                  substantiels \`a l'ex\'ecution. D'apr\`es nos essais, ces optimisations g\'en\'eriques fournissent des
                  performances supportant la comparaison avec du code d\'edi\'e, allant parfois m\^eme jusqu'\`a
                  surpasser des routines optimis\'ees manuellement.},
  lrdeposter   = {http://www.lrde.epita.fr/dload/papers/levillain.11.gretsi.poster.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.11.gretsi.pdf},
  lrdenewsdate = {2011-05-13}
}

@phdthesis{levillain.2011.phd,
  author       = {Roland Levillain},
  title        = {Towards a Software Architecture for Generic Image Processing},
  school       = {Universit\'e Paris-Est},
  year         = 2011,
  address      = {Marne-la-Vall\'ee, France},
  month        = nov,
  abstract     = {In the context of software engineering for image processing (IP), we consider the notion of
                  reusability of algorithms. In many software tools, an algorithm's implementation often depends on the
                  type of processed data. In a broad definition, discrete digital images may have various forms —
                  classical 2D images, 3D volumes, non-regular graphs, cell complexes, and so on — thus leading to a
                  combinatorial explosion of the theoretical number of implementations. Generic programming (GP) is a
                  framework suited to the development of reusable software tools. We present a programming paradigm
                  based on GP designed for the creation of scientific software such as IP tools. This approach combines
                  the benefits of reusability, expressive power, extensibility, and efficiency. We then propose a
                  software architecture for IP using this programming paradigm based on a generic IP library. The
                  foundations of this framework define essential IP concepts, enabling the development of algorithms
                  compatible with many image types. We finally present a strategy to build high-level tools on top of
                  this library, such as bridges to dynamic languages or graphical user interfaces. This mechanism has
                  been designed to preserve the genericity and efficiency of the underlying software tools, while making
                  them simpler to use and more flexible.},
  lrdepaper    = {http://www.lrde.epita.fr/~roland/phd/levillain-phd.pdf},
  lrdeprojects = {Olena}
}

@inproceedings{levillain.2012.wadgmm-lncs,
  oldkeys      = {levillain.12.lncs},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Writing Reusable Digital Topology Algorithms in a Generic Image Processing Framework},
  booktitle    = {WADGMM 2010},
  pages        = {140--153},
  year         = 2012,
  editor       = {Ullrich K\"othe and Annick Montanvert and Pierre Soille},
  publisher    = {Springer-Verlag Berlin Heidelberg},
  series       = {Lecture Notes in Computer Science},
  volume       = 7346,
  lrdeprojects = {Olena},
  abstract     = {Digital Topology software should reflect the generality of the underlying mathematics: mapping the
                  latter to the former requires genericity. By designing generic solutions, one can effectively reuse
                  digital topology data structures and algorithms. We propose an image processing framework focused on
                  the Generic Programming paradigm in which an algorithm on the paper can be turned into a single code,
                  written once and usable with various input types. This approach enables users to design and implement
                  new methods at a lower cost, try cross-domain experiments and help generalize results.},
  keywords     = {Generic Programming, Interface, Skeleton, Complex},
  annote       = {This paper is an extended version of levillain.10.wadgmm (201008-WADGMM).},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.12.wadgmm-lncs.pdf},
  lrdenewsdate = {2012-08-08}
}

@inproceedings{levillain.2014.ciarp,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman and Edwin Carlinet},
  title        = {Practical Genericity: Writing Image Processing Algorithms Both Reusable and Efficient},
  booktitle    = {Progress in Pattern Recognition, Image Analysis, Computer Vision, and Applications — Proceedings of
                  the 19th Iberoamerican Congress on Pattern Recognition (CIARP)},
  address      = {Puerto Vallarta, Mexico},
  month        = nov,
  year         = {2014},
  pages        = {70--79},
  editor       = {Eduardo Bayro and Edwin Hancock},
  publisher    = {Springer-Verlag},
  series       = {Lecture Notes in Computer Science},
  volume       = {8827},
  lrdeprojects = {Olena},
  abstract     = {An important topic for the image processing and pattern recognition community is the construction of
                  open source and efficient libraries. An increasing number of software frameworks are said to be
                  generic: they allow users to write reusable algorithms compatible with many input image types.
                  However, this design choice is often made at the expense of performance. We present an approach to
                  preserve efficiency in a generic image processing framework, by leveraging data types features.
                  Variants of generic algorithms taking advantage of image types properties can be defined, offering an
                  adjustable trade-off between genericity and efficiency. Our experiments show that these generic
                  optimizations can match dedicated code in terms of execution times, and even sometimes perform better
                  than routines optimized by hand. Digital Topology software should reflect the generality of the
                  underlying mathematics: mapping the latter to the former requires genericity. By designing generic
                  solutions, one can effectively reuse digital topology data structures and algorithms. We propose an
                  image processing framework focused on the Generic Programming paradigm in which an algorithm on the
                  paper can be turned into a single code, written once and usable with various input types. This
                  approach enables users to design and implement new methods at a lower cost, try cross-domain
                  experiments and help generalize results.},
  keywords     = {Generic Programming, Image Processing, Performance, Olena},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.14.ciarp.pdf},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.14.ciarp.slides.pdf},
  lrdenewsdate = {2014-09-10}
}

@article{liskov.1993.cluart,
  author     = {Liskov, Barbara},
  title      = {A History of CLU},
  year       = {1993},
  issue_date = {March 1993},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {3},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/155360.155367},
  doi        = {10.1145/155360.155367},
  abstract   = {The idea of a data abstraction has had a significant impact on the development of programming languages 
                and on programming methodology. CLU was the first implemented programming language to provide direct
                linguistic support for data abstraction. This paper provides a history of data abstraction and CLU. CLU
                contains a number of other interesting and influential features, including its exception handling
                mechanism, its iterators, and its parameterized types.},
  journal    = {SIGPLAN Not.},
  month      = mar,
  pages      = {133-147},
  numpages   = {15}
}

@inproceedings{liskov.1993.cluproc,
  author    = {Liskov, Barbara},
  title     = {A History of CLU},
  year      = {1993},
  isbn      = {0897915704},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/154766.155367},
  doi       = {10.1145/154766.155367},
  abstract  = {The idea of a data abstraction has had a significant impact on the development of programming languages
               and on programming methodology. CLU was the first implemented programming language to provide direct
               linguistic support for data abstraction. This paper provides a history of data abstraction and CLU. CLU
               contains a number of other interesting and influential features, including its exception handling
               mechanism, its iterators, and its parameterized types.},
  booktitle = {The Second ACM SIGPLAN Conference on History of Programming Languages},
  pages     = {133-147},
  numpages  = {15},
  location  = {Cambridge, Massachusetts, USA},
  series    = {HOPL-II}
}

@article{liu.2019.sunwayimg,
  author   = {R. {Liu} and Y. {Liu} and M. {Zhao} and K. {Song} and D. {Qian}},
  journal  = {IEEE Access},
  title    = {SunwayImg: A Parallel Image Processing Library for the Sunway Many-Core Processor},
  year     = {2019},
  volume   = {7},
  number   = {},
  pages    = {128555-128569},
  abstract = {Many big data applications need to process massive images and videos, while the performance of image
              processing is far from reaching requirements. This paper proposes the SunwayImg, a parallel image
              processing library, to support image-related applications on the Sunway many-core processor as well as the
              Sunway TaihuLight supercomputer. The SunwayImg integrates three kinds of image algorithms: fundamental
              algorithms to support basic image operations on the Sunway processor, widely used image feature extraction
              algorithms and a typical neural network model DBN. In addition, to parallelize various kinds of image
              algorithms efficiently on the Sunway processor, we propose a three-tier parallelization strategy as well
              as fine-grained parallelization inside core-groups. Finally, we accomplish implementation of the SunwayImg
              and evaluate it on the Sunway TaihuLight supercomputer to verify its effectiveness and performance.},
  keywords = {Big Data; feature extraction; image processing; multiprocessing systems; neural nets; parallel machines;
              image feature extraction algorithms; three-tier parallelization strategy; fine-grained parallelization;
              SunwayImg; Sunway TaihuLight supercomputer; parallel image processing library; Sunway many-core processor;
              big data applications; image-related applications; image operations; neural network model; Libraries;
              Computer architecture; Feature extraction; Supercomputers; Software; Neural networks; Image library;
              high performance computing; parallel computing; deep neural networks},
  doi      = {10.1109/ACCESS.2019.2939940},
  issn     = {2169-3536},
  month    = {}
}

@software{mathworks.2020.matlab,
  author  = {{MathWorks}},
  title   = {MATLAB},
  url     = {https://fr.mathworks.com/products/matlab.html},
  version = {R2020b},
  date    = {2020-09-22}
}

@inproceedings{matuska.2012.bench,
  author    = {S. {Matuska} and R. {Hudec} and M. {Benco}},
  booktitle = {2012 ELEKTRO},
  title     = {The comparison of CPU time consumption for image processing
               algorithm in Matlab and OpenCV},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {75-78},
  abstract  = {In order to fill gap of growing demand for high efficient image and video processing, open source
               computer vision library (OpenCv) is way to deals with this task. Hence, this paper is about basic
               algorithm for image processing and their CPU time consumption in Matlab comparing with OpenCv.
               Algorithms are tested on images with resolution 3264×2448, 1920×1080, 1024×768 and 220×260.
               Multi-processors computer and multi-threading programs are used to improve processing efficiency.},
  keywords  = {image processing; mathematics computing; microprocessor chips; multi-threading; CPU time consumption;
               image processing algorithm; Matlab; OpenCV; video processing; open source computer vision library;
               multi-processors computer; multi-threading programs; Application software; Instruction sets; Kernel;
               Image edge detection; Smoothing methods; Computer vision; OpenCV; Matlab; computer vision;
               mutli-threading},
  doi       = {10.1109/ELEKTRO.2012.6225575},
  issn      = {null},
  month     = {05}
}

@article{meyer.1992.design,
  author   = {Meyer, B.},
  journal  = {Computer},
  title    = {Applying 'design by contract'},
  year     = {1992},
  volume   = {25},
  number   = {10},
  pages    = {40-51},
  abstract = {Methodological guidelines for object-oriented software construction that improve the reliability of the
              resulting software systems are presented. It is shown that the object-oriented techniques rely on the
              theory of design by contract, which underlies the design of the Eiffel analysis, design, and programming
              language and of the supporting libraries, from which a number of examples are drawn. The theory of
              contract design and the role of assertions in that theory are discussed.&lt;<ETX>&gt;</ETX>},
  keywords = {},
  doi      = {10.1109/2.161279},
  issn     = {1558-0814},
  month    = {Oct}
}

@inproceedings{meyer.2009.ismm,
  title     = {Morphology on graphs and minimum spanning trees},
  author    = {Fernand Meyer and Jean Stawiaski},
  booktitle = {Proc. of the Intl. Symp. on Mathematical Morphology (ISMM)},
  pages     = {161--170},
  year      = {2009},
  publisher = {Springer},
  series    = {LNCS},
  volume    = {5720}
}

@article{moisan.2005.modeling,
  title   = {Modeling and image processing},
  author  = {Moisan, Lionel},
  journal = {Lecture Notes of ENS Cachan edition},
  year    = {2005}
}

@book{moore.2017.matlab,
  title     = {MATLAB for Engineers},
  author    = {Moore, Holly},
  year      = {2017},
  publisher = {Pearson}
}

@inproceedings{musser.1987.ada,
  author    = {Musser, David R. and Stepanov, Alexander A.},
  title     = {A Library of Generic Algorithms in Ada},
  year      = {1987},
  isbn      = {0897912438},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/317500.317529},
  doi       = {10.1145/317500.317529},
  abstract  = {It is well-known that data abstractions are crucial to good software engineering practice. We argue that
               algorithmic abstractions, or generic algorithms, are perhaps even more important for software
               reusability. Generic algorithms are parameterized procedural schemata that are completely independent of
               the underlying data representation and are derived from concrete, efficient algorithms. We discuss this
               notion with illustrations from the structure of an Ada library of reusable software components we are
               presently developing.},
  booktitle = {Proceedings of the 1987 Annual ACM SIGAda International Conference on Ada},
  pages     = {216-225},
  numpages  = {10},
  location  = {Boston, Massachusetts, USA},
  series    = {SIGAda '87}
}

@inproceedings{musser.1988.generic,
  title        = {Generic programming},
  author       = {David R. Musser and Alexander A. Stepanov},
  booktitle    = {Intl. Symp. on Symbolic and Algebraic Computation},
  pages        = {13--25},
  year         = {1988},
  organization = {Springer}
}

@book{musser.1989.ada,
  title     = {The Ada Generic Library linear list processing packages},
  author    = {Musser, David R and Stepanov, Alexander A},
  year      = {1989},
  publisher = {Springer-Verlag}
}

@article{musser.1994.algorithm,
  author   = {Musser, David R. and Stepanov, Alexander A.},
  title    = {Algorithm-oriented generic libraries},
  journal  = {Software: Practice and Experience},
  volume   = {24},
  number   = {7},
  pages    = {623-642},
  keywords = {Generic algorithms, Algorithmic abstractions, Software libraries, Abstract data types, C+ +, Templates},
  doi      = {10.1002/spe.4380240703},
  url      = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380240703},
  eprint   = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380240703},
  abstract = {We outline an approach to construction of software libraries in which generic algorithms (algorithmic
              abstractions) play a more central role than in conventional software library technology or in the
              object-oriented programming paradigm. Our approach is to consider algorithms first, decide what types and
              access operations they need for efficient execution, and regard the types and operations as formal
              parameters that can be instantiated in many different ways, as long as the actual parameters satisfy the
              assumptions on which the correctness and efficiency of the algorithms are based. The means by which
              instantiation is carried out is language dependent; in the C++ examples in this paper, we instantiate
              generic algorithms by constructing classes that define the needed types and access operations. By use of
              such compile-time techniques and careful attention to algorithmic issues, it is possible to construct
              software components of broad utility with no sacrifice of efficiency.},
  year     = {1994}
}
@book{musser.2012.ada,
  title     = {The Ada{\textregistered} generic library: linear list processing packages},
  author    = {Musser, David R and Stepanov, Alexander A},
  year      = {2012},
  publisher = {Springer Science \& Business Media}
}

@article{mytkowicz.2009.sigplan-art,
  author     = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
  title      = {Producing Wrong Data without Doing Anything Obviously Wrong!},
  year       = {2009},
  issue_date = {March 2009},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {44},
  number     = {3},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1508284.1508275},
  doi        = {10.1145/1508284.1508275},
  abstract   = {This paper presents a surprising result: changing a seemingly innocuous aspect of an experimental setup
                can cause a system researcher to draw wrong conclusions from an experiment. What appears to be an
                innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation.
                This phenomenon is called measurement bias in the natural and social sciences.Our results demonstrate
                that measurement bias is significant and commonplace in computer system evaluation. By significant we
                mean that measurement bias can lead to a performance analysis that either over-states an effect or even
                yields an incorrect conclusion. By common place we mean that measurement bias occurs in all
                architectures that we tried (Pentium 4, Core 2, and m5 O3CPU), both compilers that we tried (gcc and
                Intel's C compiler), and most of the SPEC CPU2006 C programs. Thus, we cannot ignore measurement bias.
                Nevertheless, in a literature survey of 133 recent papers from ASPLOS, PACT, PLDI, and CGO, we
                determined that none of the papers with experimental results adequately consider measurement bias.
                Inspired by similar problems and their solutions in other sciences, we describe and demonstrate two
                methods, one for detecting (causal analysis) and one for avoiding (setup randomization) measurement
                bias.},
  journal    = {SIGPLAN Not.},
  month      = mar,
  pages      = {265-276},
  numpages   = {12},
  keywords   = {bias, performance, measurement}
}

@inproceedings{mytkowicz.2009.sigplan-proc,
  author    = {Mytkowicz, Todd and Diwan, Amer and Hauswirth, Matthias and Sweeney, Peter F.},
  title     = {Producing Wrong Data without Doing Anything Obviously Wrong!},
  year      = {2009},
  isbn      = {9781605584065},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1508244.1508275},
  doi       = {10.1145/1508244.1508275},
  abstract  = {This paper presents a surprising result: changing a seemingly innocuous aspect of an experimental setup
               can cause a system researcher to draw wrong conclusions from an experiment. What appears to be an
               innocuous aspect in the experimental setup may in fact introduce a significant bias in an evaluation.
               This phenomenon is called measurement bias in the natural and social sciences.Our results demonstrate
               that measurement bias is significant and commonplace in computer system evaluation. By significant we
               mean that measurement bias can lead to a performance analysis that either over-states an effect or even
               yields an incorrect conclusion. By common place we mean that measurement bias occurs in all
               architectures that we tried (Pentium 4, Core 2, and m5 O3CPU), both compilers that we tried (gcc and
               Intel's C compiler), and most of the SPEC CPU2006 C programs. Thus, we cannot ignore measurement bias.
               Nevertheless, in a literature survey of 133 recent papers from ASPLOS, PACT, PLDI, and CGO, we
               determined that none of the papers with experimental results adequately consider measurement bias.
               Inspired by similar problems and their solutions in other sciences, we describe and demonstrate two
               methods, one for detecting (causal analysis) and one for avoiding (setup randomization) measurement
               bias.},
  journal   = {SIGPLAN Not.},
  booktitle = {Proceedings of the 14th International Conference on Architectural Support for Programming Languages and
               Operating Systems},
  pages     = {265-276},
  numpages  = {12},
  keywords  = {measurement, bias, performance},
  location  = {Washington, DC, USA},
  series    = {ASPLOS XIV}
}

@book{najman.2013.mathematical,
  title     = {Mathematical Morphology: From Theory to Applications},
  author    = {Najman, L. and Talbot, H.},
  isbn      = {9781118600856},
  series    = {ISTE},
  url       = {https://books.google.fr/books?id=9FUlX8YrRvMC},
  year      = {2013},
  publisher = {Wiley}
}

@misc{niebler.2014.ranges,
  title  = {Ranges for the Standard Library: Revision 1},
  author = {Eric Niebler, Sean Parent, Andrew Sutton},
  year   = {2014},
  key    = {D4128},
  month  = {10},
  url    = {https://ericniebler.github.io/std/wg21/D4128.html}
}

@misc{niebler.2018.deepranges,
  title        = {Deep Integration of the Ranges {TS}},
  author       = {Eric Niebler and Casey Carter},
  year         = {2018},
  key          = {p1037r0},
  pages        = {61--61},
  month        = {05},
  organization = {WG21},
  url          = {https://wg21.link/p1037r0}
}

@misc{niebler.2018.mergingranges,
  title        = {Merging the Ranges {TS}},
  author       = {Eric Niebler and Casey Carter},
  year         = {2018},
  key          = {p0896r1},
  pages        = {96--96},
  month        = {05},
  organization = {WG21},
  url          = {https://wg21.link/p0896r1}
}

@misc{niebler.2018.ranges,
  author       = {Eric Niebler and Casey Carter},
  title        = {{P1037R0}: {D}eep Integration of the Ranges {TS}},
  note         = {{\small\url{https://wg21.link/p1037r0}}},
  year         = 2018,
  month        = may,
  optpublisher = {WG21}
}

@software{nlohmann.2021.json,
  author  = {Niels Lohmann},
  title   = {Json},
  url     = {https://github.com/nlohmann/json},
  version = {3.10.2},
  date    = {2021-08-26}
}

@article{novak.1997.reuse,
  author   = {G. S. {Novak}},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Software reuse by specialization of generic procedures through views},
  year     = {1997},
  volume   = {23},
  number   = {7},
  pages    = {401-417},
  abstract = {A generic procedure can be specialized, by compilation through views, to operate directly on concrete
              data. A view is a computational mapping that describes how a concrete type implements an abstract type.
              Clusters of related views are needed for specialization of generic procedures that involve several types
              or several views of a single type. A user interface that reasons about relationships between concrete
              types and abstract types allows view clusters to be created easily. These techniques allow rapid
              specialization of generic procedures for applications.},
  keywords = {software reusability; abstract data types; partial evaluation (compilers); program compilers;
              user interfaces; software reuse; generic procedure specialization; views; computational mapping;
              concrete type; abstract data type; user interface; view clusters; partial evaluation;
              direct manipulation editor; Concrete; Software algorithms; Clustering algorithms; Programming profession;
              Object oriented programming; User interfaces; Application software; Costs; Production; Libraries},
  doi      = {10.1109/32.605759},
  issn     = {2326-3881},
  month    = {July}
}

@inproceedings{oezkan.2017.IPlibrary,
  author    = {M. A. {Oezkan} and O. {Reiche} and F. {Hannig} and J. {Teich}},
  booktitle = {FSP 2017; Fourth International Workshop on FPGAs for Software Programmers},
  title     = {A Highly Efficient and Comprehensive Image Processing Library for C++-based High-Level Synthesis},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {1-10},
  abstract  = {Field Programmable Gate Arrays (FPGAs) are proved to be among the most suitable architectures for image
               processing applications. However, accelerating algorithms using FPGAs is a time-consuming task and needs
               expertise. Whereas the recent advancements in High-Level Synthesis (HLS) promise to solve this problem,
               today's HLS tools require apt hardware descriptions of algorithms to be able to provide favorable
               implementations. A solution is developing highly parameterizable and optimized HLS libraries for the
               fundamental image processing components. Another solution is providing a higher level of abstraction in
               the form of a Domain-Specific Language (DSL) and a corresponding efficient back end for hardware design.
               In this paper, we provide a highly efficient and parameterizable C++ library for image processing
               applications, which would be the cornerstone for both approaches. In our library, nodes of a stream-based
               data flow graph can be described as C++ objects for specified functions, and the whole application can be
               efficiently parallelized just by defining a global constant as the parallelization factor. Moreover, the
               key hardware design elements, i.e., line buffers and sliding windows with different border handling
               patterns, can be utilized individually to ease the design of more complicated applications.},
  keywords  = {},
  doi       = {},
  issn      = {null},
  month     = {Sep.}
}

@misc{olena.2000.www,
  author       = {EPITA Research and Developpement Laboratory (LRDE)},
  oldkeys      = {olena.net},
  title        = {The {Olena} image processing platform},
  key          = {Olena},
  year         = {2000},
  howpublished = {\url{http://olena.lrde.epita.fr}}
}

@misc{oliphant.2006.numpy,
  author       = {Travis Oliphant},
  title        = {{NumPy}: A guide to {NumPy}},
  year         = {2006},
  howpublished = {USA: Trelgol Publishing},
  url          = {http://www.numpy.org/}
}

@misc{opencv.bg_sub,
  title = {Background Subtraction},
  note  = {{\small\url{https://docs.opencv.org/3.4/d1/dc5/tutorial_background_subtraction.html}}},
  year  = 2018,
  month = dec
}

@incollection{oram.2007.beautiful,
  title     = {Multidimensional Iterators in {N}um{P}y},
  chapter   = 19,
  booktitle = {Beautiful code},
  author    = {Travis E. Oliphant},
  editor    = {Andrew Oram and Greg Wilson},
  year      = 2007,
  publisher = {O'reilly Sebastopol, CA}
}

@misc{parent.2018.generic-programming,
  author    = {Sean Parent},
  title     = {2018 : Generic Programming},
  url       = {https://codedive.pl/2018/generic-programming},
  year      = {2018},
  publisher = {{code::dive} 2019},
  note      = {Talk available on youtube at \url{https://youtu.be/FtZEU9zv9eM}}
}

@book{part.1996.matlab,
  title     = {The MATLAB handbook},
  author    = {P{\"a}rt-Enander, Eva and Sj{\"o}berg, Anders and Melin, Bo and Isaksson, Pernilla},
  year      = {1996},
  publisher = {Addison-Wesley Harlow}
}

@incollection{paszke.2019.pytorch,
  title     = {PyTorch: An Imperative Style, High-Performance Deep Learning Library},
  author    = {Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and
               Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and
               Desmaison, Alban and Kopf, Andreas and Yang, Edward and DeVito, Zachary and Raison, Martin and
               Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and
               Chintala, Soumith},
  booktitle = {Advances in Neural Information Processing Systems 32},
  editor    = {H. Wallach and H. Larochelle and A. Beygelzimer and F. d\textquotesingle Alch{\'e}-Buc and E. Fox and
               R. Garnett},
  pages     = {8024--8035},
  year      = {2019},
  publisher = {Curran Associates, Inc.},
  url       = {http://papers.neurips.cc/paper/9015-pytorch-an-imperative-style-high-performance-deep-learning-library.pdf}
}

@article{perret.2019.higra,
  title    = {Higra: Hierarchical Graph Analysis},
  journal  = {SoftwareX},
  volume   = {10},
  pages    = {100335},
  year     = {2019},
  issn     = {2352-7110},
  doi      = {https://doi.org/10.1016/j.softx.2019.100335},
  url      = {http://www.sciencedirect.com/science/article/pii/S235271101930247X},
  author   = {B. Perret and G. Chierchia and J. Cousty and S.J. F. Guimarães and Y. Kenmochi and L. Najman},
  keywords = {Graph, Hierarchical clustering, Component tree},
  abstract = {Higra — Hierarchical Graph Analysis is a C++/Python library for efficient sparse graph analysis with a
              special focus on hierarchical methods capable of handling large amount of data. The main aspects of
              hierarchical graph analysis addressed in Higra are the construction of hierarchical representations
              (agglomerative clustering, mathematical morphology hierarchies, etc.), the analysis and processing of such
              representations (filtering, clustering, characterization, etc.), and their assessment. Higra targets a
              large audience, from students and practitioners wanting an accessible library for quickly experimenting,
              to researchers developing new methods for hierarchical analysis of graph data. Higra is a generic toolbox
              for graph analysis and can be utilized in a large variety of application fields like machine learning,
              data science, pattern analysis and computer vision. Moreover, it contains an image analysis module easing
              the handling of pixel grid graphs by providing efficient algorithms dedicated to this field.}
}

@article{peterson.2009.f2py,
  title     = {F2PY: a tool for connecting Fortran and Python programs},
  author    = {Peterson, Pearu},
  journal   = {International Journal of Computational Science and Engineering},
  volume    = {4},
  number    = {4},
  pages     = {296--305},
  year      = {2009},
  publisher = {Inderscience Publishers}
}

@article{piper.1985.data,
  title     = {Data structures for image processing in a {C} language and {U}nix environment},
  author    = {Jim Piper and Denis Rutovitz},
  journal   = {Pattern Recognition Letters},
  volume    = {3},
  number    = {2},
  pages     = {119--129},
  year      = {1985},
  publisher = {Elsevier}
}

@article{pirkelbauer.2010.multimethods,
  title    = {Design and evaluation of {C}++ open multi-methods},
  journal  = {Science of Computer Programming},
  volume   = {75},
  number   = {7},
  pages    = {638 - 667},
  year     = {2010},
  note     = {Generative Programming and Component Engineering (GPCE 2007)},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2009.06.002},
  url      = {http://www.sciencedirect.com/science/article/pii/S016764230900094X},
  author   = {Peter Pirkelbauer and Yuriy Solodkyy and Bjarne Stroustrup},
  keywords = {Multi-methods, Open-methods, Multiple dispatch, Binary method problem, Augmenting method problem,
              Object-oriented programming, Generic programming, C},
  abstract = {Multiple dispatch-the selection of a function to be invoked based on the dynamic type of two or more
              arguments-is a solution to several classical problems in object-oriented programming. Open multi-methods
              generalize multiple dispatch towards open-class extensions, which improve separation of concerns and
              provisions for retroactive design. We present the rationale, design, implementation, performance,
              programming guidelines, and experiences of working with a language feature, called open multi-methods, for
              C++. Our open multi-methods support both repeated and virtual inheritance. Our call resolution rules
              generalize both virtual function dispatch and overload resolution semantics. After using all information
              from argument types, these rules can resolve further ambiguities by using covariant return types. Care was
              taken to integrate open multi-methods with existing C++ language features and rules. We describe a model
              implementation and compare its performance and space requirements to existing open multi-method extensions
              and work-around techniques for C++. Compared to these techniques, our approach is simpler to use, catches
              more user mistakes, and resolves more ambiguities through link-time analysis, is comparable in memory
              usage, and runs significantly faster. In particular, the runtime cost of calling an open multi-method is
              constant and less than the cost of a double dispatch (two virtual function calls). Finally, we provide a
              sketch of a design for open multi-methods in the presence of dynamic loading and linking of libraries.}
}

@book{plauger.2000.c++-stl,
  title     = {C++ standard template library},
  author    = {Plauger, Phillip James and Lee, Meng and Musser, David and Stepanov, Alexander A},
  year      = {2000},
  publisher = {Prentice Hall PTR}
}

@software{ptc.2019.mathcad,
  author  = {{PTC}},
  title   = {GraphicsMagick},
  url     = {https://www.mathcad.com},
  version = {6.0},
  date    = {2019-10-01}
}

@software{pypi.2021,
  author  = {{The PyPi Developement Team}},
  title   = {{P}y{P}i},
  url     = {https://pypi.org},
  version = {21.0.1},
  date    = {2021-01-31}
}

@software{quantstack.2021.xeus-cling,
  author  = {QuantStack},
  title   = {xeus-cling},
  url     = {https://github.com/QuantStack/xeus-cling},
  version = {0.12.1},
  date    = {2021-03-16}
}

@article{ragankelley.2013.halide,
  author  = {Jonathan Ragan-kelley and Connelly Barnes and Andrew Adams and Fr{\'e}do Durand and Saman Amarasinghe and
             et al.},
  title   = {{H}alide: A Language and Compiler for Optimizing Parallelism, Locality, and Recomputation in Image
             Processing Pipelines},
  year    = {2013},
  journal = {PLDI 2013}
}

@book{redfern.2012.matlab,
  title     = {The MATLAB{\textregistered} 5 Handbook},
  author    = {Redfern, Darren and Campbell, Colin},
  year      = {2012},
  publisher = {Springer Science \& Business Media}
}

@article{ritter.1990.cvgi,
  title     = {Image algebra: An overview},
  author    = {Gerhard X. Ritter and Joseph N. Wilson and Jennifer L. Davidson},
  journal   = {Computer Vision, Graphics, and Image Processing},
  volume    = 49,
  number    = 3,
  pages     = {297--331},
  year      = 1990,
  publisher = {Elsevier}
}

@article{roman.1998.digital,
  author   = {D. {Roman} and M. {Fisher} and J. {Cubillo}},
  journal  = {IEEE Transactions on Education},
  title    = {Digital image processing-an object-oriented approach},
  year     = {1998},
  volume   = {41},
  number   = {4},
  pages    = {331-333},
  abstract = {This paper presents a class library dedicated to digital image processing which provides resources for
              essential digital image processing operations. Besides its practical value, the class library is used to
              teach both object-oriented software engineering methodology and digital image processing. The resulting
              module can be accessed from independent specialized applications through its public interface while its
              implementation details are perfectly encapsulated. First of all it is used as the inner part of an
              integrated environment designed for students and researchers in the field of digital image processing.This
              software component was built aiming for both portability and extendibility. It contains attributes and
              methods that allow for a wide range of digital image processing algorithms: point and geometric
              operations; filter, edge detection, segmentation and texture operations; and fast Fourier transforms,
              discrete cosine transforms, and wavelet and Gabor transformations. All these can be used for image
              enhancement, restoration, compression, analysis, and synthesis.},
  keywords = {image processing; software engineering; engineering education; object-oriented programming;
              object-oriented approach; digital image processing; object-oriented software engineering; encapsulation;
              integrated environment; digital image processing algorithms; geometric operations; point operations;
              filter; edge detection; segmentation; texture operations; fast Fourier transforms;
              discrete cosine transforms; wavelet; Gabor transformations; image enhancement; image restoration;
              image compression; image analysis; image synthesis; Digital images; Software libraries;
              Software engineering; Application software; Digital filters; Gabor filters; Image edge detection;
              Image segmentation; Fast Fourier transforms; Discrete cosine transforms},
  doi      = {10.1109/13.728270},
  issn     = {1557-9638},
  month    = {Nov}
}

@inproceedings{roynard.2019.rrpr,
  author    = {Roynard, Micha{\"e}l and Carlinet, Edwin and G{\'e}raud, Thierry},
  editor    = {Kerautret, Bertrand and Colom, Miguel and Lopresti, Daniel and Monasse, Pascal and Talbot, Hugues},
  title     = {An Image Processing Library in Modern C++: Getting Simplicity and Efficiency with Generic Programming},
  booktitle = {Reproducible Research in Pattern Recognition},
  year      = {2019},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {121--137},
  abstract  = {As there are as many clients as many usages of an Image Processing library, each one may expect
               different services from it. Some clients may look for efficient and production-quality algorithms, some
               may look for a large tool set, while others may look for extensibility and genericity to inter-operate
               with their own code base...but in most cases, they want a simple-to-use and stable product. For a C++
               Image Processing library designer, it is difficult to conciliate genericity, efficiency and simplicity at
               the same time. Modern C++ (post 2011) brings new features for library developers that will help designing
               a software solution combining those three points. In this paper, we develop a method using these
               facilities to abstract the library components and augment the genericity of the algorithms. Furthermore,
               this method is not specific to image processing; it can be applied to any C++ scientific library.},
  isbn      = {978-3-030-23987-9}
}

@article{sanderson.2016.armadillo,
  title     = {Armadillo: a template-based C++ library for linear algebra},
  author    = {Sanderson, Conrad and Curtin, Ryan},
  journal   = {Journal of Open Source Software},
  volume    = {1},
  number    = {2},
  pages     = {26},
  year      = {2016},
  publisher = {Journal of Open Source Software}
}
  
@article{sanderson.2019.practical,
  title     = {Practical Sparse Matrices in C++ with Hybrid Storage and Template-Based Expression Optimisation},
  author    = {Sanderson, Conrad and Curtin, Ryan},
  journal   = {Mathematical and Computational Applications},
  volume    = {24},
  number    = {3},
  pages     = {70},
  year      = {2019},
  publisher = {Multidisciplinary Digital Publishing Institute}
}

@software{scilab.2020,
  author  = {{Scilab Enterprises}},
  title   = {Scilab},
  url     = {https://www.scilab.org},
  version = {6.1.0},
  date    = {2020-02-25}
}

@misc{seymour.2009.concepts,
  title        = {{LWG} Papers to Re-Merge into {C}++0x After Removing Concepts},
  author       = {Bill Seymour},
  year         = {2009},
  key          = {N2929},
  month        = {07},
  organization = {WG21},
  url          = {https://wg21.link/n2929}
}

@inproceeding{siek.2001.boostgraph,
  author    = {Jeremy Siek, Lie-Quan Lee, Andrew Lumsdaine},
  title     = {The {B}oost {G}raph library},
  year      = {2001},
  url       = {http://cds.cern.ch/record/1518180/files/0201729148_TOC.pdf},
  publisher = {Addison-Wesley}
}

@book{stepanov.1987.higher,
  title     = {Higher order programming},
  author    = {Stepanov, Alexander A and Kershenbaum, Aaron and Musser, David R},
  year      = {1987},
  publisher = {March}
}

  

@book{stepanov.1995.standard,
  title     = {The standard template library},
  author    = {Stepanov, Alexander and Lee, Meng},
  volume    = {1501},
  year      = {1995},
  publisher = {Hewlett Packard Laboratories 1501 Page Mill Road, Palo Alto, CA 94304}
}

  
@misc{stepanov.2003.gcm,
  author    = {Alexander Stepanov},
  title     = {Greatest Common Measure: The Last 2500 Years},
  url       = {http://stepanovpapers.com/gcd.pdf},
  year      = {2003},
  publisher = {1999 Arthur Schoffstall Lecture in Computer Science and Computer Engineering at the Rensselaer
               Polytechnic Institute},
  note      = {Slides available at \url{http://stepanovpapers.com/gcd.pdf}.
               Talk available on youtube at \url{https://youtu.be/fanm5y00joc}}
}

  

@book{stepanov.2004.notes,
  title     = {Notes on the Foundations of Programming},
  author    = {Stepanov, Alexander A and Marcus, Matthew A},
  year      = {2004},
  publisher = {Citeseer}
}

@book{stepanov.2009.elements,
  author    = {Alexander Stepanov and Paul McJones},
  title     = {Elements of Programming},
  publisher = {Addison-Wesley Professional},
  year      = {2009},
  month     = {06},
  optnote   = {Decomposing programs into a system of algorithmic components}
}

@book{stepanov.2014.mathematics,
  title     = {From mathematics to generic programming},
  author    = {Stepanov, Alexander A and Rose, Daniel E},
  year      = {2014},
  publisher = {Pearson Education}
}

@book{stroustrup.1995.design,
  author    = {Stroustrup, Bjarne},
  title     = {The Design and Evolution of {C}++},
  year      = {1994},
  isbn      = {0-201-54330-3},
  publisher = {ACM Press/Addison-Wesley Publishing Co.},
  address   = {New York, NY, USA}
}


@inbook{stroustrup.1996.history,
  author    = {Stroustrup, Bjarne},
  title     = {A History of C++: 1979--1991},
  year      = {1996},
  isbn      = {0201895021},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/234286.1057836},
  abstract  = {This paper outlines the history of the C++ programming language. The emphasis is on the ideas,
               constraints, and people that shaped the language, rather than the minutiae of language features. Key
               design decisions relating to language features are discussed, but the focus is one of the overall design
               goals and practical constraints. The evolution of C++ is traced from C with Classes to the current ANSI
               and ISO standards work and the explosion of use, interest, commercial activity, compilers, tools,
               environments, and libraries.},
  booktitle = {History of Programming Languages---II},
  pages     = {699-769},
  numpages  = {71}
}

@article{stroustrup.1999.hot,
  title     = {An overview of the {C++} programming language},
  author    = {Bjarne Stroustrup},
  journal   = {Handbook of Object Technology},
  year      = {1999},
  publisher = {CRC Press}
}

@misc{stroustrup.2003.concepts,
  title        = {Concepts — {D}esign choices for template argument checking},
  author       = {Bjarne Stroustrup and Gabriel Dos Reis},
  year         = {2003},
  key          = {N1522},
  month        = {10},
  organization = {WG21},
  url          = {https://wg21.link/n1522}
}


@article{stroustrup.2005.design,
  title   = {The design of C++ 0x},
  author  = {Stroustrup, Bjarne},
  journal = {C/C++ Users Journal},
  volume  = {23},
  number  = {5},
  pages   = {7},
  year    = {2005}
}

@inproceedings{stroustrup.2007.evolving,
  author    = {Stroustrup, Bjarne},
  title     = {Evolving a Language in and for the Real World: C++ 1991-2006},
  year      = {2007},
  isbn      = {9781595937667},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1238844.1238848},
  doi       = {10.1145/1238844.1238848},
  abstract  = {This paper outlines the history of the C++ programming language from the early days of its ISO
               standardization (1991), through the 1998 ISO standard, to the later stages of the C++0x revision of that
               standard (2006). The emphasis is on the ideals, constraints, programming techniques, and people that
               shaped the language, rather than the minutiae of language features. Among the major themes are the
               emergence of generic programming and the STL (the C++ standard library's algorithms and containers).
               Specific topics include separate compilation of templates, exception handling, and support for embedded
               systems programming. During most of the period covered here, C++ was a mature language with millions of
               users. Consequently, this paper discusses various uses of C++ and the technical and commercial pressures
               that provided the background for its continuing evolution.},
  booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  pages     = {4-1-4-59},
  keywords  = {programming language, standardization, libraries, language use, STL, multi-paradigm programming,
               evolution, ISO, C++, history},
  location  = {San Diego, California},
  series    = {HOPL III}
}

% First appearence of the expression "generic programming"
@inproceedings{stroustrup.2007.hopl,
  author       = {Bjarne Stroustrup},
  title        = {Evolving a Language in and for the Real World: {C++} 1991-2006},
  year         = {2007},
  isbn         = {9781595937667},
  optpublisher = {Association for Computing Machinery},
  address      = {New York, USA},
  url          = {https://doi.org/10.1145/1238844.1238848},
  doi          = {10.1145/1238844.1238848},
  booktitle    = {Proc. of the 3rd ACM SIGPLAN Conf. on History of Programming Languages},
  optbooktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  volume       = {4},
  pages        = {1--59},
  location     = {San Diego, California},
  optseries    = {HOPL III}
}

@article{stroustrup.2012.concept,
  title   = {A Concept Design for the STL},
  author  = {Stroustrup, Bjarne and Sutton, Andrew and Voufo, L and Zalewski, M},
  journal = {C++ Standards Committee Papers, Technical Report N},
  volume  = {3351},
  pages   = {12--0041},
  year    = {2012}
}

@article{stroustrup.2020.acm,
  author     = {Stroustrup, Bjarne},
  title      = {Thriving in a Crowded and Changing World: C++ 2006-2020},
  year       = {2020},
  issue_date = {June 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {HOPL},
  url        = {https://doi.org/10.1145/3386320},
  doi        = {10.1145/3386320},
  abstract   = {By 2006, C++ had been in widespread industrial use for 20 years. It contained parts that had survived
                unchanged since introduced into C in the early 1970s as well as features that were novel in the early
                2000s. From 2006 to 2020, the C++ developer community grew from about 3 million to about 4.5 million. It
                was a period where new programming models emerged, hardware architectures evolved, new application
                domains gained massive importance, and quite a few well-financed and professionally marketed languages
                fought for dominance. How did C++ -- an older language without serious commercial backing -- manage to
                thrive in the face of all that? This paper focuses on the major changes to the ISO C++ standard for the
                2011, 2014, 2017, and 2020 revisions. The standard library is about 3/4 of the C++20 standard, but this
                paper's primary focus is on language features and the programming techniques they support. The paper
                contains long lists of features documenting the growth of C++. Significant technical points are
                discussed and illustrated with short code fragments. In addition, it presents some failed proposals and
                the discussions that led to their failure. It offers a perspective on the bewildering flow of facts and
                features across the years. The emphasis is on the ideas, people, and processes that shaped the language.
                Themes include efforts to preserve the essence of C++ through evolutionary changes, to simplify its use,
                to improve support for generic programming, to better support compile-time programming, to extend
                support for concurrency and parallel programming, and to maintain stable support for decades' old code.
                The ISO C++ standard evolves through a consensus process. Inevitably, there is competition among
                proposals and clashes (usually polite ones) over direction, design philosophies, and principles. The
                committee is now larger and more active than ever, with as many as 250 people turning up to week-long
                meetings three times a year and many more taking part electronically. We try (not always successfully)
                to mitigate the effects of design by committee, bureaucratic paralysis, and excessive enthusiasm for a
                variety of language fashions.  Specific language-technical topics include the memory model, concurrency
                and parallelism, compile-time computation, move-semantics, exceptions, lambda expressions, and modules.
                Designing a mechanism for specifying a template's requirements on its arguments that is sufficiently
                flexible and precise yet doesn't impose run-time costs turned out to be hard. The repeated attempts to
                design ``concepts'' to do that have their roots back in the 1980s and touch upon many key design issues
                for C++ and for generic programming.  The description is based on personal participation in the key
                events and design decisions, backed by the thousands of papers and hundreds of meeting minutes in the
                ISO C++ standards committee's archives.},
  journal    = {Proc. ACM Program. Lang.},
  month      = jun,
  articleno  = {70},
  numpages   = {168},
  keywords   = {C++, concurrency and parallelism, generic programming, programming language design and evolution,
                resource management, simplification of language use, standardization}
}


@inproceedings{sutton.2012.concepts,
  author    = {Sutton, Andrew and Stroustrup, Bjarne},
  editor    = {Sloane, Anthony and A{\ss}mann, Uwe},
  title     = {Design of Concept Libraries for C++},
  booktitle = {Software Language Engineering},
  year      = {2012},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {97--118},
  abstract  = {We present a set of concepts (requirements on template arguments) for a large subset of the ISO C++
               standard library. The goal of our work is twofold: to identify a minimal and useful set of concepts
               required to constrain the library's generic algorithms and data structures and to gain insights into how
               best to support such concepts within C++. We start with the design of concepts rather than the design of
               supporting language features; the language design must be made to fit the concepts, rather than the other
               way around. A direct result of the experiment is the realization that to simply and elegantly support
               generic programming we need two kinds of abstractions: constraints are predicates on static properties of
               a type, and concepts are abstract specifications of an algorithm's syntactic and semantic requirements.
               Constraints are necessary building blocks of concepts. Semantic properties are represented as axioms. We
               summarize our approach: concepts{\thinspace}={\thinspace}constraints{\thinspace}+{\thinspace}axioms. This
               insight is leveraged to develop a library containing only 14 concepts that encompassing the functional,
               iterator, and algorithm components of the C++ Standard Library (the STL). The concepts are implemented as
               constraint classes and evaluated using Clang's and GCC's Standard Library test suites.},
  isbn      = {978-3-642-28830-2}
}

% first appearence of "concept" and "regular type"
@misc{sutton.2017.concepts,
  title        = {Working Draft, {C}++ extensions for Concepts},
  author       = {Andrew Sutton},
  year         = {2017},
  key          = {N4674},
  month        = {06},
  organization = {WG21},
  url          = {https://wg21.link/n4674}
}

@book{taylor.2004.intel,
  title     = {Intel integrated performance primitives},
  author    = {Taylor, Stewart},
  year      = {2004},
  publisher = {Intel Press}
}

@misc{tensorflow.2015.whitepaper,
  title  = {{TensorFlow}: Large-Scale Machine Learning on Heterogeneous Systems},
  url    = {https://www.tensorflow.org/},
  note   = {Software available from tensorflow.org},
  author = {Mart{\'i}n~Abadi and Ashish~Agarwal and Paul~Barham and Eugene~Brevdo and Zhifeng~Chen and Craig~Citro and
            Greg~S.~Corrado and Andy~Davis and Jeffrey~Dean and Matthieu~Devin and Sanjay~Ghemawat and
            Ian~Goodfellow and Andrew~Harp and Geoffrey~Irving and Michael~Isard and Yangqing Jia and
            Rafal~Jozefowicz and Lukasz~Kaiser and Manjunath~Kudlur and Josh~Levenberg and Dandelion~Man{\'e} and
            Rajat~Monga and Sherry~Moore and Derek~Murray and Chris~Olah and Mike~Schuster and Jonathon~Shlens and
            Benoit~Steiner and Ilya~Sutskever and Kunal~Talwar and Paul~Tucker and Vincent~Vanhoucke and
            Vijay~Vasudevan and Fernanda~Vi{\'e}gas and Oriol~Vinyals and Pete~Warden and Martin~Wattenberg and
            Martin~Wicke and Yuan~Yu and Xiaoqiang~Zheng},
  year   = {2015}
}

@inproceedings{tschumperle.2012.cimg,
  title       = {{The CImg Library}},
  author      = {Tschumperl{\'e}, David},
  url         = {https://hal.archives-ouvertes.fr/hal-00927458},
  booktitle   = {{IPOL 2012 Meeting on Image Processing Libraries}},
  address     = {Cachan, France},
  pages       = {4 pp},
  year        = {2012},
  month       = Jun,
  keywords    = {Image Processing; C++ Library; Template-based programming; Genericity; Straightforwardness;
                 Script language},
  pdf         = {https://hal.archives-ouvertes.fr/hal-00927458/file/tschumperle_ipol2012.pdf},
  hal_id      = {hal-00927458},
  hal_version = {v1}
}

@article{vanderwalt.2014.skimage,
  title    = {scikit-image: image processing in {P}ython},
  author   = {van der Walt, {S}t\'efan and {S}ch\"onberger, {J}ohannes {L}. and {Nunez-Iglesias}, {J}uan and
              {B}oulogne, {F}ran\c{c}ois and {W}arner, {J}oshua {D}. and {Y}ager, {N}eil and
              {G}ouillart, {E}mmanuelle and {Y}u, {T}ony and the scikit-image contributors},
  year     = {2014},
  month    = {6},
  keywords = {Image processing, Reproducible research, Education, Visualization, Open source, Python,
              Scientific programming},
  volume   = {2},
  pages    = {e453},
  journal  = {PeerJ},
  issn     = {2167-8359},
  url      = {https://doi.org/10.7717/peerj.453},
  doi      = {10.7717/peerj.453}
}

@book{vandevoorde.2002.c++,
  title     = {C++ Templates: The Complete Guide, Portable Documents},
  author    = {Vandevoorde, David and Josuttis, Nicolai M},
  year      = {2002},
  publisher = {Addison-Wesley Professional}
}

@article{vanherk.1992.localminmax,
  title    = {A fast algorithm for local minimum and maximum filters on rectangular and octagonal kernels},
  journal  = {Pattern Recognition Letters},
  volume   = {13},
  number   = {7},
  pages    = {517 - 521},
  year     = {1992},
  issn     = {0167-8655},
  doi      = {https://doi.org/10.1016/0167-8655(92)90069-C},
  url      = {http://www.sciencedirect.com/science/article/pii/016786559290069C},
  author   = {Marcel van Herk},
  keywords = {Mathematical morphology, recursive filters, local maximum and minimum, separability},
  abstract = {A new algorithm is presented for local maximum and minimum filters requiring only 6 comparisons per pixel
              independent of kernel size. The algorithm is based on separability and a combination of block recursive
              series which are evaluated forwards and backwards.}
}

@inproceedings{vassilev.2012.cling,
  author    = {Vassilev,V. and Canal,Ph. and Naumann,A. and Moneta,L. and Russo,P.},
  title     = {{Cling} — The New Interactive Interpreter for {ROOT} 6},
  journal   = {Journal of Physics: Conference Series},
  year      = 2012,
  month     = {12},
  volume    = {396},
  number    = {5},
  pages     = {052071},
  doi       = {10.1088/1742-6596/396/5/052071},
  url       = {https://iopscience.iop.org/article/10.1088/1742-6596/396/5/052071/pdf},
  publisher = {{IOP} Publishing}
}

@article{veldhuizen.1995.expression,
  title   = {Expression templates},
  author  = {Veldhuizen, Todd},
  journal = {C++ Report},
  volume  = {7},
  number  = {5},
  pages   = {26--31},
  year    = {1995}
}

@inproceedings{veldhuizen.1998.arrays,
  author    = {Veldhuizen, Todd L.},
  editor    = {Caromel, Denis and Oldehoeft, Rodney R. and Tholburn, Marydell},
  title     = {Arrays in Blitz++},
  booktitle = {Computing in Object-Oriented Parallel Environments},
  year      = {1998},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {223--230},
  abstract  = {The Blitz++ library provides numeric arrays for C++ with efficiency that rivals Fortran, without any
               language extensions. Blitz++ has features unavailable in Fortran 90/95, such as arbitrary transpose
               operations, array renaming, tensor notation, partial reductions, multi-component arrays and stencil
               operators. The library handles parsing and analysis of array expressions on its own using the expression
               templates technique, and performs optimizations (such as loop transformations) which have until now been
               the responsibility of compilers.},
  isbn      = {978-3-540-49372-3}
}

@inproceedings{veldhuizen.2000.blitz,
  author    = {Veldhuizen, Todd L.},
  editor    = {Langtangen, Hans Petter and Bruaset, Are Magnus and Quak, Ewald},
  title     = {Blitz++: The Library that Thinks it is a Compiler},
  booktitle = {Advances in Software Tools for Scientific Computing},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {57--87},
  abstract  = {Blitz++ provides dense numeric arrays for C++ with performance on par with Fortran. It does so by using
               ''template techniques'' (expression templates and template metaprograms). In addition to fast
               performance, Blitz++ arrays pro­vide many nice notations and features not available in Fortran 90.},
  isbn      = {978-3-642-57172-5}
}


@article{veldhuizen.2000.techniques,
  title     = {Techniques for scientific C++},
  author    = {Veldhuizen, Todd},
  journal   = {Computer science technical report},
  volume    = {542},
  pages     = {60},
  year      = {2000},
  publisher = {Citeseer}
}

@techreport{veldhuizen.2003.c++templates,
  author      = {Todd L. Veldhuizen},
  title       = {C++ Templates are Turing Complete},
  institution = {},
  year        = {2003}
}

@misc{voutilainen.2017.concepts,
  title        = {Merge the Concepts {TS} Working Draft into the {C}++20 working draft},
  author       = {Ville Voutilainen},
  year         = {2017},
  key          = {P0724r0},
  month        = {06},
  organization = {WG21},
  url          = {https://wg21.link/p0724r0}
}

@article{wagner.2005.generic,
  title   = {A Generic and Extensible Optimization Environment},
  author  = {Wagner, S and Affenzeller, M},
  journal = {Adaptive and Natural Computing Algorithms, Springer Computer Science},
  pages   = {538--541},
  year    = {2005}
}

@inproceedings{wimtlplavrijsen.2016.cppyy,
  author    = {W. T. L. P. Lavrijsen and A. Dutta},
  booktitle = {2016 6th Workshop on {P}ython for High-Performance and Scientific Computing ({P}y{HPC})},
  title     = {High-Performance {P}ython-{C}++ Bindings with {P}y{P}y and {C}ling},
  year      = {2016},
  volume    = {},
  number    = {},
  pages     = {27-35},
  keywords  = {C++ language; software libraries; private Boolean query processing; encrypted data; data outsourcing;
               privacy risks; data encryption; data confidentiality; support complex queries; security requirements;
               privacy-preserving query processing framework; Bloom filter; additive homomorphic encryption;
               query evaluation; PyPy; Cling; high level productivity language; high performance libraries;
               Python-C++ bindings generators; thread safety; C++ parser; dynamic optimizations; CPython; C++ functions;
               C++ libraries; C++ languages; Generators; Standards; Libraries; Optimization; Semantics; Productivity},
  doi       = {10.1109/PyHPC.2016.008},
  issn      = {},
  month     = {11}
}

@software{wolfram.2020.mathematica,
  author  = {{wolfram Research}},
  title   = {Mathematica},
  url     = {https://www.wolfram.com/mathematica/},
  version = {12.2},
  date    = {2020-12-16}
}

@inproceedings{wong.2019.heterogeneous,
  author    = {Wong, Michael and Finkel, Hal},
  title     = {Distributed \& Heterogeneous Programming in C++ for HPC at SC17},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  series    = {IWOCL '18},
  year      = {2018},
  isbn      = {978-1-4503-6439-3},
  location  = {Oxford, United Kingdom},
  pages     = {20:1--20:7},
  articleno = {20},
  numpages  = {7},
  url       = {http://doi.acm.org/10.1145/3204919.3204939},
  doi       = {10.1145/3204919.3204939},
  acmid     = {3204939},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {BoF, C++, HPC, SC17, concurrency, distributed programming models, heterogeneous programming, parallelism}
}

 @software{xilinx.2021.triSYCL,
  author  = {Xilinx and others},
  title   = {The triSYCL project},
  url     = {https://github.com/trisycl/trisycl},
  version = {master}
}

@article{xu.2015.pami,
  title        = {Connected filtering on tree-based shape-spaces},
  author       = {Yongchao Xu and Thierry G{\'e}raud and Laurent Najman},
  journal      = {IEEE Transactions on Pattern Analysis and Machine Intelligence},
  volume       = {38},
  number       = {6},
  pages        = {1126--1140},
  year         = {2015},
  optpublisher = {IEEE}
}

@article{yoo.2002.engineering,
  title     = {Engineering and algorithm design for an image processing API: a technical report on ITK-the insight
               toolkit},
  author    = {Yoo, Terry S and Ackerman, Michael J and Lorensen, William E and Schroeder, Will and Chalana, Vikram and
               Aylward, Stephen and Metaxas, Dimitris and Whitaker, Ross},
  journal   = {Studies in health technology and informatics},
  pages     = {586--592},
  year      = {2002},
  publisher = {IOS Press; 1999}
}

