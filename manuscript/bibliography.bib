@inproceedings{austern.2000.segmented,
  author    = {Austern, Matthew H.},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser,
                David R.},
  title     = {Segmented Iterators and Hierarchical Algorithms},
  booktitle = {Generic Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {80--90},
  abstract  = {Many data structures are naturally segmented. Generic
                algorithms that ignore that feature, and that treat every data
                structure as a uniform range of elements, are unnecessarily
                inefficient. A new kind of iterator abstraction, in which
                segmentation is explicit, makes it possible to write
                hierarchical algorithms that exploit segmentation.},
  isbn      = {978-3-540-39953-7}
}

@inproceedings{burrus.2003.mpool,
  author       = {Nicolas Burrus and Alexandre Duret-Lutz and Thierry
                  G\'eraud and David Lesage and Rapha\"el Poss},
  title        = {A static {C++} object-oriented programming ({SCOOP})
                  paradigm mixing benefits of traditional {OOP} and generic
                  programming},
  booktitle    = {Proceedings of the Workshop on Multiple Paradigm with
                  Object-Oriented Languages (MPOOL)},
  year         = 2003,
  address      = {Anaheim, CA, USA},
  month        = oct,
  abstract     = {Object-oriented and generic programming are both supported
                  in C++. OOP provides high expressiveness whereas GP leads
                  to more efficient programs by avoiding dynamic typing. This
                  paper presents SCOOP, a new paradigm which enables both
                  classical OO design and high performance in C++ by mixing
                  OOP and GP. We show how classical and advanced OO features
                  such as virtual methods, multiple inheritance, argument
                  covariance, virtual types and multimethods can be
                  implemented in a fully statically typed model, hence
                  without run-time overhead.},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/mpool03-abstract.pdf},
  lrdeprojects = {Olena},
  lrdenewsdate = {2003-10-29}
}

@article{berti.2006.gral,
  title     = {{GrAL}--the Grid Algorithms Library},
  author    = {Guntram Berti},
  journal   = {Future Generation Computer Systems},
  volume    = {22},
  number    = {1-2},
  pages     = {110--122},
  year      = {2006},
  publisher = {Elsevier}
}

@misc{bourdev.2006.bgil,
  author       = {Lubomir Bourdev and Hailin Jin},
  title        = {{B}oost {G}eneric {I}mage {L}ibrary},
  year         = {2006},
  howpublished = {{A}dobe stlab},
  note         = {Available at \url{https://stlab.adobe.com/gil/index.html}}
}

@article{bourdev.2011.runtimedispatch,
  title    = {Efficient run-time dispatching in generic programming with
              minimal code bloat},
  journal  = {Science of Computer Programming},
  volume   = {76},
  number   = {4},
  pages    = {243 - 257},
  year     = {2011},
  note     = {Special issue on library-centric software design (LCSD 2006)},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2008.06.003},
  url      = {http://www.sciencedirect.com/science/article/pii/S0167642308000634},
  author   = {Lubomir Bourdev and Jaakko Järvi},
  keywords = {Generic programming, C++ templates, Template bloat, Template
              metaprogramming}
}

@article{bradski.2000.opencv,
  author               = {Bradski, G.},
  citeulike-article-id = {2236121},
  journal              = {Dr. Dobb's Journal of Software Tools},
  keywords             = {bibtex-import},
  posted-at            = {2008-01-15 19:21:54},
  priority             = {4},
  title                = {{The OpenCV Library}},
  year                 = {2000}
}

@inproceedings{brown.2019.heterogeneous,
  author    = {Brown, Gordon and Reyes, Ruyman and Wong, Michael},
  title     = {Towards Heterogeneous and Distributed Computing in C++},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  series    = {IWOCL'19},
  year      = {2019},
  isbn      = {978-1-4503-6230-6},
  location  = {Boston, MA, USA},
  pages     = {18:1--18:5},
  articleno = {18},
  numpages  = {5},
  url       = {http://doi.acm.org/10.1145/3318170.3318196},
  doi       = {10.1145/3318170.3318196},
  acmid     = {3318196},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {C++, concurrency, distributed programming models, executors,
                heterogeneous programming, parallelism}
}

@misc{carlinet.2018.pylena,
  author       = {Edwin Carlinet and others},
  title        = {{P}ylena: a Modern {C}++ Image Processing Generic
                 Library},
  year         = {2018},
  howpublished = {{EPITA} Research and Developement Laboratory},
  note         = {Available at \url{https://gitlab.lrde.epita.fr/olena/pylene}}
}

@misc{carter.2018.concepts,
  title        = {Standard Library Concepts},
  author       = {Casey Carter and Eric Niebler},
  year         = {2018},
  key          = {P0898r3},
  month        = {06},
  organization = {WG21},
  url          = {https://wg21.link/p0898r3}
}

@misc{coeurjolly.2016.dgtal,
  title  = {DGtal: Digital geometry tools and algorithms library},
  author = {Coeurjolly, D and Lachaud, JO and Kerautret, B},
  year   = {2016}
}

@inproceedings{czarnecki.2000.generative,
  author    = {Czarnecki, Krzysztof and Eisenecker, Ulrich and Gl{\"u}ck,
                Robert and Vandevoorde, David and Veldhuizen, Todd},
  editor    = {Jazayeri, Mehdi and Loos, R{\"u}diger G. K. and Musser, David
                R.},
  title     = {Generative Programming and Active Libraries},
  booktitle = {Generic Programming},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {25--39},
  abstract  = {We describe generative programming, an approach to generating
                customized programming components or systems, and active
                libraries, which are based on this approach. In contrast to
                conventional libraries, active libraries may contain
                metaprograms that implement domain-specific code generation,
                optimizations, debugging, profiling and testing. Several working
                examples (Blitz++, GMCL, Xroma) are presented to illustrate the
                potential of active libraries. We discuss relevant
                implementation technologies.},
  isbn      = {978-3-540-39953-7},
  url       = {http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.646.8822&rep=rep1&type=pdf}
}

@inproceedings{darbon.2002.ismm,
  author       = {J\'er\^ome Darbon and Thierry G\'eraud and Alexandre
                  Duret-Lutz},
  title        = {Generic implementation of morphological image operators},
  booktitle    = {Mathematical Morphology, Proceedings of the 6th
                  International Symposium (ISMM)},
  pages        = {175--184},
  year         = 2002,
  address      = {Sydney, Australia},
  month        = apr,
  publisher    = {CSIRO Publishing},
  abstract     = {Several libraries dedicated to mathematical morphology
                  exist. But they lack genericity, that is to say, the
                  ability for operators to accept input of different natures
                  ---2D binary images, graphs enclosing floating values, etc.
                  We describe solutions which are integrated in Olena, a
                  library providing morphological operators. We demonstrate
                  with some examples that translating mathematical formulas
                  and algorithms into source code is made easy and safe with
                  Olena. Moreover, experimental results show that no extra
                  costs at run-time are induced.},
  lrdeprojects = {Olena}
}

@inproceedings{darbon.2004.ecoopphd,
  author       = {J\'er\^ome Darbon and Thierry G\'eraud and Patrick Bellot},
  title        = {Generic algorithmic blocks dedicated to image processing},
  booktitle    = {Proceedings of the ECOOP Workshop for PhD Students},
  year         = 2004,
  address      = {Oslo, Norway},
  month        = jun,
  abstract     = {This paper deals with the implementation of algorithms in
                  the specific domain of image processing. Although many
                  image processing libraries are available, they generally
                  lack genericity and flexibility. Many image processing
                  algorithms can be expressed as compositions of elementary
                  algorithmic operations referred to as blocks. Implementing
                  these compositions is achieved using generic programming.
                  Our solution is compared to previous ones and we
                  demonstrate it on a class image processing algorithms.},
  lrdeprojects = {Olena},
  lrdenewsdate = {2004-03-10}
}

@inproceedings{dehnert.1998.fundamentals,
  title        = {Fundamentals of Generic Programming},
  author       = {James C. Dehnert and Alexander Stepanov},
  booktitle    = {Generic Programming},
  errbooktitle = {Intl. Symp. on Symbolic and Algebraic Computation},
  optmonth     = {apr},
  year         = 2000,
  series       = {LNCS},
  volume       = {1766},
  pages        = {1--11},
  organization = {Springer}
}

@inproceedings{duretlutz.2000.olena,
  title        = {Olena: a component-based platform for image processing,
                  mixing generic, generative and OO programming},
  author       = {Duret-Lutz, Alexandre},
  booktitle    = {symposium on Generative and Component-Based Software
                  Engineering, Young Researchers Workshop},
  volume       = {10},
  year         = {2000},
  organization = {Citeseer}
}

@inproceedings{esterie.2014.boostsimd,
  author    = {Est{\'e}rie, Pierre and Falcou, Joel and Gaunard, Mathias and
                Laprest{\'e}, Jean-Thierry},
  title     = {Boost.SIMD: Generic Programming for Portable SIMDization},
  booktitle = {Proceedings of the 2014 Workshop on Programming Models for
                SIMD/Vector Processing},
  series    = {WPMVP '14},
  year      = {2014},
  isbn      = {978-1-4503-2653-7},
  location  = {Orlando, Florida, USA},
  pages     = {1--8},
  numpages  = {8},
  url       = {http://doi.acm.org/10.1145/2568058.2568063},
  doi       = {10.1145/2568058.2568063},
  acmid     = {2568063},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {SIMD, c++, generic programming, template meta-programming}
}

@book{etter.1993.engineering,
  title     = {Engineering problem solving with MATLAB},
  author    = {Etter, Delores M and Etter, Dolores M and Etter, Delores M},
  volume    = {2},
  year      = {1993},
  publisher = {Prentice Hall Englewood cliffs, New Jersey 07632}
}

@book{etter.2002.introduction,
  title     = {Introduction to MATLAB},
  author    = {Etter, Delores M and Kuncicky, David C and Hull, Douglas W},
  year      = {2002},
  publisher = {Prentice Hall}
}

@misc{fog.2013.vcl,
  title  = {{C}++ vector class library},
  author = {Fog, Agner},
  note   = {\url{http://www.agner.org/optimize/vectorclass.pdf}},
  pages  = {33},
  year   = {2013}
}

@misc{froment.2004.megawave2,
  title  = {MegaWave2 user's guide},
  author = {Froment, Jacques},
  year   = {2004}
}

@inproceedings{froment.2012.megawave,
  title       = {{MegaWave}},
  author      = {Froment, Jacques},
  url         = {https://hal.archives-ouvertes.fr/hal-00907378},
  booktitle   = {{IPOL 2012 Meeting on Image Processing Libraries}},
  address     = {France},
  year        = {2012},
  month       = Jun,
  hal_id      = {hal-00907378},
  hal_version = {v1}
}

@book{gamma.1995.design,
  title     = {Design patterns: elements of reusable object-oriented software},
  author    = {Erich Gamma},
  year      = {1995},
  publisher = {Pearson Education India}
}

@inproceedings{garrigues.2014.video++,
  title        = {Video++, a modern image and video processing {C}++
                  framework},
  author       = {Matthieu Garrigues and Antoine Manzanera},
  booktitle    = {Conference on Design and Architectures for Signal and Image
  Processing (DASIP)},
  pages        = {1--6},
  year         = {2014},
  organization = {IEEE}
}

@incollection{geraud.2010.book,
  author       = {Thierry G\'eraud and Hugues Talbot and Marc Van
                  Droogenbroeck},
  title        = {Algorithms for Mathematical Morphology},
  booktitle    = {Mathematical Morphology---From Theory to Applications},
  pages        = {323--353},
  publisher    = {Wiley-ISTE},
  year         = 2010,
  editor       = {Laurent Najman and Hugues Talbot},
  isbn         = {978-1-84821-215-2},
  month        = jul,
  url          = {http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1848212151.html},
  lrdekeywords = {Image},
  crossref     = {najman.2013.mathematical}
}

@phdthesis{geraud.2012.hdr,
  author      = {Thierry G\'eraud},
  title       = {Outil logiciel pour le traitement d'images:
                  Biblioth\`eque, paradigmes, types et algorithmes},
  school      = {Universit\'e Paris-Est},
  year        = 2012,
  month       = jun,
  lrdeproject = {Olena},
  type        = {Habilitation Thesis},
  note        = {In French},
  lrdepaper   = {http://www.lrde.epita.fr/~theo/papers/geraud.2012.hdr.pdf},
  lrdeslides  = {http://www.lrde.epita.fr/~theo/slides/geraud.2012.hdr_slides.pdf}
}

@inproceedings{geraud.2000.europlop,
  author       = {Thierry G\'eraud and Alexandre Duret-Lutz},
  title        = {Generic programming redesign of patterns},
  booktitle    = {Proceedings of the 5th European Conference on Pattern
                  Languages of Programs (EuroPLoP)},
  year         = 2000,
  month        = jul,
  address      = {Irsee, Germany},
  pages        = {283--294},
  editors      = {M. Devos and A. R\"uping},
  publisher    = {UVK, Univ. Verlag, Konstanz},
  lrdeprojects = {Software},
  abstract     = {This pattern faces the problem of improving the
                  performances of design patterns when they are involved in
                  intensive algorithms. Generic programming is a paradigm in
                  which most classes and procedures are parameterized, thus
                  leading to the construction of general and efficient
                  software components. We demonstrate that some design
                  patterns from Gamma et al. can be translated into this
                  paradigm while handling operation polymorphism by
                  parametric polymorphism. We thus preserve their modularity
                  and reusability properties but we avoid the performance
                  penalty due to their dynamic behavior, which is a critical
                  issue in numerical computing.},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/europlop00.pdf},
  lrdekeywords = {Software engineering}
}

@inproceedings{geraud.2000.icpr,
  author       = {Thierry G\'eraud and Yoann Fabre and Alexandre Duret-Lutz
                  and Dimitri Papadopoulos-Orfanos and Jean-Fran\c{c}ois
                  Mangin},
  title        = {Obtaining genericity for image processing and pattern
                  recognition algorithms},
  booktitle    = {Proceedings of the 15th International Conference on
                  Pattern Recognition (ICPR)},
  year         = 2000,
  month        = sep,
  address      = {Barcelona, Spain},
  volume       = 4,
  pages        = {816--819},
  publisher    = {IEEE Computer Society},
  lrdeprojects = {Olena},
  abstract     = {Algorithm libraries dedicated to image processing and
                  pattern recognition are not reusable; to run an algorithm
                  on particular data, one usually has either to rewrite the
                  algorithm or to manually ``copy, paste, and modify''. This
                  is due to the lack of genericity of the programming
                  paradigm used to implement the libraries. In this paper, we
                  present a recent paradigm that allows algorithms to be
                  written once and for all and to accept input of various
                  types. Moreover, this total reusability can be obtained
                  with a very comprehensive writing and without significant
                  cost at execution, compared to a dedicated algorithm. This
                  new paradigm is called ``generic programming'' and is fully
                  supported by the C++ language. We show how this paradigm
                  can be applied to image processing and pattern recognition
                  routines. The perspective of our work is the creation of a
                  generic library.}
}

@misc{geraud.2006.scoop-pres,
  author       = {Thierry G\'eraud},
  title        = {Advanced Static Object-Oriented Programming Features: A
                  Sequel to {SCOOP}},
  howpublished = {\url{http://www.lrde.epita.fr/people/theo/pub/olena/olena-06-jan.pdf}},
  month        = jan,
  year         = 2006,
  project      = {Olena},
  urllrde      = {200601-TR}
}

@inproceedings{geraud.2008.mpool,
  author       = {Thierry G\'eraud and Roland Levillain},
  title        = {Semantics-Driven Genericity: A Sequel to the Static {C++}
                  Object-Oriented Programming Paradigm ({SCOOP 2})},
  booktitle    = {Proceedings of the 6th International Workshop on
                  Multiparadigm Programming with Object-Oriented Languages
                  (MPOOL)},
  year         = 2008,
  address      = {Paphos, Cyprus},
  month        = jul,
  lrdeprojects = {Olena},
  abstract     = {Classical (unbounded) genericity in \Cxx{}03 defines the
                  interactions between generic data types and algorithms in
                  terms of concepts. Concepts define the requirements over a
                  type (or a parameter) by expressing constraints on its
                  methods and dependent types (typedefs). The upcoming
                  \Cxx{}0x standard will promote concepts from abstract
                  entities (not directly enforced by the tools) to language
                  constructs, enabling compilers and tools to perform
                  additional checks on generic constructs as well as enabling
                  new features (e.g., concept-based overloading). Most modern
                  languages support this notion of signature on generic
                  types. However, generic types built on other types and
                  relying on concepts to both ensure type conformance and
                  drive code specialization, restrain the interface and the
                  implementation of the newly created type: specific methods
                  and associated types not mentioned in the concept will not
                  be part of the new type. The paradigm of concept-based
                  genericity lacks the required semantics to transform types
                  while retaining or adapting their intrinsic capabilities.
                  We present a new form of semantically-enriched genericity
                  allowing static generic type transformations through a
                  simple form of type introspection based on type metadata
                  called properties. This approach relies on a new Static
                  \Cxx Object-Oriented Programming (SCOOP) paradigm, and is
                  adapted to the creation of generic and efficient libraries,
                  especially in the field of scientific computing. Our
                  proposal uses a metaprogramming facility built into a \Cxx
                  library called Static, and doesn't require any language
                  extension nor additional processing (preprocessor,
                  transformation tool).},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/geraud.08.mpool.pdf},
  lrdenewsdate = {2008-05-26}
}

@misc{geraud.2012.ipolmeeting,
  author       = {Thierry G\'eraud and Roland Levillain and Guillaume Lazzara},
  title        = {The {M}ilena Image Processing Library},
  howpublished = {{IPOL} meeting, {ENS} Cachan, France},
  month        = {June},
  year         = {2012},
  url          = {https://www.lrde.epita.fr/~theo/talks/geraud.2012.ipol_talk.pdf}
}

@misc{geraud.2018.gtgdmm,
  author       = {Thierry G\'eraud and Edwin Carlinet},
  title        = {A Modern {C++} Library for Generic and Efficient Image
                  Processing},
  howpublished = {Journ\'ee du Groupe de Travail de G\'eom\'etrie Discrète et
                  Morphologie Math\'ematique, Lyon, France},
  month        = {06},
  year         = {2018},
  url          = {https://www.lrde.epita.fr/~theo/talks/geraud.2018.gtgdmm_talk.pdf}
}

@article{gibbons.2007.datatype,
  title     = {Datatype-Generic Programming},
  author    = {Gibbons, Jeremy},
  journal   = {Datatype-Generic Programming: International Spring School,
              {SSDGP} 2006, Nottingham, {UK}, April 24-27, 2006, Revised
              Lectures},
  volume    = {4719},
  pages     = {1},
  year      = {2007},
  publisher = {Springer Science \& Business Media}
}

@inproceedings{gossec.2019.pybind,
  title     = {Binding a high-performance {C}++ image processing library to
                {P}ython},
  author    = {Celian Gossec},
  booktitle = {Student LRDE tech reports},
  year      = {2019}
}

@article{guelton.2015.pythran,
  title     = {{P}ythran: Enabling static optimization of scientific python
              programs},
  author    = {Guelton, Serge and Brunet, Pierrick and Amini, Mehdi and Merlini,
              Adrien and Corbillon, Xavier and Raynaud, Alan},
  journal   = {Computational Science \& Discovery},
  volume    = {8},
  number    = {1},
  pages     = {014001},
  year      = {2015},
  publisher = {IOP Publishing}
}

@misc{guennebaud.2010.eigen,
  author       = {Ga\"{e}l Guennebaud and Beno\^{i}t Jacob and others},
  title        = {Eigen v3},
  year         = {2010},
  howpublished = {http://eigen.tuxfamily.org},
  note         = {Available at \url{http://eigen.tuxfamily.org}}
}

@article{haralick.1977.imageaccessprotocol,
  author   = {R. M. {Haralick}},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Image Access Protocol for Image Processing Software},
  year     = {1977},
  volume   = {SE-3},
  number   = {2},
  pages    = {190-192},
  abstract = {During the past decade a number of multiimage picture processing
              software packages have been put together. However, only a few of
              the references to picture processing systems discuss image data
              structure or input/output routines. This correspondence is a first
              step in a direction toward getting a communication process started
              by suggesting some specifications for a multiimage data format and
              standard input/output interface routines to access the image
              data.},
  keywords = {Digital image processing; image processing; software; Access
              protocols; Image processing; Image segmentation; Data structures;
              Spatial resolution; Software packages; Communication standards;
              Laboratories; Image resolution; Electromagnetic launching; Digital
              image processing; image processing; software},
  doi      = {10.1109/TSE.1977.231124},
  issn     = {2326-3881},
  month    = {March}
}

@manual{ibanez.2003.ITKSoftwareGuide,
  title        = {The {ITK} {S}oftware {G}uide},
  author       = {Ibanez, L. and Schroeder, W. and Ng, L. and Cates, J.},
  organization = {Kitware, Inc.},
  edition      = {First},
  year         = {2003},
  note         = {ISBN 1-930934-10-6},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf}
}

@manual{ibanez.2005.ITKSoftwareGuideSecondEdition,
  title        = {The {ITK} {S}oftware {G}uide},
  author       = {Ibanez, L. and Schroeder, W. and Ng, L. and Cates, J.},
  organization = {Kitware, Inc.},
  edition      = {Second},
  year         = {2005},
  note         = {ISBN 1-930934-15-7},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf}
}

@misc{iglberger.2012.blaze,
  author       = {Klaus {Iglberger}},
  title        = {Blaze C++ Linear Algebra Library},
  howpublished = {https://bitbucket.org/blaze-lib},
  year         = {2012}
}

@article{iglberger.2012_1.blaze,
  author  = {Klaus {Iglberger} and Georg {Hager} and Jan {Treibig} and Ulrich
              {R{\"u}de}},
  title   = {Expression Templates Revisited: A Performance Analysis of Current
              Methodologies},
  journal = {SIAM Journal on Scientific Computing},
  year    = {2012},
  volume  = {34(2)},
  pages   = {C42--C69}
}

@inproceedings{iglberger2012_2.blaze,
  author    = {Klaus {Iglberger} and Georg {Hager} and Jan {Treibig} and
                Ulrich {R{\"u}de}},
  title     = {High Performance Smart Expression Template Math Libraries},
  booktitle = {Proceedings of the 2nd International Workshop on New Algorithms
                and Programming Models for the Manycore Era (APMM 2012) at HPCS
                2012},
  year      = 2012
}

@misc{jakob.2017.pybind11,
  title  = {pybind11—Seamless operability between C++ 11 and Python},
  author = {Jakob, Wenzel and Rhinelander, Jason and Moldovan, Dean},
  year   = {2017},
  note   = {https://github.com/pybind/pybind11}
}

@inproceedings{jarvi.2006.specialization,
  author    = {J\"{a}rvi, Jaakko and Gregor, Douglas and Willcock, Jeremiah
                and Lumsdaine, Andrew and Siek, Jeremy},
  title     = {Algorithm Specialization in Generic Programming: Challenges of
                Constrained Generics in C++},
  booktitle = {Proceedings of the 27th ACM SIGPLAN Conference on Programming
                Language Design and Implementation},
  series    = {PLDI '06},
  year      = {2006},
  isbn      = {1-59593-320-4},
  location  = {Ottawa, Ontario, Canada},
  pages     = {272--282},
  numpages  = {11},
  url       = {http://doi.acm.org/10.1145/1133981.1134014},
  doi       = {10.1145/1133981.1134014},
  acmid     = {1134014},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {concepts, constrained generics, generic programming, parametric
                polymorphism, specialization}
} 

@article{jarvi.2006.specialization-article,
  author     = {J\"{a}rvi, Jaakko and Gregor, Douglas and Willcock, Jeremiah
                and Lumsdaine, Andrew and Siek, Jeremy},
  title      = {Algorithm Specialization in Generic Programming: Challenges of
                Constrained Generics in C++},
  journal    = {SIGPLAN Not.},
  issue_date = {June 2006},
  volume     = {41},
  number     = {6},
  month      = jun,
  year       = {2006},
  issn       = {0362-1340},
  pages      = {272--282},
  numpages   = {11},
  url        = {http://doi.acm.org/10.1145/1133255.1134014},
  doi        = {10.1145/1133255.1134014},
  acmid      = {1134014},
  publisher  = {ACM},
  address    = {New York, NY, USA},
  keywords   = {concepts, constrained generics, generic programming, parametric
                polymorphism, specialization}
}

@manual{johnson.2015.itkvol1,
  author    = {Johnson, Hans J and McCormick, Matthew M and Ibanez, Luis},
  publisher = {Kitware, Inc.},
  title     = {Template:The ITK Software Guide Book 1: Introduction and
              Development Guidelines-Volume 1},
  year      = {2015}
}

@manual{johnson.2015.itkvol2,
  author    = {Johnson, Hans J and McCormick, Matthew M and Ibanez, Luis},
  publisher = {Kitware, Inc.},
  title     = {Template:The ITK Software Guide Book 2: Design and
              Functionality-Volume 2},
  year      = {2015}
}

@manual{johnson.2013.ITKSoftwareGuideThirdEdition,
  title        = {The {ITK} {S}oftware {G}uide},
  author       = {Johnson, Hans J. and McCormick, M. and Ib\'{a}{\~n}ez, L.
                   and The Insight Software Consortium},
  organization = {Kitware, Inc.},
  edition      = {Third},
  year         = {2013},
  note         = {\textit{In press}},
  url          = {http://www.itk.org/ItkSoftwareGuide.pdf}
}

@misc{jones.2006.scipy,
  author = {Eric Jones and Travis Oliphant and Pearu Peterson and others},
  title  = {{SciPy}: Open source scientific tools for {Python}},
  year   = {2001},
  url    = {http://www.scipy.org/}
}

@proceedings{kerautret.2018.rrprconf,
  editor    = {Bertrand Kerautret and Miguel Colom and Daniel Lopresti and
              Pascal Monasse and Hugues Talbot},
  title     = {Reproducible Research in Pattern Recognition - Second
              International Workshop, {RRPR} 2018, Beijing, China, August 20,
              2018, Revised Selected Papers},
  series    = {Lecture Notes in Computer Science},
  volume    = {11455},
  publisher = {Springer},
  year      = {2019}
}

@misc{kobalicek.2011.asmjit,
  title  = {asmjit-complete x86/x64 {JIT} assembler for {C}++ language},
  author = {Kobalicek, P},
  year   = {2011}
}

@misc{kolas.2000.gegl,
  title  = {{G}eneric {G}raphic {L}ibrary},
  year   = {2000},
  author = {Kol{\r{a}}s, {\O}yvind and et al.},
  note   = {Available at \url{http://www.gegl.org}}
}

@misc{kothe.2011.generic.INTROUVABLE,
  title  = {Generic programming for computer vision: The vigra computer vision
            library},
  author = {K{\"o}the, Ullrich},
  year   = {2011}
}

@article{kothe.2011.generic,
  author  = {Ullrich K{\"o}the},
  title   = {{STL}-Style Generic Programming with Images},
  journal = {C++ Report Magazine},
  year    = {2000},
  volume  = {12},
  number  = {1},
  pages   = {24--30},
  note    = {{\small\url{https://ukoethe.github.io/vigra}}}
}

@inproceedings{levillain.2009.ismm,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {{Milena}: Write Generic Morphological Algorithms Once, Run
                  on Many Kinds of Images},
  booktitle    = {Mathematical Morphology and Its Application to Signal and
                  Image Processing -- Proceedings of the Ninth International
                  Symposium on Mathematical Morphology (ISMM)},
  pages        = {295--306},
  year         = 2009,
  editor       = {Michael H. F. Wilkinson and Jos B. T. M. Roerdink},
  series       = {Lecture Notes in Computer Science},
  address      = {Groningen, The Netherlands},
  month        = aug,
  publisher    = {Springer Berlin / Heidelberg},
  volume       = 5720,
  lrdeprojects = {Olena},
  abstract     = {We present a programming framework for discrete
                  mathematical morphology centered on the concept of
                  genericity. We show that formal definitions of
                  morphological algorithms can be translated into actual
                  code, usable on virtually any kind of compatible images,
                  provided a general definition of the concept of image is
                  given. This work is implemented in Milena, a generic,
                  efficient, and user-friendly image processing library.},
  keywords     = {mathematical morphology, image processing operator,
                  genericity, programming},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.09.ismm.slides.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.09.ismm.pdf},
  lrdenewsdate = {2009-04-09}
}

@inproceedings{levillain.2010.icip,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Why and How to Design a Generic and Efficient Image
                  Processing Framework: The Case of the {Milena} Library},
  booktitle    = {Proceedings of the IEEE International Conference on Image
                  Processing (ICIP)},
  pages        = {1941--1944},
  year         = 2010,
  address      = {Hong Kong},
  month        = sep,
  lrdeprojects = {Olena},
  abstract     = {Most image processing frameworks are not generic enough to
                  provide true reusability of data structures and algorithms.
                  In fact, genericity allows users to write and experiment
                  virtually any method on any compatible input(s). In this
                  paper, we advocate the use of generic programming in the
                  design of image processing software, while preserving
                  performances close to dedicated code. The implementation of
                  our proposal, Milena, a generic and efficient library,
                  illustrates the benefits of our approach.},
  keywords     = {Genericity, Image Processing, Software Design,
                  Reusability, Efficiency},
  lrdeposter   = {http://www.lrde.epita.fr/dload/papers/levillain.10.icip.poster.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.10.icip.pdf},
  lrdenewsdate = {2010-05-26}
}

@inproceedings{levillain.2010.wadgmm,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Writing Reusable Digital Geometry Algorithms in a Generic
                  Image Processing Framework},
  booktitle    = {Proceedings of the Workshop on Applications of Digital
                  Geometry and Mathematical Morphology (WADGMM)},
  pages        = {96--100},
  year         = 2010,
  address      = {Istanbul, Turkey},
  month        = aug,
  url          = {http://mdigest.jrc.ec.europa.eu/wadgmm2010/},
  lrdeprojects = {Olena},
  abstract     = {Digital Geometry software should reflect the generality of
                  the underlying mathematics: mapping the latter to the
                  former requires genericity. By designing generic solutions,
                  one can effectively reuse digital geometry data structures
                  and algorithms. We propose an image processing framework
                  centered on the Generic Programming paradigm in which an
                  algorithm on the paper can be turn into a single code,
                  written once and usable with various input types. This
                  approach enables users to design and implement new methods
                  at a lower cost, try cross-domain experiments and help
                  generalize results.},
  keywords     = {Generic Programming, Interface, Skeleton, Complex},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.10.wadgmm.slides.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.10.wadgmm.pdf},
  lrdenewsdate = {2012-07-30}
}

@inproceedings{levillain.2011.gretsi,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Une approche g\'en\'erique du logiciel pour le traitement
                  d'images pr\'eservant les performances},
  booktitle    = {Proceedings of the 23rd Symposium on Signal and Image
                  Processing (GRETSI)},
  category     = {national},
  year         = 2011,
  address      = {Bordeaux, France},
  month        = sep,
  note         = {In French.},
  lrdeprojects = {Olena},
  abstract     = {De plus en plus d'outils logiciels modernes pour le
                  traitement d'images sont con\c{c}us en prenant en compte le
                  probl\`eme de la g\'en\'ericit\'e du code, c'est-\`a-dire la
                  possibilit\'e d'\'ecrire des algorithmes r\'eutilisables,
                  compatibles avec de nombreux types d'entr\'ees. Cependant, ce
                  choix de conception se fait souvent au d\'etriment des
                  performances du code ex\'ecut\'e. Du fait de la grande
                  vari\'et\'e des types d'images existants et de la
                  n\'ecessit\'e d'avoir des impl\'ementations rapides,
                  g\'en\'ericit\'e et performance apparaissent comme des
                  qualit\'es essentielles du logiciel en traitement d'images.
                  Cet article pr\'esente une approche pr\'eservant les
                  performances dans un framework logiciel g\'en\'erique tirant
                  parti des caract\'eristiques des types de donn\'ees
                  utilis\'es. Gr\^ace \`a celles-ci, il est possible d'\'ecrire
                  des variantes d'algorithmes g\'en\'eriques offrant un
                  compromis entre g\'en\'ericit\'e et performance. Ces
                  alternatives sont capables de pr\'eserver une partie des
                  aspects g\'en\'eriques d'origine tout en apportant des gains
                  substantiels \`a l'ex\'ecution. D'apr\`es nos essais, ces
                  optimisations g\'en\'eriques fournissent des performances
                  supportant la comparaison avec du code d\'edi\'e, allant
                  parfois m\^eme jusqu'\`a surpasser des routines optimis\'ees
                  manuellement.},
  lrdeposter   = {http://www.lrde.epita.fr/dload/papers/levillain.11.gretsi.poster.pdf},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.11.gretsi.pdf},
  lrdenewsdate = {2011-05-13}
}

@phdthesis{levillain.2011.phd,
  author       = {Roland Levillain},
  title        = {Towards a Software Architecture for Generic Image
                  Processing},
  school       = {Universit\'e Paris-Est},
  year         = 2011,
  address      = {Marne-la-Vall\'ee, France},
  month        = nov,
  abstract     = {In the context of software engineering for image
                  processing (IP), we consider the notion of reusability of
                  algorithms. In many software tools, an algorithm's
                  implementation often depends on the type of processed data.
                  In a broad definition, discrete digital images may have
                  various forms---classical 2D images, 3D volumes,
                  non-regular graphs, cell complexes, and so on---thus
                  leading to a combinatorial explosion of the theoretical
                  number of implementations.\\ Generic programming (GP) is a
                  framework suited to the development of reusable software
                  tools. We present a programming paradigm based on GP
                  designed for the creation of scientific software such as IP
                  tools. This approach combines the benefits of reusability,
                  expressive power, extensibility, and efficiency.\\ We then
                  propose a software architecture for IP using this
                  programming paradigm based on a generic IP library. The
                  foundations of this framework define essential IP concepts,
                  enabling the development of algorithms compatible with many
                  image types.\\ We finally present a strategy to build
                  high-level tools on top of this library, such as bridges to
                  dynamic languages or graphical user interfaces. This
                  mechanism has been designed to preserve the genericity and
                  efficiency of the underlying software tools, while making
                  them simpler to use and more flexible.},
  lrdepaper    = {http://www.lrde.epita.fr/~roland/phd/levillain-phd.pdf},
  lrdeprojects = {Olena}
}

@inproceedings{levillain.2012.wadgmm-lncs,
  oldkeys      = {levillain.12.lncs},
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman},
  title        = {Writing Reusable Digital Topology Algorithms in a Generic
                  Image Processing Framework},
  booktitle    = {WADGMM 2010},
  pages        = {140--153},
  year         = 2012,
  editor       = {Ullrich K\"othe and Annick Montanvert and Pierre Soille},
  publisher    = {Springer-Verlag Berlin Heidelberg},
  series       = {Lecture Notes in Computer Science},
  volume       = 7346,
  lrdeprojects = {Olena},
  abstract     = {Digital Topology software should reflect the generality of
                  the underlying mathematics: mapping the latter to the
                  former requires genericity. By designing generic solutions,
                  one can effectively reuse digital topology data structures
                  and algorithms. We propose an image processing framework
                  focused on the Generic Programming paradigm in which an
                  algorithm on the paper can be turned into a single code,
                  written once and usable with various input types. This
                  approach enables users to design and implement new methods
                  at a lower cost, try cross-domain experiments and help
                  generalize results.},
  keywords     = {Generic Programming, Interface, Skeleton, Complex},
  annote       = {This paper is an extended version of levillain.10.wadgmm
                  (201008-WADGMM).},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.12.wadgmm-lncs.pdf},
  lrdenewsdate = {2012-08-08}
}

@inproceedings{levillain.2014.ciarp,
  author       = {Roland Levillain and Thierry G\'eraud and Laurent Najman
                  and Edwin Carlinet},
  title        = {Practical Genericity: Writing Image Processing Algorithms
                  Both Reusable and Efficient},
  booktitle    = {Progress in Pattern Recognition, Image Analysis, Computer
                  Vision, and Applications -- Proceedings of the 19th
                  Iberoamerican Congress on Pattern Recognition (CIARP)},
  address      = {Puerto Vallarta, Mexico},
  month        = nov,
  year         = {2014},
  pages        = {70--79},
  editor       = {Eduardo Bayro and Edwin Hancock},
  publisher    = {Springer-Verlag},
  series       = {Lecture Notes in Computer Science},
  volume       = {8827},
  lrdeprojects = {Olena},
  abstract     = {An important topic for the image processing and pattern
                  recognition community is the construction of open source
                  and efficient libraries. An increasing number of software
                  frameworks are said to be generic: they allow users to
                  write reusable algorithms compatible with many input image
                  types. However, this design choice is often made at the
                  expense of performance. We present an approach to preserve
                  efficiency in a generic image processing framework, by
                  leveraging data types features. Variants of generic
                  algorithms taking advantage of image types properties can
                  be defined, offering an adjustable trade-off between
                  genericity and efficiency. Our experiments show that these
                  generic optimizations can match dedicated code in terms of
                  execution times, and even sometimes perform better than
                  routines optimized by hand. Digital Topology software
                  should reflect the generality of the underlying
                  mathematics: mapping the latter to the former requires
                  genericity. By designing generic solutions, one can
                  effectively reuse digital topology data structures and
                  algorithms. We propose an image processing framework
                  focused on the Generic Programming paradigm in which an
                  algorithm on the paper can be turned into a single code,
                  written once and usable with various input types. This
                  approach enables users to design and implement new methods
                  at a lower cost, try cross-domain experiments and help
                  generalize results.},
  keywords     = {Generic Programming, Image Processing, Performance,
                  Olena},
  lrdepaper    = {http://www.lrde.epita.fr/dload/papers/levillain.14.ciarp.pdf},
  lrdeslides   = {http://www.lrde.epita.fr/dload/papers/levillain.14.ciarp.slides.pdf},
  lrdenewsdate = {2014-09-10}
}

@article{liu.2019.sunwayimg,
  author   = {R. {Liu} and Y. {Liu} and M. {Zhao} and K. {Song} and D. {Qian}},
  journal  = {IEEE Access},
  title    = {SunwayImg: A Parallel Image Processing Library for the Sunway
              Many-Core Processor},
  year     = {2019},
  volume   = {7},
  number   = {},
  pages    = {128555-128569},
  abstract = {Many big data applications need to process massive images and
              videos, while the performance of image processing is far from
              reaching requirements. This paper proposes the SunwayImg, a
              parallel image processing library, to support image-related
              applications on the Sunway many-core processor as well as the
              Sunway TaihuLight supercomputer. The SunwayImg integrates three
              kinds of image algorithms: fundamental algorithms to support basic
              image operations on the Sunway processor, widely used image
              feature extraction algorithms and a typical neural network model
              DBN. In addition, to parallelize various kinds of image algorithms
              efficiently on the Sunway processor, we propose a three-tier
              parallelization strategy as well as fine-grained parallelization
              inside core-groups. Finally, we accomplish implementation of the
              SunwayImg and evaluate it on the Sunway TaihuLight supercomputer
              to verify its effectiveness and performance.},
  keywords = {Big Data; feature extraction; image processing;
              multiprocessing systems; neural nets; parallel machines; image
              feature extraction algorithms; three-tier parallelization
              strategy; fine-grained parallelization; SunwayImg; Sunway
              TaihuLight supercomputer; parallel image processing library;
              Sunway many-core processor; big data applications; image-related
              applications; image operations; neural network model; Libraries;
              Computer architecture; Feature extraction; Supercomputers;
              Software; Neural networks; Image library; high performance
              computing; parallel computing; deep neural networks},
  doi      = {10.1109/ACCESS.2019.2939940},
  issn     = {2169-3536},
  month    = {}
}

@inproceedings{matuska.2012.bench,
  author    = {S. {Matuska} and R. {Hudec} and M. {Benco}},
  booktitle = {2012 ELEKTRO},
  title     = {The comparison of CPU time consumption for image processing
                algorithm in Matlab and OpenCV},
  year      = {2012},
  volume    = {},
  number    = {},
  pages     = {75-78},
  abstract  = {In order to fill gap of growing demand for high efficient image
                and video processing, open source computer vision library
                (OpenCv) is way to deals with this task. Hence, this paper is
                about basic algorithm for image processing and their CPU time
                consumption in Matlab comparing with OpenCv. Algorithms are
                tested on images with resolution 3264×2448, 1920×1080, 1024×768
                and 220×260. Multi-processors computer and multi-threading
                programs are used to improve processing efficiency.},
  keywords  = {image processing; mathematics computing; microprocessor chips;
                multi-threading; CPU time consumption; image processing
                algorithm; Matlab; OpenCV; video processing; open source
                computer vision library; multi-processors computer;
                multi-threading programs; Application software; Instruction
                sets; Kernel; Image edge detection; Smoothing methods; Computer
                vision; OpenCV; Matlab; computer vision; mutli-threading},
  doi       = {10.1109/ELEKTRO.2012.6225575},
  issn      = {null},
  month     = {05}
}

@article{moisan.2005.modeling,
  title   = {Modeling and image processing},
  author  = {Moisan, Lionel},
  journal = {Lecture Notes of ENS Cachan edition},
  year    = {2005}
}

@book{moore.2017.matlab,
  title     = {MATLAB for Engineers},
  author    = {Moore, Holly},
  year      = {2017},
  publisher = {Pearson}
}

@inproceedings{musser.1988.generic,
  title        = {Generic programming},
  author       = {David R. Musser and Alexander A. Stepanov},
  booktitle    = {Intl. Symp. on Symbolic and Algebraic Computation},
  pages        = {13--25},
  year         = {1988},
  organization = {Springer}
}

@article{musser.1994.algorithm,
  author   = {Musser, David R. and Stepanov, Alexander A.},
  title    = {Algorithm-oriented generic libraries},
  journal  = {Software: Practice and Experience},
  volume   = {24},
  number   = {7},
  pages    = {623-642},
  keywords = {Generic algorithms, Algorithmic abstractions, Software libraries,
              Abstract data types, C+ +, Templates},
  doi      = {10.1002/spe.4380240703},
  url      = {https://onlinelibrary.wiley.com/doi/abs/10.1002/spe.4380240703},
  eprint   = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/spe.4380240703},
  abstract = {We outline an approach to construction of software
              libraries in which generic algorithms (algorithmic abstractions)
              play a more central role than in conventional software library
              technology or in the object-oriented programming paradigm. Our
              approach is to consider algorithms first, decide what types and
              access operations they need for efficient execution, and regard
              the types and operations as formal parameters that can be
              instantiated in many different ways, as long as the actual
              parameters satisfy the assumptions on which the correctness and
              efficiency of the algorithms are based. The means by which
              instantiation is carried out is language dependent; in the C + +
              examples in this paper, we instantiate generic algorithms by
              constructing classes that define the needed types and access
              operations. By use of such compile-time techniques and careful
              attention to algorithmic issues, it is possible to construct
              software components of broad utility with no sacrifice of
              efficiency.},
  year     = {1994}
}

@book{najman.2013.mathematical,
  title     = {Mathematical Morphology: From Theory to Applications},
  author    = {Najman, L. and Talbot, H.},
  isbn      = {9781118600856},
  series    = {ISTE},
  url       = {https://books.google.fr/books?id=9FUlX8YrRvMC},
  year      = {2013},
  publisher = {Wiley}
}

@misc{niebler.2014.ranges,
  title  = {Ranges for the Standard Library: Revision 1},
  author = {Eric Niebler, Sean Parent, Andrew Sutton},
  year   = {2014},
  key    = {D4128},
  month  = {10},
  url    = {https://ericniebler.github.io/std/wg21/D4128.html}
}

@misc{niebler.2018.deepranges,
  title        = {Deep Integration of the Ranges {TS}},
  author       = {Eric Niebler and Casey Carter},
  year         = {2018},
  key          = {p1037r0},
  pages        = {61--61},
  month        = {05},
  organization = {WG21},
  url          = {https://wg21.link/p1037r0}
}

@misc{niebler.2018.mergingranges,
  title        = {Merging the Ranges {TS}},
  author       = {Eric Niebler and Casey Carter},
  year         = {2018},
  key          = {p0896r1},
  pages        = {96--96},
  month        = {05},
  organization = {WG21},
  url          = {https://wg21.link/p0896r1}
}

@article{novak.1997.reuse,
  author   = {G. S. {Novak}},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Software reuse by specialization of generic procedures through
              views},
  year     = {1997},
  volume   = {23},
  number   = {7},
  pages    = {401-417},
  abstract = {A generic procedure can be specialized, by compilation through
              views, to operate directly on concrete data. A view is a
              computational mapping that describes how a concrete type
              implements an abstract type. Clusters of related views are needed
              for specialization of generic procedures that involve several
              types or several views of a single type. A user interface that
              reasons about relationships between concrete types and abstract
              types allows view clusters to be created easily. These techniques
              allow rapid specialization of generic procedures for
              applications.},
  keywords = {software reusability; abstract data types; partial evaluation
              (compilers); program compilers; user interfaces; software reuse;
              generic procedure specialization; views; computational mapping;
              concrete type; abstract data type; user interface; view clusters;
              partial evaluation; direct manipulation editor; Concrete;
              Software algorithms; Clustering algorithms; Programming
              profession; Object oriented programming; User interfaces;
              Application software; Costs; Production; Libraries},
  doi      = {10.1109/32.605759},
  issn     = {2326-3881},
  month    = {July}
}

@inproceedings{oezkan.2017.IPlibrary,
  author    = {M. A. {Oezkan} and O. {Reiche} and F. {Hannig} and J. {Teich}},
  booktitle = {FSP 2017; Fourth International Workshop on FPGAs for Software
                Programmers},
  title     = {A Highly Efficient and Comprehensive Image Processing Library
                for C++-based High-Level Synthesis},
  year      = {2017},
  volume    = {},
  number    = {},
  pages     = {1-10},
  abstract  = {Field Programmable Gate Arrays (FPGAs) are proved to be among
                the most suitable architectures for image processing
                applications. However, accelerating algorithms using FPGAs is a
                time-consuming task and needs expertise. Whereas the recent
                advancements in High-Level Synthesis (HLS) promise to solve this
                problem, today's HLS tools require apt hardware descriptions of
                algorithms to be able to provide favorable implementations. A
                solution is developing highly parameterizable and optimized HLS
                libraries for the fundamental image processing components.
                Another solution is providing a higher level of abstraction in
                the form of a Domain-Specific Language (DSL) and a corresponding
                efficient back end for hardware design. In this paper, we
                provide a highly efficient and parameterizable C++ library for
                image processing applications, which would be the cornerstone
                for both approaches. In our library, nodes of a stream-based
                data flow graph can be described as C++ objects for specified
                functions, and the whole application can be efficiently
                parallelized just by defining a global constant as the
                parallelization factor. Moreover, the key hardware design
                elements, i. e., line buffers and sliding windows with different
                border handling patterns, can be utilized individually to ease
                the design of more complicated applications.},
  keywords  = {},
  doi       = {},
  issn      = {null},
  month     = {Sep.}
}

@misc{olena.2000.www,
  author       = {EPITA Research and Developpement Laboratory (LRDE)},
  oldkeys      = {olena.net},
  title        = {The {Olena} image processing platform},
  key          = {Olena},
  year         = {2000},
  howpublished = {\url{http://olena.lrde.epita.fr}}
}

@misc{oliphant.2006.numpy,
  author       = {Travis Oliphant},
  title        = {{NumPy}: A guide to {NumPy}},
  year         = {2006},
  howpublished = {USA: Trelgol Publishing},
  url          = {http://www.numpy.org/}
}

@incollection{oram.2007.beautiful,
  title     = {Multidimensional Iterators in {N}um{P}y},
  chapter   = 19,
  booktitle = {Beautiful code},
  author    = {Travis E. Oliphant},
  editor    = {Andrew Oram and Greg Wilson},
  year      = 2007,
  publisher = {O'reilly Sebastopol, CA}
}

@book{part.1996.matlab,
  title     = {The MATLAB handbook},
  author    = {P{\"a}rt-Enander, Eva and Sj{\"o}berg, Anders and Melin, Bo and
              Isaksson, Pernilla},
  year      = {1996},
  publisher = {Addison-Wesley Harlow}
}

@article{peterson.2009.f2py,
  title     = {F2PY: a tool for connecting Fortran and Python programs},
  author    = {Peterson, Pearu},
  journal   = {International Journal of Computational Science and Engineering},
  volume    = {4},
  number    = {4},
  pages     = {296--305},
  year      = {2009},
  publisher = {Inderscience Publishers}
}


@article{piper.1985.data,
  title     = {Data structures for image processing in a {C} language and {U}nix
              environment},
  author    = {Jim Piper and Denis Rutovitz},
  journal   = {Pattern Recognition Letters},
  volume    = {3},
  number    = {2},
  pages     = {119--129},
  year      = {1985},
  publisher = {Elsevier}
}

@article{pirkelbauer.2010.multimethods,
  title    = {Design and evaluation of {C}++ open multi-methods},
  journal  = {Science of Computer Programming},
  volume   = {75},
  number   = {7},
  pages    = {638 - 667},
  year     = {2010},
  note     = {Generative Programming and Component Engineering (GPCE 2007)},
  issn     = {0167-6423},
  doi      = {https://doi.org/10.1016/j.scico.2009.06.002},
  url      = {http://www.sciencedirect.com/science/article/pii/S016764230900094X},
  author   = {Peter Pirkelbauer and Yuriy Solodkyy and Bjarne Stroustrup},
  keywords = {Multi-methods, Open-methods, Multiple dispatch, Binary method
              problem, Augmenting method problem, Object-oriented programming,
              Generic programming, C},
  abstract = {Multiple dispatch-the selection of a function to be invoked based
              on the dynamic type of two or more arguments-is a solution to
              several classical problems in object-oriented programming. Open
              multi-methods generalize multiple dispatch towards open-class
              extensions, which improve separation of concerns and provisions
              for retroactive design. We present the rationale, design,
              implementation, performance, programming guidelines, and
              experiences of working with a language feature, called open
              multi-methods, for C++. Our open multi-methods support both
              repeated and virtual inheritance. Our call resolution rules
              generalize both virtual function dispatch and overload resolution
              semantics. After using all information from argument types, these
              rules can resolve further ambiguities by using covariant return
              types. Care was taken to integrate open multi-methods with
              existing C++ language features and rules. We describe a model
              implementation and compare its performance and space requirements
              to existing open multi-method extensions and work-around
              techniques for C++. Compared to these techniques, our approach is
              simpler to use, catches more user mistakes, and resolves more
              ambiguities through link-time analysis, is comparable in memory
              usage, and runs significantly faster. In particular, the runtime
              cost of calling an open multi-method is constant and less than the
              cost of a double dispatch (two virtual function calls). Finally,
              we provide a sketch of a design for open multi-methods in the
              presence of dynamic loading and linking of libraries.}
}

@article{ragankelley.2013.halide,
  author  = {Jonathan Ragan-kelley and Connelly Barnes and Andrew Adams and
              Frédo Durand and Saman Amarasinghe and et al.},
  title   = {{H}alide: A Language and Compiler for Optimizing Parallelism,
              Locality, and Recomputation in Image Processing Pipelines},
  year    = {2013},
  journal = {PLDI 2013}
}

@book{redfern.2012.matlab,
  title     = {The MATLAB{\textregistered} 5 Handbook},
  author    = {Redfern, Darren and Campbell, Colin},
  year      = {2012},
  publisher = {Springer Science \& Business Media}
}

@article{roman.1998.digital,
  author   = {D. {Roman} and M. {Fisher} and J. {Cubillo}},
  journal  = {IEEE Transactions on Education},
  title    = {Digital image processing-an object-oriented approach},
  year     = {1998},
  volume   = {41},
  number   = {4},
  pages    = {331-333},
  abstract = {This paper presents a class library dedicated to digital image
              processing which provides resources for essential digital image
              processing operations. Besides its practical value, the class
              library is used to teach both object-oriented software engineering
              methodology and digital image processing. The resulting module can
              be accessed from independent specialized applications through its
              public interface while its implementation details are perfectly
              encapsulated. First of all it is used as the inner part of an
              integrated environment designed for students and researchers in
              the field of digital image processing. This software component was
              built aiming for both portability and extendibility. It contains
              attributes and methods that allow for a wide range of digital
              image processing algorithms: point and geometric operations;
              filter, edge detection, segmentation and texture operations; and
              fast Fourier transforms, discrete cosine transforms, and wavelet
              and Gabor transformations. All these can be used for image
              enhancement, restoration, compression, analysis, and synthesis.},
  keywords = {image processing; software engineering; engineering education;
              object-oriented programming; object-oriented approach; digital
              image processing; object-oriented software engineering;
              encapsulation; integrated environment; digital image processing
              algorithms; geometric operations; point operations; filter; edge
              detection; segmentation; texture operations; fast Fourier
              transforms; discrete cosine transforms; wavelet; Gabor
              transformations; image enhancement; image restoration; image
              compression; image analysis; image synthesis; Digital images;
              Software libraries; Software engineering; Application software;
              Digital filters; Gabor filters; Image edge detection; Image
              segmentation; Fast Fourier transforms; Discrete cosine
              transforms},
  doi      = {10.1109/13.728270},
  issn     = {1557-9638},
  month    = {Nov}
}

@inproceedings{roynard.2019.rrpr,
  author    = {Roynard, Micha{\"e}l and Carlinet, Edwin and G{\'e}raud,
                  Thierry},
  editor    = {Kerautret, Bertrand and Colom, Miguel and Lopresti, Daniel
                  and Monasse, Pascal and Talbot, Hugues},
  title     = {An Image Processing Library in Modern C++: Getting Simplicity
                  and Efficiency with Generic Programming},
  booktitle = {Reproducible Research in Pattern Recognition},
  year      = {2019},
  publisher = {Springer International Publishing},
  address   = {Cham},
  pages     = {121--137},
  abstract  = {As there are as many clients as many usages of an Image
                  Processing library, each one may expect different services
                  from it. Some clients may look for efficient and
                  production-quality algorithms, some may look for a large tool
                  set, while others may look for extensibility and genericity to
                  inter-operate with their own code base...but in most cases,
                  they want a simple-to-use and stable product. For a C++ Image
                  Processing library designer, it is difficult to conciliate
                  genericity, efficiency and simplicity at the same time. Modern
                  C++ (post 2011) brings new features for library developers
                  that will help designing a software solution combining those
                  three points. In this paper, we develop a method using these
                  facilities to abstract the library components and augment the
                  genericity of the algorithms. Furthermore, this method is not
                  specific to image processing; it can be applied to any C++
                  scientific library.},
  isbn      = {978-3-030-23987-9}
}

@article{sanderson.2016.armadillo,
  title     = {Armadillo: a template-based C++ library for linear algebra},
  author    = {Sanderson, Conrad and Curtin, Ryan},
  journal   = {Journal of Open Source Software},
  volume    = {1},
  number    = {2},
  pages     = {26},
  year      = {2016},
  publisher = {Journal of Open Source Software}
}

@article{sanderson.2019.practical,
  title     = {Practical Sparse Matrices in C++ with Hybrid Storage and
              Template-Based Expression Optimisation},
  author    = {Sanderson, Conrad and Curtin, Ryan},
  journal   = {Mathematical and Computational Applications},
  volume    = {24},
  number    = {3},
  pages     = {70},
  year      = {2019},
  publisher = {Multidisciplinary Digital Publishing Institute}
}

@misc{seymour.2009.concepts,
  title        = {{LWG} Papers to Re-Merge into {C}++0x After Removing
                  Concepts},
  author       = {Bill Seymour},
  year         = {2009},
  key          = {N2929},
  month        = {07},
  organization = {WG21},
  url          = {https://wg21.link/n2929}
}

@inproceeding{siek.2001.boostgraph,
  author    = {Jeremy Siek, Lie-Quan Lee, Andrew Lumsdaine},
  title     = {The {B}oost {G}raph library},
  year      = {2001},
  url       = {http://cds.cern.ch/record/1518180/files/0201729148_TOC.pdf},
  publisher = {Addison-Wesley}
}

@book{stepanov.2009.elements,
  author    = {Alexander Stepanov and Paul McJones},
  title     = {Elements of Programming},
  publisher = {Addison-Wesley Professional},
  year      = {2009},
  month     = {06},
  optnote   = {Decomposing programs into a system of algorithmic components}
}

@book{stroustrup.1995.design,
  author    = {Stroustrup, Bjarne},
  title     = {The Design and Evolution of {C}++},
  year      = {1994},
  isbn      = {0-201-54330-3},
  publisher = {ACM Press/Addison-Wesley Publishing Co.},
  address   = {New York, NY, USA}
}

@misc{stroustrup.2003.concepts,
  title        = {Concepts - {D}esign choices for template argument checking},
  author       = {Bjarne Stroustrup and Gabriel Dos Reis},
  year         = {2003},
  key          = {N1522},
  month        = {10},
  organization = {WG21},
  url          = {https://wg21.link/n1522}
}

@misc{sutton.2017.concepts,
  title        = {Working Draft, {C}++ extensions for Concepts},
  author       = {Andrew Sutton},
  year         = {2017},
  key          = {N4674},
  month        = {06},
  organization = {WG21},
  url          = {https://wg21.link/n4674}
}

@book{taylor.2004.intel,
  title     = {Intel integrated performance primitives},
  author    = {Taylor, Stewart},
  year      = {2004},
  publisher = {Intel Press}
}

@inproceedings{tschumperle.2012.cimg,
  title       = {{The CImg Library}},
  author      = {Tschumperl{\'e}, David},
  url         = {https://hal.archives-ouvertes.fr/hal-00927458},
  booktitle   = {{IPOL 2012 Meeting on Image Processing Libraries}},
  address     = {Cachan, France},
  pages       = {4 pp},
  year        = {2012},
  month       = Jun,
  keywords    = {Image Processing; C++ Library; Template-based programming;
                Genericity; Straightforwardness; Script language},
  pdf         = {https://hal.archives-ouvertes.fr/hal-00927458/file/tschumperle_ipol2012.pdf},
  hal_id      = {hal-00927458},
  hal_version = {v1}
}

@article{vanderwalt.2014.skimage,
  title    = {scikit-image: image processing in {P}ython},
  author   = {van der Walt, {S}t\'efan and {S}ch\"onberger, {J}ohannes {L}. and
             {Nunez-Iglesias}, {J}uan and {B}oulogne, {F}ran\c{c}ois and
             {W}arner, {J}oshua {D}. and {Y}ager, {N}eil and {G}ouillart,
             {E}mmanuelle and {Y}u, {T}ony and the scikit-image contributors},
  year     = {2014},
  month    = {6},
  keywords = {Image processing, Reproducible research, Education, Visualization,
             Open source, Python, Scientific programming},
  volume   = {2},
  pages    = {e453},
  journal  = {PeerJ},
  issn     = {2167-8359},
  url      = {https://doi.org/10.7717/peerj.453},
  doi      = {10.7717/peerj.453}
}

@article{vanherk.1992.localminmax,
  title    = {A fast algorithm for local minimum and maximum filters on
              rectangular and octagonal kernels},
  journal  = {Pattern Recognition Letters},
  volume   = {13},
  number   = {7},
  pages    = {517 - 521},
  year     = {1992},
  issn     = {0167-8655},
  doi      = {https://doi.org/10.1016/0167-8655(92)90069-C},
  url      = {http://www.sciencedirect.com/science/article/pii/016786559290069C},
  author   = {Marcel van Herk},
  keywords = {Mathematical morphology, recursive filters, local maximum and
              minimum, separability},
  abstract = {A new algorithm is presented for local maximum and minimum
              filters requiring only 6 comparisons per pixel independent of
              kernel size. The algorithm is based on separability and a
              combination of block recursive series which are evaluated forwards
              and backwards.}
}

@article{veldhuizen.1995.expression,
  title   = {Expression templates},
  author  = {Veldhuizen, Todd},
  journal = {C++ Report},
  volume  = {7},
  number  = {5},
  pages   = {26--31},
  year    = {1995}
}

@inproceedings{veldhuizen.2000.blitz,
  author    = {Veldhuizen, Todd L.},
  editor    = {Langtangen, Hans Petter and Bruaset, Are Magnus and Quak, Ewald},
  title     = {Blitz++: The Library that Thinks it is a Compiler},
  booktitle = {Advances in Software Tools for Scientific Computing},
  year      = {2000},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {57--87},
  abstract  = {Blitz++ provides dense numeric arrays for C++ with performance
                on par with Fortran. It does so by using ''template techniques''
                (expression templates and template metaprograms). In addition to
                fast performance, Blitz++ arrays pro­vide many nice notations
                and features not available in Fortran 90.},
  isbn      = {978-3-642-57172-5}
}

@inproceedings{veldhuizen.1998.arrays,
  author    = {Veldhuizen, Todd L.},
  editor    = {Caromel, Denis and Oldehoeft, Rodney R. and Tholburn,
                Marydell},
  title     = {Arrays in Blitz++},
  booktitle = {Computing in Object-Oriented Parallel Environments},
  year      = {1998},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {223--230},
  abstract  = {The Blitz++ library provides numeric arrays for C++ with
                efficiency that rivals Fortran, without any language extensions.
                Blitz++ has features unavailable in Fortran 90/95, such as
                arbitrary transpose operations, array renaming, tensor notation,
                partial reductions, multi-component arrays and stencil
                operators. The library handles parsing and analysis of array
                expressions on its own using the expression templates technique,
                and performs optimizations (such as loop transformations) which
                have until now been the responsibility of compilers.},
  isbn      = {978-3-540-49372-3}
}

@article{veldhuizen.2000.techniques,
  title     = {Techniques for scientific C++},
  author    = {Veldhuizen, Todd},
  journal   = {Computer science technical report},
  volume    = {542},
  pages     = {60},
  year      = {2000},
  publisher = {Citeseer}
}

@misc{voutilainen.2017.concepts,
  title        = {Merge the Concepts {TS} Working Draft into the {C}++20
                  working draft},
  author       = {Ville Voutilainen},
  year         = {2017},
  key          = {P0724r0},
  month        = {06},
  organization = {WG21},
  url          = {https://wg21.link/p0724r0}
}

@article{wagner.2005.generic,
  title   = {A Generic and Extensible Optimization Environment},
  author  = {Wagner, S and Affenzeller, M},
  journal = {Adaptive and Natural Computing Algorithms, Springer Computer
            Science},
  pages   = {538--541},
  year    = {2005}
}

@inproceedings{wimtlplavrijsen.2016.cppyy,
  author    = {W. T. L. P. Lavrijsen and A. Dutta},
  booktitle = {2016 6th Workshop on {P}ython for High-Performance and
                Scientific Computing ({P}y{HPC})},
  title     = {High-Performance {P}ython-{C}++ Bindings with {P}y{P}y and
                {C}ling},
  year      = {2016},
  volume    = {},
  number    = {},
  pages     = {27-35},
  keywords  = {C++ language; software libraries; private Boolean query
                processing; encrypted data; data outsourcing; privacy risks;
                data encryption; data confidentiality; support complex queries;
                security requirements; privacy-preserving query processing
                framework; Bloom filter; additive homomorphic encryption; query
                evaluation; PyPy; Cling; high level productivity language; high
                performance libraries; Python-C++ bindings generators; thread
                safety; C++ parser; dynamic optimizations; CPython; C++
                functions; C++ libraries; C++ languages; Generators; Standards;
                Libraries; Optimization; Semantics; Productivity},
  doi       = {10.1109/PyHPC.2016.008},
  issn      = {},
  month     = {11}
}

@inproceedings{wong.2019.heterogeneous,
  author    = {Wong, Michael and Finkel, Hal},
  title     = {Distributed \& Heterogeneous Programming in C++ for HPC at
                SC17},
  booktitle = {Proceedings of the International Workshop on OpenCL},
  series    = {IWOCL '18},
  year      = {2018},
  isbn      = {978-1-4503-6439-3},
  location  = {Oxford, United Kingdom},
  pages     = {20:1--20:7},
  articleno = {20},
  numpages  = {7},
  url       = {http://doi.acm.org/10.1145/3204919.3204939},
  doi       = {10.1145/3204919.3204939},
  acmid     = {3204939},
  publisher = {ACM},
  address   = {New York, NY, USA},
  keywords  = {BoF, C++, HPC, SC17, concurrency, distributed programming
                models, heterogeneous programming, parallelism}
}

@article{yoo.2002.engineering,
  title     = {Engineering and algorithm design for an image processing API: a
              technical report on ITK-the insight toolkit},
  author    = {Yoo, Terry S and Ackerman, Michael J and Lorensen, William E and
              Schroeder, Will and Chalana, Vikram and Aylward, Stephen and
              Metaxas, Dimitris and Whitaker, Ross},
  journal   = {Studies in health technology and informatics},
  pages     = {586--592},
  year      = {2002},
  publisher = {IOS Press; 1999}
}

@inproceedings{hanus.1995.curry,
  author    = {Michael Hanus and Herbert Kuchen and Juan Jose Moreno-Navarro},
  title     = {Curry: A Truly Functional Logic Language},
  year      = {1995},
  booktitle = {Proc. ILPS'95 Workshop on Visions for the Future of Logic Programming},
  pages     = {95-107},
  volume    = {95},
  abstract  = {Functional and logic programming are the most important declarative programming paradigms, and interest
                in combining them has grown over the last decade. However, integrated functional logic languages are
                currently not widely used. This is due to the fact that the operational principles are not well
                understood and many different evaluation strategies have been proposed which resulted in many different
                functional logic languages. To overcome this situation, we propose the functional logic language Curry
                which is intended to become a standard language in this area. It includes important ideas of existing
                functional logic languages and recent developments, and combines the most important features of
                functional and logic languages. Thus, Curry can be the basis to combine the currently separated research
                efforts of the functional and logic programming communities and to boost declarative programming in
                general. Moreover, since functions provide for more efficient evaluation strategies and are a
                declarative replacement of some impure features of Prolog (in particular, pruning operators), Curry can
                be also used as a declarative successor of Prolog.}
}

@article{carlinet.2015.tip,
  author   = {Edwin Carlinet and Thierry G\'eraud},
  title    = {{MToS}: {A} Tree of Shapes for Multivariate Images},
  journal  = {IEEE Transactions on Image Processing},
  year     = {2015},
  volume   = {24},
  number   = {12},
  pages    = {5330--5342},
  optmonth = {December}
}

@article{carlinet.2014.tip,
  author   = {Edwin Carlinet and Thierry G\'eraud},
  title    = {A Comparative Review of Component Tree Computation Algorithms},
  journal  = {IEEE Transactions on Image Processing},
  year     = {2014},
  volume   = {23},
  number   = {9},
  optmonth = {September},
  pages    = {3885--3895}
}

@inproceedings{meyer.2009.ismm,
  title     = {Morphology on graphs and minimum spanning trees},
  author    = {Fernand Meyer and Jean Stawiaski},
  booktitle = {Proc. of the Intl. Symp. on Mathematical Morphology (ISMM)},
  pages     = {161--170},
  year      = {2009},
  publisher = {Springer},
  series    = {LNCS},
  volume    = {5720}
}

@article{xu.2015.pami,
  title        = {Connected filtering on tree-based shape-spaces},
  author       = {Yongchao Xu and Thierry G{\'e}raud and Laurent Najman},
  journal      = {IEEE Transactions on Pattern Analysis and Machine Intelligence},
  volume       = {38},
  number       = {6},
  pages        = {1126--1140},
  year         = {2015},
  optpublisher = {IEEE}
}

@article{ritter.1990.cvgi,
  title     = {Image algebra: An overview},
  author    = {Gerhard X. Ritter and Joseph N. Wilson and Jennifer L. Davidson},
  journal   = {Computer Vision, Graphics, and Image Processing},
  volume    = 49,
  number    = 3,
  pages     = {297--331},
  year      = 1990,
  publisher = {Elsevier}
}

@article{perret.2019.higra,
  title    = {Higra: Hierarchical Graph Analysis},
  journal  = {SoftwareX},
  volume   = {10},
  pages    = {100335},
  year     = {2019},
  issn     = {2352-7110},
  doi      = {https://doi.org/10.1016/j.softx.2019.100335},
  url      = {http://www.sciencedirect.com/science/article/pii/S235271101930247X},
  author   = {B. Perret and G. Chierchia and J. Cousty and S.J. F. Guimarães and Y. Kenmochi and L. Najman},
  keywords = {Graph, Hierarchical clustering, Component tree},
  abstract = {Higra — Hierarchical Graph Analysis is a C++/Python library for efficient sparse graph analysis with a
              special focus on hierarchical methods capable of handling large amount of data. The main aspects of
              hierarchical graph analysis addressed in Higra are the construction of hierarchical representations
              (agglomerative clustering, mathematical morphology hierarchies, etc.), the analysis and processing of such
              representations (filtering, clustering, characterization, etc.), and their assessment. Higra targets a
              large audience, from students and practitioners wanting an accessible library for quickly experimenting,
              to researchers developing new methods for hierarchical analysis of graph data. Higra is a generic toolbox
              for graph analysis and can be utilized in a large variety of application fields like machine learning,
              data science, pattern analysis and computer vision. Moreover, it contains an image analysis module easing
              the handling of pixel grid graphs by providing efficient algorithms dedicated to this field.}
}

@misc{niebler.2018.ranges,
  author       = {Eric Niebler and Casey Carter},
  title        = {{P1037R0}: {D}eep Integration of the Ranges {TS}},
  note         = {{\small\url{https://wg21.link/p1037r0}}},
  year         = 2018,
  month        = may,
  optpublisher = {WG21}
}

@techreport{c++.2020.stddraftN4849,
  author       = {Richard Smith},
  title        = {{N4849}: Working Draft, Standard for Programming Language {C++}},
  note         = {{\small\url{https://wg21.link/n4849}}},
  institution  = {International Organization for Standardization},
  year         = 2020,
  month        = jan,
  optpublisher = {WG21}
}

@inproceedings{stroustrup.2007.hopl,
  author       = {Bjarne Stroustrup},
  title        = {Evolving a Language in and for the Real World: {C++} 1991-2006},
  year         = {2007},
  isbn         = {9781595937667},
  optpublisher = {Association for Computing Machinery},
  address      = {New York, USA},
  url          = {https://doi.org/10.1145/1238844.1238848},
  doi          = {10.1145/1238844.1238848},
  booktitle    = {Proc. of the 3rd ACM SIGPLAN Conf. on History of Programming Languages},
  optbooktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  volume       = {4},
  pages        = {1--59},
  location     = {San Diego, California},
  optseries    = {HOPL III}
}

@article{stroustrup.1999.hot,
  title     = {An overview of the {C++} programming language},
  author    = {Bjarne Stroustrup},
  journal   = {Handbook of Object Technology},
  year      = {1999},
  publisher = {CRC Press}
}

@article{fernique.2018.autowig,
  title     = {AutoWIG: automatic generation of python bindings for C++ libraries},
  author    = {Fernique, Pierre and Pradal, Christophe},
  journal   = {PeerJ Computer Science},
  volume    = {4},
  pages     = {e149},
  year      = {2018},
  publisher = {PeerJ Inc.},
  url       = {https://peerj.com/articles/cs-149.pdf}
}

@misc{opencv.bg_sub,
  title = {Background Subtraction},
  note  = {{\small\url{https://docs.opencv.org/3.4/d1/dc5/tutorial_background_subtraction.html}}},
  year  = 2018,
  month = dec
}

@misc{howard.2017.mobilenets,
  title         = {MobileNets: Efficient Convolutional Neural Networks for Mobile Vision Applications},
  author        = {Andrew G. Howard and Menglong Zhu and Bo Chen and Dmitry Kalenichenko and Weijun Wang and Tobias
                  Weyand and Marco Andreetto and Hartwig Adam},
  year          = {2017},
  eprint        = {1704.04861},
  archiveprefix = {arXiv},
  primaryclass  = {cs.CV}
}

@inproceedings{beazley.1996.swig,
  title     = {SWIG: An Easy to Use Tool for Integrating Scripting Languages with C and C++.},
  author    = {Beazley, David M and others},
  booktitle = {Tcl/Tk Workshop},
  volume    = {43},
  pages     = {74},
  year      = {1996}
}

@inproceedings{demaille.2013.vcsn,
  author    = {Demaille, Akim and Duret-Lutz, Alexandre and Lombardy, Sylvain and Sakarovitch, Jacques},
  editor    = {Konstantinidis, Stavros},
  title     = {Implementation Concepts in Vaucanson 2},
  booktitle = {Implementation and Application of Automata},
  year      = {2013},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {122--133},
  abstract  = {Vaucanson is an open source C++ platform dedicated to the computation with finite weighted automata. It
              is generic: it allows to write algorithms that apply on a wide set of mathematical objects. Initiated ten
              years ago, several shortcomings were discovered along the years, especially problems related to code
              complexity and obfuscation as well as performance issues. This paper presents the concepts underlying
              Vaucanson 2, a complete rewrite of the platform that addresses these issues.},
  isbn      = {978-3-642-39274-0}
}

@software{gimp.2019,
  author  = {{The GIMP Development Team}},
  title   = {GIMP},
  url     = {https://www.gimp.org},
  version = {2.10.12},
  date    = {2019-06-12}
}

@software{adobe.2019.photoshop,
  author  = {Adobe},
  title   = {Adobe Photoshop},
  url     = {https://photoshop.com/fr},
  version = {22.2},
  date    = {2021-02-09}
}

@software{imagemagick.2021,
  author  = {{The ImageMagick Development Team}},
  title   = {ImageMagick},
  url     = {https://imagemagick.org},
  version = {7.0.10},
  date    = {2021-01-04}
}

@software{graphicsmagick.2021,
  author  = {{GraphicsMagick Group}},
  title   = {GraphicsMagick},
  url     = {https://http://www.graphicsmagick.org},
  version = {1.3.36},
  date    = {2020-12-26}
}

@software{ptc.2019.mathcad,
  author  = {{PTC}},
  title   = {GraphicsMagick},
  url     = {https://www.mathcad.com},
  version = {6.0},
  date    = {2019-10-01}
}

@software{scilab.2020,
  author  = {{Scilab Enterprises}},
  title   = {Scilab},
  url     = {https://www.scilab.org},
  version = {6.1.0},
  date    = {2020-02-25}
}

@software{gnu.2021.octave,
  author  = {{GNU Project}},
  title   = {Octave},
  url     = {https://www.gnu.org/software/octave/index},
  version = {6.2.0},
  date    = {2021-02-20}
}

@software{mathworks.2020.matlab,
  author  = {{MathWorks}},
  title   = {MATLAB},
  url     = {https://fr.mathworks.com/products/matlab.html},
  version = {R2020b},
  date    = {2020-09-22}
}

@software{anaconda.2020,
  author  = {{Anaconda, Inc.}},
  title   = {Anaconda},
  url     = {https://anaconda.com},
  version = {2020.11},
  date    = {2020-11-19}
}

@software{wolfram.2020.mathematica,
  author  = {{wolfram Research}},
  title   = {Mathematica},
  url     = {https://www.wolfram.com/mathematica/},
  version = {12.2},
  date    = {2020-12-16}
}

@article{vanderWalts.2014.scikit-image,
  title    = {scikit-image: image processing in {P}ython},
  author   = {van der Walt, {S}t\'efan and {S}ch\"onberger, {J}ohannes {L}. and
              {Nunez-Iglesias}, {J}uan and {B}oulogne, {F}ran\c{c}ois and {W}arner, {J}oshua {D}. and {Y}ager, {N}eil
              and {G}ouillart, {E}mmanuelle and {Y}u, {T}ony and the scikit-image contributors},
  year     = {2014},
  month    = {6},
  keywords = {Image processing, Reproducible research, Education, Visualization, Open source, Python, Scientific
              programming},
  volume   = {2},
  pages    = {e453},
  journal  = {PeerJ},
  issn     = {2167-8359},
  url      = {https://doi.org/10.7717/peerj.453},
  doi      = {10.7717/peerj.453}
}

@software{clark.2021.pillow,
  author  = {{Alex Clark and al.}},
  title   = {Pillow},
  url     = {https://python-pillow.org},
  version = {8.1.2},
  date    = {2021-03-06}
}

@software{pypi.2021,
  author  = {{The PyPi Developement Team}},
  title   = {{P}y{P}i},
  url     = {https://pypi.org},
  version = {21.0.1},
  date    = {2021-01-31}
}

@inproceedings{kluyver.2016.jupyter,
  booktitle = {Positioning and Power in Academic Publishing: Players, Agents and Agendas},
  editor    = {Fernando Loizides and Birgit Scmidt},
  title     = {Jupyter Notebooks - a publishing format for reproducible computational workflows},
  author    = {Thomas Kluyver and Benjamin Ragan-Kelley and Fernando P{\'e}rez and Brian Granger and Matthias Bussonnier
              and Jonathan Frederic and Kyle Kelley and Jessica Hamrick and Jason Grout and Sylvain Corlay and Paul
              Ivanov and Dami{\'a}n Avila and Safia Abdalla and Carol Willing and  Jupyter development team},
  publisher = {IOS Press},
  address   = {Netherlands},
  year      = {2016},
  pages     = {87--90},
  url       = {https://eprints.soton.ac.uk/403913/},
  abstract  = {It is increasingly necessary for researchers in all fields to write computer code, and in order to
              reproduce research results, it is important that this code is published. We present Jupyter notebooks, a
              document format for publishing code, results and explanations in a form that is both readable and
              executable. We discuss various tools and use cases for notebook documents.}
}

@book{ansi.1983.ada,
  author    = {{ANSI}},
  title     = {{ANSI/MIL-STD-1815A}: {Programming} languages --- {Ada}},
  publisher = {American National Standards Institute},
  pages     = {333},
  month     = {06},
  year      = {1983},
  url       = {https://www.iso.org/standard/16028.html}
}

@String{pub-ISO     = "International Organization for Standardization"}
@String{pub-ISO:adr = "Geneva, Switzerland"}

@book{iso.1987.ada,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {333},
  month     = {06},
  year      = {1987},
  url       = {https://www.iso.org/standard/16028.html}
}

@book{iso.1995.ada,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {511},
  month     = {02},
  year      = {1995},
  url       = {https://www.iso.org/standard/22983.html}
}

@book{iso.1995.ada.corr,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Technical Corrigendum 1},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {56},
  month     = {06},
  year      = {2001},
  url       = {https://www.iso.org/standard/35451.html}
}

@book{iso.1995.ada.amend,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Amendment 1},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {317},
  month     = {03},
  year      = {2007},
  url       = {https://www.iso.org/standard/45001.html}
}

@book{iso.2012.ada,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {832},
  month     = {21},
  year      = {2012},
  url       = {https://www.iso.org/standard/61507.html}
}

@book{iso.2012.ada.corr,
  author    = {{ISO}},
  title     = {{ISO\slash IEC JTC 1/SC 22}: {Programming} languages --- {Ada} --- Technical Corrigendum 1},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {75},
  month     = {02},
  year      = {2016},
  url       = {https://www.iso.org/standard/69798.html}
}

@book{iso.1998.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2003}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {732},
  month     = {09},
  year      = {1998},
  url       = {https://www.iso.org/standard/25845.html}
}

@book{iso.2003.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2003}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {757},
  month     = {10},
  year      = {2003},
  url       = {https://www.iso.org/standard/38110.html}
}

@book{iso.2011.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2011}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1338},
  month     = {09},
  year      = {2011},
  url       = {https://www.iso.org/standard/50372.html}
}

@book{iso.2014.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2014}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1358},
  month     = {12},
  year      = {2014},
  url       = {https://www.iso.org/standard/64029.html}
}

@book{iso.2017.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2017}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1605},
  month     = {12},
  year      = {2017},
  url       = {https://www.iso.org/standard/68564.html}
}

@book{iso.2020.cpp,
  author    = {{ISO}},
  title     = {{ISO\slash IEC 14882:2020}: {Programming} languages --- {C++}},
  publisher = pub-ISO,
  address   = pub-ISO:adr,
  pages     = {1853},
  month     = {12},
  year      = {2020},
  url       = {https://www.iso.org/standard/79358.html}
}

@techreport{veldhuizen.2003.c++templates,
  author      = {Todd L. Veldhuizen},
  title       = {C++ Templates are Turing Complete},
  institution = {},
  year        = {2003}
}

@book{vandevoorde.2002.c++,
  title     = {C++ Templates: The Complete Guide, Portable Documents},
  author    = {Vandevoorde, David and Josuttis, Nicolai M},
  year      = {2002},
  publisher = {Addison-Wesley Professional}
}

@software{quantstack.2021.xeus-cling,
  author  = {QuantStack},
  title   = {xeus-cling},
  url     = {https://github.com/QuantStack/xeus-cling},
  version = {0.12.1},
  date    = {2021-03-16}
}

@article{behnel.2010.cython,
  author   = {Behnel, S. and Bradshaw, R. and Citro, C. and Dalcin, L. and Seljebotn, D.S. and Smith, K.},
  journal  = {Computing in Science Engineering},
  title    = {Cython: The Best of Both Worlds},
  year     = {2011},
  month    = {03},
  volume   = {13},
  number   = {2},
  pages    = {31-39},
  keywords = {Cython language; Fortran code; Python language extension; numerical loops; programming language;
             Clanguage; numerical analysis},
  doi      = {10.1109/MCSE.2010.118},
  issn     = {1521-9615}
}

@software{boost.2021,
  author  = {Boost},
  title   = {Boost C++ Libraries},
  url     = {https://www.boost.org/},
  version = {1.76.0},
  date    = {2021-04-16}
}

@software{nlohmann.2021.json,
  author  = {Niels Lohmann},
  title   = {Json},
  url     = {https://github.com/nlohmann/json},
  version = {3.10.2},
  date    = {2021-08-26}
}

@software{lemire.2021.simdjson,
  author  = {Daniel Lemire and Geoff Langdale and John Keiser},
  title   = {simdjson},
  url     = {https://github.com/simdjson/simdjson},
  version = {1.0},
  date    = {2021-09-08}
}

@software{boost.2021,
  author  = {Boost},
  title   = {Boost C++ Libraries},
  url     = {https://www.boost.org/},
  version = {1.76.0},
  date    = {2021-04-16}
}

@inproceedings{vassilev.2012.cling,
  author    = {Vassilev,V. and Canal,Ph. and Naumann,A. and Moneta,L. and Russo,P.},
  title     = {{Cling} -- The New Interactive Interpreter for {ROOT} 6},
  journal   = {Journal of Physics: Conference Series},
  year      = 2012,
  month     = {12},
  volume    = {396},
  number    = {5},
  pages     = {052071},
  doi       = {10.1088/1742-6596/396/5/052071},
  url       = {https://iopscience.iop.org/article/10.1088/1742-6596/396/5/052071/pdf},
  publisher = {{IOP} Publishing}
}

@article{dean.2008.mapreduce,
  author     = {Dean, Jeffrey and Ghemawat, Sanjay},
  title      = {MapReduce: Simplified Data Processing on Large Clusters},
  year       = {2008},
  issue_date = {January 2008},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {51},
  number     = {1},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/1327452.1327492},
  doi        = {10.1145/1327452.1327492},
  abstract   = {MapReduce is a programming model and an associated implementation for processing and generating large
                datasets that is amenable to a broad variety of real-world tasks. Users specify the computation in terms
                of a map and a reduce function, and the underlying runtime system automatically parallelizes the
                computation across large-scale clusters of machines, handles machine failures, and schedules
                inter-machine communication to make efficient use of the network and disks. Programmers find the system
                easy to use: more than ten thousand distinct MapReduce programs have been implemented internally at
                Google over the past four years, and an average of one hundred thousand MapReduce jobs are executed on
                Google's clusters every day, processing a total of more than twenty petabytes of data per day.},
  journal    = {Commun. ACM},
  month      = {01},
  pages      = {107-113},
  numpages   = {7}
}

@misc{dean.2019.monoids,
  author    = {Ben Dean},
  title     = {Identifying Monoids: Exploiting Compositional Structure in Code},
  url       = {https://cppnow2019.sched.com/event/b60160aa659270370279c5acb6196fb6},
  month     = {06},
  year      = {2019},
  publisher = {{C++Now} 2019},
  note      = {Slides available at
                  \url{https://github.com/boostcon/cppnow_presentations_2019/blob/master/05-09-2019_thursday/Identifying_Monoids_Exploiting_Compositional_Structure_in_Code__Ben_Deane_cppnow_05092019.pdf},
                  Talk available on youtube at \url{https://youtu.be/INnattuluiM}}
}

@article{liskov.1993.cluart,
  author     = {Liskov, Barbara},
  title      = {A History of CLU},
  year       = {1993},
  issue_date = {March 1993},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {28},
  number     = {3},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/155360.155367},
  doi        = {10.1145/155360.155367},
  abstract   = {The idea of a data abstraction has had a significant impact on the development of programming languages 
                and on programming methodology. CLU was the first implemented programming language to provide direct
                linguistic support for data abstraction. This paper provides a history of data abstraction and CLU. CLU
                contains a number of other interesting and influential features, including its exception handling
                mechanism, its iterators, and its parameterized types.},
  journal    = {SIGPLAN Not.},
  month      = mar,
  pages      = {133-147},
  numpages   = {15}
}

@inproceedings{liskov.1993.cluproc,
  author    = {Liskov, Barbara},
  title     = {A History of CLU},
  year      = {1993},
  isbn      = {0897915704},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/154766.155367},
  doi       = {10.1145/154766.155367},
  abstract  = {The idea of a data abstraction has had a significant impact on the development of programming languages
                and on programming methodology. CLU was the first implemented programming language to provide direct
                linguistic support for data abstraction. This paper provides a history of data abstraction and CLU. CLU
                contains a number of other interesting and influential features, including its exception handling
                mechanism, its iterators, and its parameterized types.},
  booktitle = {The Second ACM SIGPLAN Conference on History of Programming Languages},
  pages     = {133-147},
  numpages  = {15},
  location  = {Cambridge, Massachusetts, USA},
  series    = {HOPL-II}
}

@inproceedings{atkinson.1978.cluimpl,
  author    = {Atkinson, Russell R. and Liskov, Barbara H. and Scheifler, Robert W.},
  title     = {Aspects Of Implementing CLU},
  year      = {1978},
  isbn      = {0897910001},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/800127.804079},
  doi       = {10.1145/800127.804079},
  abstract  = {Linguistic mechanisms used in CLU to support 1) structured exception handling, 2) iteration over abstract
               objects, and 3) parameterized abstractions are briefly reviewed, and methods of realizing these
               mechanisms are described. The mechanisms discussed support features that are likely to be included in
               other programming languages, and the implementation methods should be applicable to a wide range of
               languages.},
  booktitle = {Proceedings of the 1978 Annual Conference},
  pages     = {123-129},
  numpages  = {7},
  keywords  = {CLU, Iterators, Programming language, Parameterized modules, Exception handling, Implementation methods},
  location  = {Washington, D.C., USA},
  series    = {ACM '78}
}

@article{goguen.1984.parametrized,
  author   = {Goguen, Joseph A.},
  journal  = {IEEE Transactions on Software Engineering},
  title    = {Parameterized Programming},
  year     = {1984},
  volume   = {SE-10},
  number   = {5},
  pages    = {528-543},
  abstract = {Parameterized programming is a powerful technique for the reliable reuse of software. In this technique,
              modules are parameterized over very general interfaces that describe what properties of an environment are
              required for the module to work correctly. Reusability is enhanced by the flexibility of the
              parameterization mechanism proposed here. Reliability is further enhanced by permitting interface
              requirements to include more than purely syntactic information. This paper introduces three new ideas that
              seem especially useful in supporting parameterized programming: 1) theories, which declare global
              properties of program modules and interfaces; 2) views, which connect theories with program modules in an
              elegant way; and 3) module expressions, a kind of general structured program transformation which produces
              new modules by modifying and combining existing modules. Although these ideas are illustrated with some
              simple examples in the OBJ programming language, they should also be taken as proposals for an
              Ada<sup>1</sup> library system, for adding modules to Prolog, and as considerations for future language
              design efforts. OBJ is an ultra-high level programming language, based upon rewrite rules, that
              incorporates these ideas, and many others from modern programming methodology.},
  keywords = {},
  doi      = {10.1109/TSE.1984.5010277},
  issn     = {1939-3520},
  month    = {Sep.}
}

@inbook{coplien.1996.crtp,
  author    = {Coplien, James O.},
  title     = {Curiously Recurring Template Patterns},
  year      = {1996},
  isbn      = {1884842372},
  publisher = {SIGS Publications, Inc.},
  address   = {USA},
  booktitle = {C++ Gems},
  pages     = {135-144},
  numpages  = {10}
}

@article{stroustrup.2020.acm,
  author     = {Stroustrup, Bjarne},
  title      = {Thriving in a Crowded and Changing World: C++ 2006-2020},
  year       = {2020},
  issue_date = {June 2020},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {4},
  number     = {HOPL},
  url        = {https://doi.org/10.1145/3386320},
  doi        = {10.1145/3386320},
  abstract   = {By 2006, C++ had been in widespread industrial use for 20 years. It contained parts that had survived
                unchanged since introduced into C in the early 1970s as well as features that were novel in the early
                2000s. From 2006 to 2020, the C++ developer community grew from about 3 million to about 4.5 million. It
                was a period where new programming models emerged, hardware architectures evolved, new application
                domains gained massive importance, and quite a few well-financed and professionally marketed languages
                fought for dominance. How did C++ -- an older language without serious commercial backing -- manage to
                thrive in the face of all that? This paper focuses on the major changes to the ISO C++ standard for the
                2011, 2014, 2017, and 2020 revisions. The standard library is about 3/4 of the C++20 standard, but this
                paper's primary focus is on language features and the programming techniques they support. The paper
                contains long lists of features documenting the growth of C++. Significant technical points are
                discussed and illustrated with short code fragments. In addition, it presents some failed proposals and
                the discussions that led to their failure. It offers a perspective on the bewildering flow of facts and
                features across the years. The emphasis is on the ideas, people, and processes that shaped the language.
                Themes include efforts to preserve the essence of C++ through evolutionary changes, to simplify its use,
                to improve support for generic programming, to better support compile-time programming, to extend
                support for concurrency and parallel programming, and to maintain stable support for decades' old code.
                The ISO C++ standard evolves through a consensus process. Inevitably, there is competition among
                proposals and clashes (usually polite ones) over direction, design philosophies, and principles. The
                committee is now larger and more active than ever, with as many as 250 people turning up to week-long
                meetings three times a year and many more taking part electronically. We try (not always successfully)
                to mitigate the effects of design by committee, bureaucratic paralysis, and excessive enthusiasm for a
                variety of language fashions.  Specific language-technical topics include the memory model, concurrency
                and parallelism, compile-time computation, move-semantics, exceptions, lambda expressions, and modules.
                Designing a mechanism for specifying a template's requirements on its arguments that is sufficiently
                flexible and precise yet doesn't impose run-time costs turned out to be hard. The repeated attempts to
                design ``concepts'' to do that have their roots back in the 1980s and touch upon many key design issues
                for C++ and for generic programming.  The description is based on personal participation in the key
                events and design decisions, backed by the thousands of papers and hundreds of meeting minutes in the
                ISO C++ standards committee's archives.},
  journal    = {Proc. ACM Program. Lang.},
  month      = jun,
  articleno  = {70},
  numpages   = {168},
  keywords   = {C++, concurrency and parallelism, generic programming, programming language design and evolution,
                resource management, simplification of language use, standardization}
}

@article{dosries.2066.specifying.art,
  author     = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  title      = {Specifying C++ Concepts},
  year       = {2006},
  issue_date = {January 2006},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {41},
  number     = {1},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1111320.1111064},
  doi        = {10.1145/1111320.1111064},
  abstract   = {C++ templates are key to the design of current successful mainstream libraries and systems. They are the
                basis of programming techniques in diverse areas ranging from conventional general-purpose programming
                to software for safety-critical embedded systems. Current work on improving templates focuses on the
                notion of concepts (a type system for templates), which promises significantly improved error
                diagnostics and increased expressive power such as concept-based overloading and function template
                partial specialization. This paper presents C++ templates with an emphasis on problems related to
                separate compilation. We consider the problem of how to express concepts in a precise way that is simple
                enough to be usable by ordinary programmers. In doing so, we expose a few weaknesses of the current
                specification of the C++ standard library and suggest a far more precise and complete specification. We
                also present a systematic way of translating our proposed concept definitions, based on use-patterns
                rather than function signatures, into constraint sets that can serve as convenient basis for concept
                checking in a compiler.},
  journal    = {SIGPLAN Not.},
  month      = jan,
  pages      = {295-308},
  numpages   = {14},
  keywords   = {C++ concepts, C++ templates, separate compilation, generic programming, type systems}
}

@inproceedings{dosries.2066.specifying.proc,
  author    = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  title     = {Specifying C++ Concepts},
  year      = {2006},
  isbn      = {1595930272},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1111037.1111064},
  doi       = {10.1145/1111037.1111064},
  abstract  = {C++ templates are key to the design of current successful mainstream libraries and systems. They are the
               basis of programming techniques in diverse areas ranging from conventional general-purpose programming to
               software for safety-critical embedded systems. Current work on improving templates focuses on the notion
               of concepts (a type system for templates), which promises significantly improved error diagnostics and
               increased expressive power such as concept-based overloading and function template partial
               specialization. This paper presents C++ templates with an emphasis on problems related to separate
               compilation. We consider the problem of how to express concepts in a precise way that is simple enough to
               be usable by ordinary programmers. In doing so, we expose a few weaknesses of the current specification
               of the C++ standard library and suggest a far more precise and complete specification. We also present a
               systematic way of translating our proposed concept definitions, based on use-patterns rather than
               function signatures, into constraint sets that can serve as convenient basis for concept checking in a
               compiler.},
  booktitle = {Conference Record of the 33rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {295-308},
  numpages  = {14},
  keywords  = {C++ concepts, generic programming, type systems, C++ templates, separate compilation},
  location  = {Charleston, South Carolina, USA},
  series    = {POPL '06}
}

@inproceedings{Stroustrup.2007.evolving,
  author    = {Stroustrup, Bjarne},
  title     = {Evolving a Language in and for the Real World: C++ 1991-2006},
  year      = {2007},
  isbn      = {9781595937667},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1238844.1238848},
  doi       = {10.1145/1238844.1238848},
  abstract  = {This paper outlines the history of the C++ programming language from the early days of its ISO
               standardization (1991), through the 1998 ISO standard, to the later stages of the C++0x revision of that
               standard (2006). The emphasis is on the ideals, constraints, programming techniques, and people that
               shaped the language, rather than the minutiae of language features. Among the major themes are the
               emergence of generic programming and the STL (the C++ standard library's algorithms and containers).
               Specific topics include separate compilation of templates, exception handling, and support for embedded
               systems programming. During most of the period covered here, C++ was a mature language with millions of
               users. Consequently, this paper discusses various uses of C++ and the technical and commercial pressures
               that provided the background for its continuing evolution.},
  booktitle = {Proceedings of the Third ACM SIGPLAN Conference on History of Programming Languages},
  pages     = {4-1-4-59},
  keywords  = {programming language, standardization, libraries, language use, STL, multi-paradigm programming,
               evolution, ISO, C++, history},
  location  = {San Diego, California},
  series    = {HOPL III}
}
  
@article{stroustrup.2005.design,
  title   = {The design of C++ 0x},
  author  = {Stroustrup, Bjarne},
  journal = {C/C++ Users Journal},
  volume  = {23},
  number  = {5},
  pages   = {7},
  year    = {2005}
}

@inbook{stroustrup.1996.history,
  author    = {Stroustrup, Bjarne},
  title     = {A History of C++: 1979--1991},
  year      = {1996},
  isbn      = {0201895021},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/234286.1057836},
  abstract  = {This paper outlines the history of the C++ programming language. The emphasis is on the ideas,
               constraints, and people that shaped the language, rather than the minutiae of language features. Key
               design decisions relating to language features are discussed, but the focus is one of the overall design
               goals and practical constraints. The evolution of C++ is traced from C with Classes to the current ANSI
               and ISO standards work and the explosion of use, interest, commercial activity, compilers, tools,
               environments, and libraries.},
  booktitle = {History of Programming Languages---II},
  pages     = {699-769},
  numpages  = {71}
}

