\chapter{Benchmark compilation time}
\label{appendix:benchmark.compilation.time}

First is the code containing containing the structures that will be used in the program against both SFINAE and concept
contraints.
\section{Common structures}
\begin{minted}{c++}
// dummy_structs.hpp

template <int N>
struct boolean_struct
{
  boolean_struct()                      = default;
  boolean_struct(const boolean_struct&) = default;
  boolean_struct(boolean_struct&&)      = default;
  boolean_struct& operator=(const boolean_struct&) = default;
  boolean_struct& operator=(boolean_struct&&) = default;

  explicit boolean_struct(bool b)
    : b_(b)
  {
  }

  operator bool() const { return b_; }

private:
  bool b_;
};

template <int N>
inline bool operator!(const boolean_struct<N>& b)
{
  return not static_cast<bool>(b);
}

template <int N, int M>
inline bool operator&&(const boolean_struct<N>& lhs, const boolean_struct<M>& rhs)
{
  return static_cast<bool>(lhs) && static_cast<bool>(rhs);
}

template <int N>
inline bool operator&&(const boolean_struct<N>& lhs, bool rhs)
{
  return static_cast<bool>(lhs) && rhs;
}

template <int M>
inline bool operator&&(bool lhs, const boolean_struct<M>& rhs)
{
  return rhs && lhs;
}

template <int N, int M>
inline bool operator||(const boolean_struct<N>& lhs, const boolean_struct<M>& rhs)
{
  return static_cast<bool>(lhs) || static_cast<bool>(rhs);
}

template <int N>
inline bool operator||(const boolean_struct<N>& lhs, bool rhs)
{
  return static_cast<bool>(lhs) || rhs;
}

template <int M>
inline bool operator||(bool lhs, const boolean_struct<M>& rhs)
{
  return lhs || static_cast<bool>(rhs);
}

template <int N, int M>
inline bool operator==(const boolean_struct<N>& lhs, const boolean_struct<M>& rhs)
{
  return static_cast<bool>(lhs) == static_cast<bool>(rhs);
}

template <int N>
inline bool operator==(const boolean_struct<N>& lhs, bool rhs)
{
  return static_cast<bool>(lhs) == rhs;
}

template <int M>
inline bool operator==(bool lhs, const boolean_struct<M>& rhs)
{
  return rhs == lhs;
}

template <int N, int M>
inline bool operator!=(const boolean_struct<N>& lhs, const boolean_struct<M>& rhs)
{
  return not(static_cast<bool>(lhs) == static_cast<bool>(rhs));
}

template <int N>
inline bool operator!=(const boolean_struct<N>& lhs, bool rhs)
{
  return not(static_cast<bool>(lhs) == rhs);
}

template <int M>
inline bool operator!=(bool lhs, const boolean_struct<M>& rhs)
{
  return not(rhs == lhs);
}


template <int N>
struct non_boolean_struct
{
  non_boolean_struct()                          = default;
  non_boolean_struct(const non_boolean_struct&) = default;
  non_boolean_struct(non_boolean_struct&&)      = default;
  non_boolean_struct& operator=(const non_boolean_struct&) = default;
  non_boolean_struct& operator=(non_boolean_struct&&) = default;

  non_boolean_struct(bool b)
    : b_(b)
  {
  }

  operator bool() const { return b_; }

private:
  bool b_;
};

template <int N>
inline bool operator!(const non_boolean_struct<N>& b)
{
  return not static_cast<bool>(b);
}

template <int N, int M>
inline bool operator&&(const non_boolean_struct<N>& lhs, const non_boolean_struct<M>& rhs)
{
  return static_cast<bool>(lhs) && static_cast<bool>(rhs);
}

template <int N>
inline bool operator&&(const non_boolean_struct<N>& lhs, bool rhs)
{
  return static_cast<bool>(lhs) && rhs;
}

template <int M>
inline bool operator&&(bool lhs, const non_boolean_struct<M>& rhs)
{
  return rhs && lhs;
}

template <int N, int M>
inline bool operator||(const non_boolean_struct<N>& lhs, const non_boolean_struct<M>& rhs)
{
  return static_cast<bool>(lhs) || static_cast<bool>(rhs);
}

template <int N>
inline bool operator||(const non_boolean_struct<N>& lhs, bool rhs)
{
  return static_cast<bool>(lhs) || rhs;
}

template <int M>
inline bool operator||(bool lhs, const non_boolean_struct<M>& rhs)
{
  return lhs || static_cast<bool>(rhs);
}

template <int N, int M>
inline bool operator==(const non_boolean_struct<N>& lhs, const non_boolean_struct<M>& rhs)
{
  return static_cast<bool>(lhs) == static_cast<bool>(rhs);
}

template <int N>
inline bool operator==(const non_boolean_struct<N>& lhs, bool rhs)
{
  return static_cast<bool>(lhs) == rhs;
}

template <int M>
inline bool operator==(bool lhs, const non_boolean_struct<M>& rhs)
{
  return rhs == lhs;
}

template <int N, int M>
inline bool operator!=(const non_boolean_struct<N>& lhs, const non_boolean_struct<M>& rhs)
{
  return not(static_cast<bool>(lhs) == static_cast<bool>(rhs));
}

template <int N>
inline bool operator!=(const non_boolean_struct<N>& lhs, bool rhs)
{
  return not(static_cast<bool>(lhs) == rhs);
}

// The non-existance of this overload will render the struct non-boolean
template <int M>
inline bool operator!=(bool lhs, const non_boolean_struct<M>& rhs) = delete;
/*
{
  return not (rhs == lhs);
}
*/
\end{minted}

We then have the canonical implementation of the standard library concepts in case the compilers does not provide library support for it yet.

\begin{minted}{c++}
// std_concepts.hpp

#ifdef _MSVC
#pragma message ( "Your compiler does not provide <concepts> header yet. Using in-house concepts implementation!" )
#else
#warning "Your compiler does not provide <concepts> header yet. Using in-house concepts implementation!"
#endif

#include <type_traits>
#include <utility>

namespace std_
{
  using namespace std;

  // clang-format off

  template<class T, class U>
  concept __SameImpl = is_same_v<T, U>;  // exposition only
 
  template<class T, class U>
  concept same_as = __SameImpl<T, U> && __SameImpl<U, T>;

  template<class Derived, class Base>
  concept derived_from =
    is_base_of_v<Base, Derived> &&
    is_convertible_v<const volatile Derived*, const volatile Base*>;

  template<class From, class To>
  concept convertible_to =
    is_convertible_v<From, To> &&
    requires(add_rvalue_reference_t<From> (&f)()) {
      static_cast<To>(f());
    };

  template<class B>
  concept __boolean_testable_impl =                // exposition only
    convertible_to<B, bool>;

  template<class B>
  concept boolean_testable =                       // exposition only
    __boolean_testable_impl<B> &&
    requires (B&& b) {
        { !forward<B>(b) } -> __boolean_testable_impl;
    };

  template<class T, class U>
  concept common_reference_with =
    same_as<common_reference_t<T, U>, common_reference_t<U, T>> &&
    convertible_to<T, common_reference_t<T, U>> &&
    convertible_to<U, common_reference_t<T, U>>;


  template<class T, class U>
  concept common_with =
    same_as<common_type_t<T, U>, common_type_t<U, T>> &&
    requires {
      static_cast<common_type_t<T, U>>(declval<T>());
      static_cast<common_type_t<T, U>>(declval<U>());
    } &&
    common_reference_with<
      add_lvalue_reference_t<const T>,
      add_lvalue_reference_t<const U>> &&
    common_reference_with<
      add_lvalue_reference_t<common_type_t<T, U>>,
      common_reference_t<
        add_lvalue_reference_t<const T>,
        add_lvalue_reference_t<const U>>>;

  template<class T>
  concept integral = is_integral_v<T>;

  template<class T>
  concept signed_integral = integral<T> && is_signed_v<T>;

  template<class T>
  concept unsigned_integral = integral<T> && !signed_integral<T>;

  template<class T>
  concept floating_point = is_floating_point_v<T>;

  template<class LHS, class RHS>
  concept assignable_from =
    is_lvalue_reference_v<LHS> &&
    common_reference_with<
      const remove_reference_t<LHS>&,
      const remove_reference_t<RHS>&> &&
    requires(LHS lhs, RHS&& rhs) {
      { lhs = forward<RHS>(rhs) } -> same_as<LHS>;
    };

  template<class T>
  concept swappable = requires(T& a, T& b) { ranges::swap(a, b); };

  template<class T, class U>
  concept swappable_with =
    common_reference_with<const remove_reference_t<T>&, const remove_reference_t<U>&> &&
    requires(T&& t, U&& u) {
      ranges::swap(forward<T>(t), forward<T>(t));
      ranges::swap(forward<U>(u), forward<U>(u));
      ranges::swap(forward<T>(t), forward<U>(u));
      ranges::swap(forward<U>(u), forward<T>(t));
    };

  template<class T>
  concept destructible = is_nothrow_destructible_v<T>;

  template<class T, class... Args>
  concept constructible_from = destructible<T> && is_constructible_v<T, Args...>;

  template<class T>
  concept default_initializable =
    constructible_from<T> &&
    requires { T{}; } &&
    requires { ::new (static_cast<void*>(nullptr)) T; };

  template<class T>
  concept move_constructible = constructible_from<T, T> && convertible_to<T, T>;

  template<class T>
  concept copy_constructible =
    move_constructible<T> &&
    constructible_from<T, T&> && convertible_to<T&, T> &&
    constructible_from<T, const T&> && convertible_to<const T&, T> &&
    constructible_from<T, const T> && convertible_to<const T, T>;

  template<class T, class U>
  concept __WeaklyEqualityComparableWith = // exposition only
    requires(const remove_reference_t<T>& t,
             const remove_reference_t<U>& u) {
      { t == u } -> boolean_testable;
      { t != u } -> boolean_testable;
      { u == t } -> boolean_testable;
      { u != t } -> boolean_testable;
    };
 
  template<class T>
  concept equality_comparable = __WeaklyEqualityComparableWith<T, T>;

  template<class T, class U>
  concept equality_comparable_with =
    equality_comparable<T> && equality_comparable<U> &&
    common_reference_with<const remove_reference_t<T>&, const remove_reference_t<U>&> &&
    equality_comparable<
      common_reference_t<
        const remove_reference_t<T>&,
        const remove_reference_t<U>&>> &&
    __WeaklyEqualityComparableWith<T, U>;

  template<class T>
  concept totally_ordered =
    equality_comparable<T> &&
    requires(const remove_reference_t<T>& a,
             const remove_reference_t<T>& b) {
      { a <  b } -> boolean_testable;
      { a >  b } -> boolean_testable;
      { a <= b } -> boolean_testable;
      { a >= b } -> boolean_testable;
    };

  template<class T, class U>
  concept totally_ordered_with =
    totally_ordered<T> && totally_ordered<U> &&
    common_reference_with<const remove_reference_t<T>&, const remove_reference_t<U>&> &&
    totally_ordered<
      common_reference_t<
        const remove_reference_t<T>&,
        const remove_reference_t<U>&>> &&
    equality_comparable_with<T, U> &&
    requires(const remove_reference_t<T>& t,
             const remove_reference_t<U>& u) {
      { t <  u } -> boolean_testable; 
      { t >  u } -> boolean_testable;
      { t <= u } -> boolean_testable;
      { t >= u } -> boolean_testable;
      { u <  t } -> boolean_testable;
      { u >  t } -> boolean_testable;
      { u <= t } -> boolean_testable;
      { u >= t } -> boolean_testable;
    };

  template<class T>
  concept movable = is_object_v<T> && move_constructible<T> &&
                    assignable_from<T&, T> && swappable<T>;
  template<class T>
  concept copyable = copy_constructible<T> && movable<T> && assignable_from<T&, T&> &&
                     assignable_from<T&, const T&> && assignable_from<T&, const T>;

  template<class T>
  concept semiregular = copyable<T> && default_initializable<T>;

  template<class T>
  concept regular = semiregular<T> && equality_comparable<T>;

  template<class F, class... Args>
  concept invocable = requires(F&& f, Args&&... args) {
    invoke(forward<F>(f), forward<Args>(args)...);
      // not required to be equality-preserving
  };

  template<class F, class... Args>
  concept regular_invocable = invocable<F, Args...>;

  template<class F, class... Args>
  concept predicate =
    regular_invocable<F, Args...> && boolean_testable<invoke_result_t<F, Args...>>;

  template<class R, class T, class U>
  concept relation =
    predicate<R, T, T> && predicate<R, U, U> &&
    predicate<R, T, U> && predicate<R, U, T>;

  template<class R, class T, class U>
  concept equivalence_relation = relation<R, T, U>;

  template<class R, class T, class U>
  concept strict_weak_order = relation<R, T, U>;

  // clang-format on

} // namespace std_
\end{minted}

\section{Constraints}

First are the concepts we are going to benchmark the common structure against:
\begin{minted}{c++}
// concepts.hpp

#include "std_concepts.hpp"

#if __has_include(<concepts>)
#include <concepts>
#else
#include "stl_concepts.hpp"
namespace std { using namespace std_; }
#endif

#include <type_traits>

template<class B>
  concept boolean_c =
  std::movable<std::remove_cvref_t<B>> &&
  requires(const std::remove_reference_t<B>& b1,
            const std::remove_reference_t<B>& b2, const bool a) {
    { b1 } -> std::convertible_to<bool>;
    { !b1 } -> std::convertible_to<bool>;
    { b1 && b2 } -> std::same_as<bool>;
    { b1 &&  a } -> std::same_as<bool>;
    {  a && b2 } -> std::same_as<bool>;
    { b1 || b2 } -> std::same_as<bool>;
    { b1 ||  a } -> std::same_as<bool>;
    {  a || b2 } -> std::same_as<bool>;
    { b1 == b2 } -> std::convertible_to<bool>;
    { b1 ==  a } -> std::convertible_to<bool>;
    {  a == b2 } -> std::convertible_to<bool>;
    { b1 != b2 } -> std::convertible_to<bool>;
    { b1 !=  a } -> std::convertible_to<bool>;
    {  a != b2 } -> std::convertible_to<bool>;
  };

template<class B>
  concept boolean_fast_c =
  // Slow code commented and replaced by builtin compiler traits
  // std_::movable<std::remove_cvref_t<B>> && 
  std::is_object_v<B> && std::is_move_assignable_v<B> &&
  std::is_move_constructible_v<B> && std::is_swappable_v<B> &&
  requires(const std::remove_reference_t<B>& b1,
            const std::remove_reference_t<B>& b2, const bool a) {
    { b1 } -> std::convertible_to<bool>;
    { !b1 } -> std::convertible_to<bool>;
    { b1 && b2 } -> std::same_as<bool>;
    { b1 &&  a } -> std::same_as<bool>;
    {  a && b2 } -> std::same_as<bool>;
    { b1 || b2 } -> std::same_as<bool>;
    { b1 ||  a } -> std::same_as<bool>;
    {  a || b2 } -> std::same_as<bool>;
    { b1 == b2 } -> std::convertible_to<bool>;
    { b1 ==  a } -> std::convertible_to<bool>;
    {  a == b2 } -> std::convertible_to<bool>;
    { b1 != b2 } -> std::convertible_to<bool>;
    { b1 !=  a } -> std::convertible_to<bool>;
    {  a != b2 } -> std::convertible_to<bool>;
  };
\end{minted}

We then provide an equivalent in SFINAE of the above concepts, written with detectors in order to be used with classic
\texttt{std::void\_t} and/or \texttt{std::enable\_if} facilities.

\begin{minted}{c++}
// sfinae.hpp

#include <type_traits>
#include <utility>


// b -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_conv<B, std::enable_if_t<std::is_convertible_v<B, bool>>> : std::true_type
{
};


// !b
template <typename B, typename = void>
struct boolean_sfinae_impl_not : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_not<B, std::void_t<decltype(!std::declval<B>())>> : std::true_type
{
};

// !b -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_not_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_not_conv<B, std::enable_if_t<std::is_convertible_v<decltype(!std::declval<B>()), bool>>>
  : std::true_type
{
};


// b1 && b2
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_and : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_and<B1, B2, std::void_t<decltype(std::declval<B1>() && std::declval<B2>())>> : std::true_type
{
};

// b1 && b2 -> bool
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_and_conv : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_and_conv<
    B1, B2, std::enable_if_t<std::is_same_v<decltype(std::declval<B1>() && std::declval<B2>()), bool>>> : std::true_type
{
};

// b1 && bool
template <typename B, typename = void>
struct boolean_sfinae_impl_and_rb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_and_rb<B, std::void_t<decltype(std::declval<B>() && std::declval<bool>())>> : std::true_type
{
};

// b1 && bool -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_and_rb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_and_rb_conv<
    B, std::enable_if_t<std::is_same_v<decltype(std::declval<B>() && std::declval<bool>()), bool>>> : std::true_type
{
};

// bool && b2
template <typename B, typename = void>
struct boolean_sfinae_impl_and_lb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_and_lb<B, std::void_t<decltype(std::declval<bool>() && std::declval<B>())>> : std::true_type
{
};

// bool && b2 -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_and_lb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_and_lb_conv<
    B, std::enable_if_t<std::is_same_v<decltype(std::declval<bool>() && std::declval<B>()), bool>>> : std::true_type
{
};


// b1 || b2
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_or : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_or<B1, B2, std::void_t<decltype(std::declval<B1>() || std::declval<B2>())>> : std::true_type
{
};

// b1 || b2 -> bool
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_or_conv : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_or_conv<
    B1, B2, std::enable_if_t<std::is_same_v<decltype(std::declval<B1>() || std::declval<B2>()), bool>>> : std::true_type
{
};

// b1 || bool
template <typename B, typename = void>
struct boolean_sfinae_impl_or_rb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_or_rb<B, std::void_t<decltype(std::declval<B>() || std::declval<bool>())>> : std::true_type
{
};

// b1 || bool -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_or_rb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_or_rb_conv<
    B, std::enable_if_t<std::is_same_v<decltype(std::declval<B>() || std::declval<bool>()), bool>>> : std::true_type
{
};

// bool || b2
template <typename B, typename = void>
struct boolean_sfinae_impl_or_lb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_or_lb<B, std::void_t<decltype(std::declval<bool>() || std::declval<B>())>> : std::true_type
{
};

// bool || b2 -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_or_lb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_or_lb_conv<
    B, std::enable_if_t<std::is_same_v<decltype(std::declval<bool>() || std::declval<B>()), bool>>> : std::true_type
{
};


// b1 == b2
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_eq : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_eq<B1, B2, std::void_t<decltype(std::declval<B1>() == std::declval<B2>())>> : std::true_type
{
};

// b1 == b2 -> bool
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_eq_conv : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_eq_conv<
    B1, B2, std::enable_if_t<std::is_convertible_v<decltype(std::declval<B1>() == std::declval<B2>()), bool>>>
  : std::true_type
{
};

// b1 == bool
template <typename B, typename = void>
struct boolean_sfinae_impl_eq_rb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_eq_rb<B, std::void_t<decltype(std::declval<B>() == std::declval<bool>())>> : std::true_type
{
};

// b1 == bool -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_eq_rb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_eq_rb_conv<
    B, std::enable_if_t<std::is_convertible_v<decltype(std::declval<B>() == std::declval<bool>()), bool>>>
  : std::true_type
{
};

// bool == b2
template <typename B, typename = void>
struct boolean_sfinae_impl_eq_lb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_eq_lb<B, std::void_t<decltype(std::declval<bool>() == std::declval<B>())>> : std::true_type
{
};

// bool == b2 -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_eq_lb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_eq_lb_conv<
    B, std::enable_if_t<std::is_convertible_v<decltype(std::declval<bool>() == std::declval<B>()), bool>>>
  : std::true_type
{
};


// b1 != b2
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_neq : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_neq<B1, B2, std::void_t<decltype(std::declval<B1>() != std::declval<B2>())>> : std::true_type
{
};

// b1 != b2 -> bool
template <typename B1, typename B2, typename = void>
struct boolean_sfinae_impl_neq_conv : std::false_type
{
};

template <typename B1, typename B2>
struct boolean_sfinae_impl_neq_conv<
    B1, B2, std::enable_if_t<std::is_convertible_v<decltype(std::declval<B1>() != std::declval<B2>()), bool>>>
  : std::true_type
{
};

// b1 != bool
template <typename B, typename = void>
struct boolean_sfinae_impl_neq_rb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_neq_rb<B, std::void_t<decltype(std::declval<B>() != std::declval<bool>())>> : std::true_type
{
};

// b1 != bool -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_neq_rb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_neq_rb_conv<
    B, std::enable_if_t<std::is_convertible_v<decltype(std::declval<B>() != std::declval<bool>()), bool>>>
  : std::true_type
{
};

// bool != b2
template <typename B, typename = void>
struct boolean_sfinae_impl_neq_lb : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_neq_lb<B, std::void_t<decltype(std::declval<bool>() != std::declval<B>())>> : std::true_type
{
};

// bool != b2 -> bool
template <typename B, typename = void>
struct boolean_sfinae_impl_neq_lb_conv : std::false_type
{
};

template <typename B>
struct boolean_sfinae_impl_neq_lb_conv<
    B, std::enable_if_t<std::is_convertible_v<decltype(std::declval<bool>() != std::declval<B>()), bool>>>
  : std::true_type
{
};


template <typename B>
using boolean_sfinae = std::conjunction<
    std::is_object<B>, std::is_move_assignable<B>, std::is_move_constructible<B>, std::is_swappable<B>,
    boolean_sfinae_impl_conv<B>, boolean_sfinae_impl_not<B>, boolean_sfinae_impl_not_conv<B>,
    boolean_sfinae_impl_and<B, B>, boolean_sfinae_impl_and_conv<B, B>, boolean_sfinae_impl_and_rb<B>,
    boolean_sfinae_impl_and_rb_conv<B>, boolean_sfinae_impl_and_lb<B>, boolean_sfinae_impl_and_lb_conv<B>,
    boolean_sfinae_impl_or<B, B>, boolean_sfinae_impl_or_conv<B, B>, boolean_sfinae_impl_or_rb<B>,
    boolean_sfinae_impl_or_rb_conv<B>, boolean_sfinae_impl_or_lb<B>, boolean_sfinae_impl_or_lb_conv<B>,
    boolean_sfinae_impl_eq<B, B>, boolean_sfinae_impl_eq_conv<B, B>, boolean_sfinae_impl_eq_rb<B>,
    boolean_sfinae_impl_eq_rb_conv<B>, boolean_sfinae_impl_eq_lb<B>, boolean_sfinae_impl_eq_lb_conv<B>,
    boolean_sfinae_impl_neq<B, B>, boolean_sfinae_impl_neq_conv<B, B>, boolean_sfinae_impl_neq_rb<B>,
    boolean_sfinae_impl_neq_rb_conv<B>, boolean_sfinae_impl_neq_lb<B>, boolean_sfinae_impl_neq_lb_conv<B>>;

template <typename B>
using boolean_sfinae_t = typename boolean_sfinae<B>::type;

template <typename B>
inline constexpr auto boolean_sfinae_v = boolean_sfinae<B>::value;
\end{minted}

\section{Index}

Finally we have the three following benchmark programs using the above code.

\paragraph{Benchmark SFINAE:}
\begin{minted}{c++}
// bench_sfinae.cpp.erb

#include "dummy_structs.hpp"
#include "sfinae.hpp"

#include <type_traits>
#include <utility>


template <typename T, std::enable_if_t<boolean_sfinae_v<T>, void*> = nullptr>
bool foo_sfinae(T&& t) {
  return static_cast<bool>(std::forward<T>(t));
}

template <typename T, std::enable_if_t<not boolean_sfinae_v<T>, void*> = nullptr>
bool foo_sfinae(T&& t) {
  return false;
}

template <int N>
constexpr auto instantiate_both(){
  boolean_struct<N> b(true);
  non_boolean_struct<N> nb(true);

  auto a = foo_sfinae(b);
  auto c = foo_sfinae(nb);

  return a && c;
}

int main() {

#if defined(METABENCH)

  // This is ruby template syntax loop to unroll it from 0 to n=250 with a step of 5
  <% (0..n).each do |i| %>
    [[maybe_unused]] auto ret<%= i %> = instantiate_both<<%= i %>>();
  <% end %>

#endif

  return 0;
}
\end{minted}

\paragraph{Benchmark Concept:}
\begin{minted}{c++}
// bench_concept.cpp.erb

#include "dummy_structs.hpp"
#include "concepts.hpp"

#include <type_traits>
#include <utility>


template <typename T>
  requires boolean_c<T>
bool foo_c(T&& t) {
  return static_cast<bool>(std::forward<T>(t));
}

template <typename T>
bool foo_c(T&&) {
  return false;
}

template <int N>
constexpr auto instantiate_both(){
  boolean_struct<N> b(true);
  non_boolean_struct<N> nb(true);

  auto a = foo_c(b);
  auto c = foo_c(nb);

  return a && c;
}


int main() {

#if defined(METABENCH)

  // This is ruby template syntax loop to unroll it from 0 to n=250 with a step of 5
  <% (0..n).each do |i| %>
    [[maybe_unused]] auto ret<%= i %> = instantiate_both<<%= i %>>();
  <% end %>

#endif

  return 0;
}

\end{minted}

\paragraph{Benchmark Concept (fast):}
\begin{minted}{c++}
// bench_concept_fast.cpp.erb

#include "dummy_structs.hpp"
#include "concepts.hpp"

#include <type_traits>
#include <utility>


template <typename T>
  requires boolean_c<T>
bool foo_c(T&& t) {
  return static_cast<bool>(std::forward<T>(t));
}

template <typename T>
bool foo_c(T&&) {
  return false;
}

template <int N>
constexpr auto instantiate_both(){
  boolean_struct<N> b(true);
  non_boolean_struct<N> nb(true);

  auto a = foo_c(b);
  auto c = foo_c(nb);

  return a && c;
}


int main() {

#if defined(METABENCH)

  // This is ruby template syntax loop to unroll it from 0 to n=250 with a step of 5
  <% (0..n).each do |i| %>
    [[maybe_unused]] auto ret<%= i %> = instantiate_both<<%= i %>>();
  <% end %>

#endif

  return 0;
}
\end{minted}