\chapter{Image processing, its users, its needs}
\label{context_and_motivations.chap.image_processing_and_its_needs}

Image processing nowadays is very diverse and cover a wide variety of purpose. Henceforth there are many tools for many
different usages, from prototyping to production or from 2D image to graph \& complex images. All the complex image
processing applications relies on the same building blocks that are used and reused to get the wanted applicative
result. Following this assessment, it makes a lot of sense to provide a user-friendly toolbox of basic building blocks
that can be used to solve as many problem as possible, and with greet efficiency so that it does not need to be fully
rewritten when switching from prototyping to production. This paper discusses how we can achieve this goal with
genericity and how modern C++ (standard 2020) allows the implementation of generic, simple and efficient algorithms.
This paper later discusses the algorithm composability into pipeline (widely used in image processing) and how modern
C++, with views, provide the tools to naturally achieve this goal, being efficient by default. Furthermore, the methods
discussed in this paper are not specific to image processing and can be reapplied to other scientific library aiming at
solving different kind of problems.

Image processing has evolved over time to become a field where a very wide array of problematic has arisen. The time
when the 2-dimensional images whose colors were encoded within three 8-bits RGB channels, was a complex construct is
long gone. Instead, and in the last 20 years, there are many new kind of image being brought by the need in new
application domains, be they: medical (3D images from MRI), video games (real time 3D rendering, meshes, visual
effects), astronomy (hyperspectral images with thousands of bands), trees (tree of shapes), graphs (for segmentation,
maps), and so on.

However, despite those kinds of images may originates from different technology domains, they still are being processed
through common, more simple algorithms (such as mathematical morphology) which are the basis of more complex
computations. Thus, it makes sense to have a common base of algorithms to build upon, later, for more complex field
specific applications.

As such, the concept of genericity was introduced. It aims at providing a common ground about how an image should behave
when passed to basic algorithms needed for complex applications. This way, in theory, one only needs to write the
algorithm once for it to work with any given kind of image. In practice, it is also possible to provide a specific
version of a specific algorithm taking advantage of specific properties when available, to for instance, increase
execution speed or decrease memory consumption.

Another aspect that Image processing is in a dire need nowadays is efficiency. Be it with Artificial Intelligence that
needs deep learning on large data set of images or simply the images themselves that are very larges (e.g. 3D mesh with
over 5 million triangles, several hundred of Go for a satellite image), efficiency is pivotal and mandatory. However
genericity and efficiency are often conflicting. Coming up with a solution allying those two aspects is a long time
ongoing work, which is still of topicality nowadays.



\section{The practitioner}

When first approaching the image processing area, one becomes what we call a practitioner. A practitioner is the end
user of image processing libraries. Its skills mainly revolve around applied mathematics for image processing,
prototyping and algorithms. A practitioner aims at leveraging the features the libraries can offer to build his
application. For instance, a practitioner can be a researcher in medical imaging, an engineer build a facial recognition
application, a data scientist labeling its image set, etc. The needs of practitioner are mainly revolving around a fast
feedback loop. The developing environment must be easily accessible and installable. This way a practitioner can judge
quickly wether one library will answer his needs. The documentation of the library must be exhaustive and didactic with
examples. When prototyping, the library must provide fast feedback loops, as in a python notebook for instance. Finally
it must be easily integrated in a standard ecosystem such as being able to work with NumPy's array natively without
imposing its own types. To sum up, practitioner's programmatic skills do not need to be high as his main goal is to
focus on algorithms and mathematics formulas.


\section{The contributer}

A contributer is an advanced user of a library who is very comfortable with its inner working, philosophy, aims,
strengths and potential shortcomings. As such, he is able to add new specific features to library, fix some shortcomings
or bugs. Usually a contributer is able to add a feature needed for a practitioner to finish his application. Furthermore
he can then contribute back his features to the main project via pull requests if it is relevant. This way, a maintainer
will assess the pull request and review it. The two main points of a contributer are his deep knowledge of a library and
his ability to write code in the same language as the source code of it. Also, a contributer must have knowledge of
coding best practices such as writing unit tests which are mandatory when adding a feature to an existing library. To
facilitate contribution, a library must provide clear guidelines about the way to contribute, be easy to bootstrap and
compile without having heavy requirements on dependencies. The best case would be that the library is handled by
standard packages managers such as system apt or python conan.

\section{The maintainer}

The maintainer is usually the creator, founder of the library or someone that took over the project when the founder
stepped back. Also, when a library grows, it is not rare that regular contributers end up being maintainer as well to
help the project. The maintainer is in charge of keeping alive the project by fulfilling several aspects: upgrade and
release new features according to the user (practitioner) needs and the library philosophy. Also, a library may not
evolve as fast as the user may want it because of lack of time from maintainers. A lot of open source projects are
maintained by volunteers and lack of time is usually the main aspect slowing development progress. The maintainer is
also in charge of reviewing all the contributers pull requests. He must check if they are relevant and completed enough,
(for instance, presence of tests and documentation) to be integrated in the project. Indeed, merging a pull requests
equals to accepting to take care of this code in the future too. It means that further upgrade, bug fix, refactoring of
the project will consider this new code too. If the maintainer is not able to take care of this code then it should
propably not be integrated in the project in the first place. Any project and library has its maintainers. A maintainer
is someone very familiar with the inner working and architectural of the project. He is also someone that has some
history in the project to understand why some decisions has been made, what choices has been made at some points and
what the philosophy of the project is. It is important to be able to refuse a contribution that would go contrary to the
philosophy of the project, even a very interesting one. Finally the profile of a maintainer is one of a developer that
is used to the standard workflow in open source based on: forks, branches, merge/pull requests and continuous
integration.



\chapter{Library's perimeter and goals}


\section{Image processing at Epita's Research and Development Laboratory (LRDE)}

Expériences de Olena \& spécialisation en Morph. Math, Topo. Discrète), définitions de nos
besoins spécifiques (outils pour l'expérimentation, outils pour l'éducation, outils pour le logiciel de production)

The Research \& Development Laboratory of EPITA (LRDE)

diversity of use case
we have a diversity of users :
maintainers of libraries
researchers that use the library to




olena.2000.www
geraud.2000.icpr
duretlutz.2000.olena
burrus.2003.mpool
darbon.2002.ismm
burrus.2003.mpool
darbon.2004.ecoopphd
geraud.2006.scoop-pres
geraud.2008.mpool
levillain.2009.ismm
levillain.2010.icip
levillain.2010.wadgmm
levillain.2011.gretsi
levillain.2011.phd
geraud.2012.hdr
levillain.2012.wadgmm-lncs
levillain.2014.ciarp



In the same way libraries are collections of reusable code, it is
possible to create generic libraries made of reusable generic code.
In C ++ such libraries are composed of function and class templates.
But unlike traditional libraries, which contains compiled code (e.g.,
files ending in ' .a ', ' .so ', ' .lib ', ' .dll ', etc.), generic libraries are
merely collection or source code containing templates. Indeed
generic algorithms and data types cannot be turned into compiled
code unless they are specialized. Thus to preserve their most
general (abstract) form, they must be distributed and installed as
source files.
The most famous generic library is probably the Standard Tem-
plate Library (STL). The STL is a collection of generic containers
(character strings, vectors, lists, dictionaries, queues, etc.) and
generic algorithms for these data structures (for sorting, search-
ing, copying, applying transformations, etc.).
STL data structures and algorithms are orthogonal: any STL
algorithm can be applied to any STL container, as long as the
combination is valid (for instance, a random shuffling algorithm
cannot be applied to a container that does not support random
accesses). Therefore, data structures and algorithms from the
STL are loosely coupled: the former can be extended irrespective
of the later, and vice versa. This powerful property is due to
the use of iterators, acting as abstract handles on the values of
a container. The concept of iterator belongs to the set of design
patterns presented by Gamma et al.. STL algorithms do not
take containers as input, but iterators: therefore, they are not tied
to a particular data structure, or even to an abstract interface (e.g.,
the interface of a sequential or random-access container). The
only interface between containers and algorithms are iterators:
they are provided by the former and use by the latter. The
STL algorithms have been designed to be also compatible with
ordinary C arrays, as C pointers can be used as iterators as well.
Most of the STL has been integrated into the ISO C ++ standard
library.
We can illustrate the possibilities of the STL with the follow-
ing example: a dynamic array ( std::vector<int> ) of three in-
tegers is created ( push\_back() calls), sorted ( std::sort ), and
copied ( std::copy ) into a linked list of floating point values
2.2 history of generic programming 35
( std::list<float> ), with on-the-fly conversion of int values
into float ones.

\begin{minted}{cpp}
std::vector <int> ints;
ints.push_back(2);
ints.push_back(3);
ints.push_back(1);
std::sort(ints.begin(), ints.end());
std::list<float> floats;
std::copy(ints.begin(), ints.end(),
std::back_inserter(floats));
\end{minted}

Method calls c.begin() and c.end() return iterators pointing
to the beginning and (past) the end of the container c . std::
back\_inserter creates a special iterator inserting data at the end
of its container.
In addition to containers, algorithms and iterators, the STL
defines a set of concepts defining syntactic and semantic require-
ments over types. Concepts are addressed in Section 2.4 (p. 52).
Section 2.2.3 (p. 38) provides additional information on the STL.
Besides the STL, there are many successful generic libraries in
C ++ . We present some of them in Section 2.3 (p. 49).
Our proposal for a generic image processing platform is cen-
tered on a generic image processing library. We reuse and extend
ideas that have been made popular by the STL and other libraries,
including data structure/algorithm uncoupling, iterator-based
traversals, etc.

\begin{itemize}
  \item Domaines du TI et besoins par domaine
  \item Profils des utilisateurs et besoins en fonction des profils Intégrateur/Développeur vs Praticien
  \item Contexte du LRDE (Expériences de Olena \& spécialisation en Morph. Math, Topo. Discrète), définitions de nos
        besoins spécifiques (outils pour l'expérimentation, outils pour l'éducation, outils pour le logiciel de production)
  \item Définitions du périmètre de la bibliothèque et de ses objectifs:
        \begin{itemize}
          \item Performance
          \item Facile d'utilisation (UX client)
          \item Facile de développement (Core developer xp)
          \item Versatilité des types d'images
          \item Utilisable depuis Python, Orientée MM
        \end{itemize}
\end{itemize}